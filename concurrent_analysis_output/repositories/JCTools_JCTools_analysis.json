{
  "repository": "JCTools/JCTools",
  "analysis_date": "2025-06-09",
  "total_functions": 1391,
  "functions_with_tests": 42,
  "test_coverage_percentage": 3.01941049604601,
  "total_test_functions": 212,
  "functions_by_domain": {
    "data_structures": 605,
    "producer_consumer": 426,
    "general": 219,
    "atomic_operations": 77,
    "memory_management": 41,
    "synchronization": 11,
    "utilities": 9,
    "thread_management": 3
  },
  "functions_by_complexity": {
    "low": 1157,
    "medium": 202,
    "high": 25,
    "very_high": 7
  },
  "functions_by_type": {
    "method": 1367,
    "constructor": 24
  },
  "test_type_distribution": {
    "unit": 212
  },
  "top_sync_primitives": {
    "final": 835,
    "static": 131,
    "AtomicReference": 120,
    "AtomicReferenceArray": 117,
    "Lock": 91,
    "lock": 91,
    "volatile": 81,
    "wait": 81,
    "Condition": 49,
    "Thread": 44
  },
  "concurrency_patterns": {
    "immutable_object": 836,
    "thread_local_storage": 836,
    "future_pattern": 431,
    "double_checked_locking": 380,
    "compare_and_swap": 292,
    "singleton_pattern": 172,
    "producer_consumer": 148,
    "lock_free_algorithm": 100,
    "observer_pattern": 3
  },
  "functions": [
    {
      "name": "read",
      "signature": "public boolean read() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/target/classes/org/jctools/channels/ChannelConsumerTemplate.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "receiver.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final long pointer = readAcquire();\n        if (pointer == EOF) {\n            return false;\n        }\n        this.pointer = pointer;\n        receiver.accept(this);\n        readRelease(pointer);\n        return true;\n    }",
      "line_number": 20,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "Unknown",
      "method_type": "method"
    },
    {
      "name": "read",
      "signature": "public boolean read() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/resources/org/jctools/channels/ChannelConsumerTemplate.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "receiver.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final long pointer = readAcquire();\n        if (pointer == EOF) {\n            return false;\n        }\n        this.pointer = pointer;\n        receiver.accept(this);\n        readRelease(pointer);\n        return true;\n    }",
      "line_number": 20,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "Unknown",
      "method_type": "method"
    },
    {
      "name": "getAddress",
      "signature": "public static long getAddress(ByteBuffer buffy) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/UnsafeDirectByteBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn UNSAFE.getLong(buffy, addressOffset);\n\t}",
      "line_number": 12,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "UnsafeDirectByteBuffer",
      "method_type": "method"
    },
    {
      "name": "allocateAlignedByteBuffer",
      "signature": "public static ByteBuffer allocateAlignedByteBuffer(int capacity, long align) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/UnsafeDirectByteBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "ByteBuffer.allocateDirect",
        "bitCount",
        "allocateDirect",
        "IllegalArgumentException",
        "Long.bitCount"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 2,
      "source_code": "\t\tif (Long.bitCount(align) != 1) {\n\t\t\tthrow new IllegalArgumentException(\"Alignment must be a power of 2\");\n\t\t}\n\t\tByteBuffer buffy = ByteBuffer.allocateDirect((int) (capacity + align));\n\t\treturn alignedSlice(capacity, align, buffy);\n\t}",
      "line_number": 16,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "UnsafeDirectByteBuffer",
      "method_type": "method"
    },
    {
      "name": "SimpleCompiler",
      "signature": "public SimpleCompiler() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/SimpleCompiler.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getSystemJavaCompiler",
        "ToolProvider.getSystemJavaCompiler"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        compiler = ToolProvider.getSystemJavaCompiler();\n    }",
      "line_number": 58,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SimpleCompiler",
      "method_type": "constructor"
    },
    {
      "name": "compile",
      "signature": "public CompilationResult compile(final String name, final String src) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/SimpleCompiler.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "StringWrappingJavaFile"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return compile(asList(new StringWrappingJavaFile(name, src)));\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SimpleCompiler",
      "method_type": "method"
    },
    {
      "name": "compile",
      "signature": "public CompilationResult compile(final List<StringWrappingJavaFile> javaFiles) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/SimpleCompiler.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "DiagnosticsHolder",
        "call",
        "CompilationResult",
        "URLClassLoader",
        "task.call",
        "getTask",
        "compiler.getTask",
        "StringWrappingJavaFile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "\n        DiagnosticsHolder holder = new DiagnosticsHolder();\n        CompilationTask task = compiler.getTask(null, null, holder, options, null, javaFiles);\n\n        if (task.call()) {\n            return new CompilationResult(new URLClassLoader(compilationDirectoryUrls), holder.diagnostics);\n        } else {\n            return new CompilationResult(holder.diagnostics);\n        }\n    }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SimpleCompiler",
      "method_type": "method"
    },
    {
      "name": "CompilationResult",
      "signature": "public CompilationResult(final ClassLoader classLoader, List<Diagnostic<StringWrappingJavaFile>> diagnostics) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/CompilationResult.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "StringWrappingJavaFile"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        this.diagnostics = diagnostics;\n        this.classLoader = classLoader;\n    }",
      "line_number": 27,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CompilationResult",
      "method_type": "constructor"
    },
    {
      "name": "getClassLoader",
      "signature": "public ClassLoader getClassLoader() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/CompilationResult.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return classLoader;\n    }",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CompilationResult",
      "method_type": "method"
    },
    {
      "name": "StringWrappingJavaFile",
      "signature": "public StringWrappingJavaFile(String name, String code) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/StringWrappingJavaFile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super(getFileUri(name), Kind.SOURCE);\n        this.code = code;\n    }",
      "line_number": 39,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "StringWrappingJavaFile",
      "method_type": "constructor"
    },
    {
      "name": "getFileUri",
      "signature": "private static URI getFileUri(String name) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/StringWrappingJavaFile.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "replace",
        "name.replace",
        "create",
        "URI.create"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return URI.create(\"string:///\" + name.replace('.', '/') + Kind.SOURCE.extension);\n    }",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "StringWrappingJavaFile",
      "method_type": "method"
    },
    {
      "name": "getCharContent",
      "signature": "public CharSequence getCharContent(boolean ignoreEncodingErrors) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/StringWrappingJavaFile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return code;\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "StringWrappingJavaFile",
      "method_type": "method"
    },
    {
      "name": "fromFile",
      "signature": "public static Template fromFile(final Class<?> resourceRoot, final String fileName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "resourceRoot.getResourceAsStream",
        "IllegalArgumentException",
        "getResourceAsStream"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        InputStream templateStream = resourceRoot.getResourceAsStream(fileName);\n        if(templateStream == null) {\n            throw new IllegalArgumentException(\"Template file of the name: \\'\"+fileName+\"\\' was not found.\");\n        }\n        return fromStream(templateStream);\n    }",
      "line_number": 37,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "fromStream",
      "signature": "private static Template fromStream(InputStream templateStream) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "InputStreamReader",
        "readLine",
        "reader.close",
        "StringBuilder",
        "BufferedReader",
        "reader.readLine",
        "IllegalArgumentException",
        "buffer.append",
        "append",
        "buffer.toString",
        "toString",
        "Template",
        "close"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        if(templateStream == null) {\n            throw new IllegalArgumentException(\"Null template stream\");\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(templateStream));\n        try {\n            try {\n                StringBuilder buffer = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    buffer.append(line);\n                    buffer.append('\\n');\n                }\n                return new Template(buffer.toString());\n            } finally {\n                reader.close();\n            }\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }",
      "line_number": 45,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "Template",
      "signature": "public Template(final String template) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        this.template = template;\n    }",
      "line_number": 67,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "render",
      "signature": "private void render(Object obj, StringBuilder result, boolean last) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "render",
        "size",
        "values.get",
        "result.append",
        "get",
        "append",
        "values.size",
        "body.render"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        index = 0;\n        while(scanNextTag()) {\n            copyPrefixTo(result);\n            index += 2;\n            if (isLoopTag()) {\n                index++;\n                String tagName = readTagName();\n                Template body = extractLoopBody(tagName);\n                List<?> values = (List<?>) readTagValue(tagName, obj, last);\n                int lastIndex = values.size() - 1;\n                for (int i = 0; i < values.size(); i++) {\n                    body.render(values.get(i), result, i == lastIndex);\n                }\n            } else {\n                String tagName = readTagName();\n                result.append(readTagValue(tagName, obj, false));\n            }\n        }\n        copySuffixTo(result);\n    }",
      "line_number": 81,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "scanNextTag",
      "signature": "private boolean scanNextTag() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "obj.getClass",
        "result.append",
        "get",
        "getMethod",
        "getField",
        "template.substring",
        "IllegalArgumentException",
        "substring",
        "append",
        "cls.getField",
        "template.indexOf",
        "cls.getMethod",
        "indexOf",
        "invoke",
        "getClass",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 21,
      "source_code": "        previousIndex = index;\n        index = template.indexOf(\"{{\", index);\n        return index != -1;\n    }\n\n    private void copyPrefixTo(StringBuilder result) {\n        result.append(template, previousIndex, index);\n    }\n\n    private Object readTagValue(String tagName, Object obj, boolean last) {\n        Object value = readBuiltinTag(tagName, obj, last);\n        if (value != null)\n            return value;\n\n        return readField(tagName, obj);\n    }\n\n    private Object readBuiltinTag(String tagName, Object obj, boolean last) {\n        if (\"notLast\".equals(tagName)) {\n            if (last) {\n                return emptyList();\n            } else {\n                return singletonList(obj);\n            }\n        }\n\n        return null;\n    }\n\n    private Object readField(String tagName, Object obj) {\n        Class<?> cls = obj.getClass();\n        try {\n            return cls.getField(tagName)\n                      .get(obj);\n        } catch (NoSuchFieldException ignored) {\n            try {\n                return cls.getMethod(tagName)\n                          .invoke(obj);\n            } catch (NoSuchMethodException e) {\n                throw new IllegalArgumentException(e);\n            } catch (InvocationTargetException e) {\n                throw new IllegalArgumentException(e);\n            } catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(e);\n            }\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    private String readTagName() {\n        int endTagIndex = template.indexOf(\"}}\", index);\n        String tagName = template.substring(index, endTagIndex);\n        index = endTagIndex + 2;\n        return tagName;\n    }",
      "line_number": 115,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "readTagValue",
      "signature": "private Object readTagValue(String tagName, Object obj, boolean last) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 1,
      "source_code": "        Object value = readBuiltinTag(tagName, obj, last);\n        if (value != null)\n            return value;\n\n        return readField(tagName, obj);\n    }",
      "line_number": 125,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "readBuiltinTag",
      "signature": "private Object readBuiltinTag(String tagName, Object obj, boolean last) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 4,
      "source_code": "        if (\"notLast\".equals(tagName)) {\n            if (last) {\n                return emptyList();\n            } else {\n                return singletonList(obj);\n            }\n        }\n\n        return null;\n    }",
      "line_number": 133,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "readField",
      "signature": "private Object readField(String tagName, Object obj) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/util/Template.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "obj.getClass",
        "getMethod",
        "get",
        "getField",
        "IllegalArgumentException",
        "cls.getMethod",
        "cls.getField",
        "invoke",
        "getClass"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        Class<?> cls = obj.getClass();\n        try {\n            return cls.getField(tagName)\n                      .get(obj);\n        } catch (NoSuchFieldException ignored) {\n            try {\n                return cls.getMethod(tagName)\n                          .invoke(obj);\n            } catch (NoSuchMethodException e) {\n                throw new IllegalArgumentException(e);\n            } catch (InvocationTargetException e) {\n                throw new IllegalArgumentException(e);\n            } catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(e);\n            }\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }",
      "line_number": 145,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "templating",
      "method_type": "method"
    },
    {
      "name": "getRequiredBufferSize",
      "signature": "public static int getRequiredBufferSize(final int capacity, final int messageSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "align",
        "Pow2.align",
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        int alignedMessageSize = (int) Pow2.align(messageSize + MESSAGE_INDICATOR_SIZE, MESSAGE_INDICATOR_SIZE);\n        return HEADER_SIZE + (Pow2.roundToPowerOfTwo(capacity) * alignedMessageSize);\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "createReferenceArray",
      "signature": "protected static Object[] createReferenceArray(final int capacity, int referenceMessageSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (referenceMessageSize > 0) {\n            return new Object[getRequiredArraySize(capacity, referenceMessageSize)];\n        } else {\n            return null;\n        }\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "getRequiredArraySize",
      "signature": "public static int getRequiredArraySize(final int capacity, final int primitiveMessageSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return Pow2.roundToPowerOfTwo(capacity) * primitiveMessageSize;\n    }",
      "line_number": 69,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "OffHeapFixedMessageSizeRingBuffer",
      "signature": "public OffHeapFixedMessageSizeRingBuffer(final int capacity, final int primitiveMessageSize, int referenceMessageSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this(allocateAlignedByteBuffer(getRequiredBufferSize(capacity, primitiveMessageSize), CACHE_LINE_SIZE),\n                Pow2.roundToPowerOfTwo(capacity),\n                true,\n                true,\n                true,\n                primitiveMessageSize,\n                createReferenceArray(capacity, referenceMessageSize),\n                referenceMessageSize);\n    }",
      "line_number": 73,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "constructor"
    },
    {
      "name": "capacity",
      "signature": "public final int capacity() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return (int) (mask + 1);\n    }",
      "line_number": 142,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public final int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return (int) (lvProducerIndex() - lvConsumerIndex());\n    }",
      "line_number": 145,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public final boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return lvProducerIndex() == lvConsumerIndex();\n    }",
      "line_number": 149,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "isReadReleased",
      "signature": "protected final boolean isReadReleased(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "getIntVolatile",
        "UNSAFE.getIntVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getIntVolatile(null, offset) == READ_RELEASE_INDICATOR;\n    }",
      "line_number": 153,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeReleaseState",
      "signature": "protected final void writeReleaseState(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedInt(null, offset, WRITE_RELEASE_INDICATOR);\n    }",
      "line_number": 157,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readReleaseState",
      "signature": "protected final void readReleaseState(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedInt(null, offset, READ_RELEASE_INDICATOR);\n    }",
      "line_number": 161,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeAcquireState",
      "signature": "protected final void writeAcquireState(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedInt(null, offset, WRITE_ACQUIRE_INDICATOR);\n    }",
      "line_number": 165,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readAcquireState",
      "signature": "protected final void readAcquireState(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedInt(null, offset, READ_ACQUIRE_INDICATOR);\n    }",
      "line_number": 169,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "offsetForIndex",
      "signature": "protected final long offsetForIndex(long currentHead) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        return offsetForIndex(bufferAddress,  mask, messageSize, currentHead);\n    }",
      "line_number": 173,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "offsetForIndex",
      "signature": "protected static long offsetForIndex(long bufferAddress, long mask, int messageSize, long currentHead) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return bufferAddress + ((currentHead & mask) * messageSize);\n    }",
      "line_number": 177,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "relativeIndexForOffset",
      "signature": "protected final long relativeIndexForOffset(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        return relativeIndexForOffset(bufferAddress, messageSize, offset);\n    }",
      "line_number": 181,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "relativeIndexForOffset",
      "signature": "protected static long relativeIndexForOffset(long bufferAddress, int messageSize, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return (offset - bufferAddress) / messageSize;\n    }",
      "line_number": 195,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "protected final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(null, consumerIndexAddress);\n    }",
      "line_number": 199,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "protected final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(null, consumerIndexAddress);\n    }",
      "line_number": 203,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "protected final void soConsumerIndex(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(null, consumerIndexAddress, value);\n    }",
      "line_number": 207,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "protected final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(null, producerIndexAddress);\n    }",
      "line_number": 211,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "protected final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(null, producerIndexAddress);\n    }",
      "line_number": 215,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "protected final void soProducerIndex(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(null, producerIndexAddress, value);\n    }",
      "line_number": 219,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "arrayIndexForCursor",
      "signature": "protected final long arrayIndexForCursor(long currentHead) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        return arrayIndexForCursor(mask, referenceMessageSize, currentHead);\n    }",
      "line_number": 223,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "consumerReferenceArrayIndex",
      "signature": "protected long consumerReferenceArrayIndex(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final long consumerIndex = relativeIndexForOffset(offset);\n        return arrayIndexForCursor(consumerIndex);\n    }",
      "line_number": 233,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "producerReferenceArrayIndex",
      "signature": "protected long producerReferenceArrayIndex(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final long producerIndex = relativeIndexForOffset(offset);\n        return arrayIndexForCursor(producerIndex);\n    }",
      "line_number": 238,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeReference",
      "signature": "protected void writeReference(long offset, Object reference) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UnsafeRefArrayAccess.calcRefElementOffset",
        "spRefElement",
        "calcRefElementOffset",
        "UnsafeRefArrayAccess.spRefElement"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        assert referenceMessageSize != 0 : \"References are not in use\";\n        // Is there a way to compute the element offset once and just\n        // arithmetic?\n        UnsafeRefArrayAccess.spRefElement(references, UnsafeRefArrayAccess.calcRefElementOffset(offset), reference);\n    }",
      "line_number": 248,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readReference",
      "signature": "protected Object readReference(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/OffHeapFixedMessageSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lpRefElement",
        "calcRefElementOffset",
        "UnsafeRefArrayAccess.lpRefElement",
        "UnsafeRefArrayAccess.calcRefElementOffset"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        assert referenceMessageSize != 0 : \"References are not in use\";\n        // Is there a way to compute the element offset once and just\n        // arithmetic?\n        return UnsafeRefArrayAccess.lpRefElement(references, UnsafeRefArrayAccess.calcRefElementOffset(offset));\n    }",
      "line_number": 260,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "OffHeapFixedMessageSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "getSizeInBytes",
      "signature": "public int getSizeInBytes() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Mapper.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "inspector.getSizeInBytes",
        "getSizeInBytes"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return Primitive.INT.sizeInBytes + inspector.getSizeInBytes();\n    }",
      "line_number": 45,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldUnderstandInterfaceFields",
          "signature": "public void shouldUnderstandInterfaceFields() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        assertEquals(EXAMPLE_SIZE_IN_BYTES, mapper.getSizeInBytes());\n        StubFlyweight example = newFlyweight();\n        assertNotNull(example);\n        assertTrue(example instanceof Example);\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [
            "newFlyweight",
            "getSizeInBytes"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToReadAndWriteData",
          "signature": "public void shouldBeAbleToReadAndWriteData() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 50,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToMoveFlyweights",
          "signature": "public void shouldBeAbleToMoveFlyweights() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        StubFlyweight writeCursor = (StubFlyweight) writer;\n        StubFlyweight readCursor = (StubFlyweight) reader;\n\n        writeCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n        readCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 62,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "moveTo",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "Mapper",
      "method_type": "method"
    },
    {
      "name": "newFlyweight",
      "signature": "public <I> I newFlyweight(Class<I> implementationParent, String templateFileName, Template template, Object... args) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Mapper.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "render",
        "compile",
        "model.className",
        "ClassViewModel",
        "I",
        "template.render",
        "className",
        "compiler.compile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        Class<?>[] constructorParameterTypes = getTypes(args);\n        ClassViewModel model = new ClassViewModel(implementationParent, constructorParameterTypes, structInterface,\n                inspector);\n        String source = template.render(model);\n        debugLogSource(source);\n        CompilationResult result = compiler.compile(model.className(), source);\n        checkCompileFailures(templateFileName, result);\n        return instantiateImplementation(constructorParameterTypes, model.className(), result, args);\n    }",
      "line_number": 54,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldUnderstandInterfaceFields",
          "signature": "public void shouldUnderstandInterfaceFields() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        assertEquals(EXAMPLE_SIZE_IN_BYTES, mapper.getSizeInBytes());\n        StubFlyweight example = newFlyweight();\n        assertNotNull(example);\n        assertTrue(example instanceof Example);\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [
            "newFlyweight",
            "getSizeInBytes"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToReadAndWriteData",
          "signature": "public void shouldBeAbleToReadAndWriteData() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 50,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToMoveFlyweights",
          "signature": "public void shouldBeAbleToMoveFlyweights() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        StubFlyweight writeCursor = (StubFlyweight) writer;\n        StubFlyweight readCursor = (StubFlyweight) reader;\n\n        writeCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n        readCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 62,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "moveTo",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "Mapper",
      "method_type": "method"
    },
    {
      "name": "checkCompileFailures",
      "signature": "private void checkCompileFailures(String templateFile, CompilationResult result) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Mapper.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "println",
        "isSuccessful",
        "getDiagnostics",
        "isEmpty",
        "IllegalArgumentException",
        "diagnostics.isEmpty",
        "result.isSuccessful",
        "StringWrappingJavaFile",
        "result.getDiagnostics",
        "err.println"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        List<Diagnostic<StringWrappingJavaFile>> diagnostics = result.getDiagnostics();\n\n        if (debugEnabled) {\n            if (diagnostics.isEmpty()) {\n                System.err.println(\"No compile diagnostics for: \" + templateFile);\n            } else {\n                System.err.println(\"---------------------------------------\");\n                System.err.println(\"Compile diagnostics for: \" + templateFile);\n                for (Diagnostic<StringWrappingJavaFile> diagnostic : diagnostics) {\n                    System.err.println(diagnostic);\n                    System.err.println();\n                }\n                System.err.println(\"---------------------------------------\");\n            }\n        }\n\n        if (!result.isSuccessful()) {\n            throw new IllegalArgumentException(\"Unable to compile \" + templateFile);\n        }\n    }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldUnderstandInterfaceFields",
          "signature": "public void shouldUnderstandInterfaceFields() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        assertEquals(EXAMPLE_SIZE_IN_BYTES, mapper.getSizeInBytes());\n        StubFlyweight example = newFlyweight();\n        assertNotNull(example);\n        assertTrue(example instanceof Example);\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [
            "newFlyweight",
            "getSizeInBytes"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToReadAndWriteData",
          "signature": "public void shouldBeAbleToReadAndWriteData() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 50,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToMoveFlyweights",
          "signature": "public void shouldBeAbleToMoveFlyweights() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        StubFlyweight writeCursor = (StubFlyweight) writer;\n        StubFlyweight readCursor = (StubFlyweight) reader;\n\n        writeCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n        readCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 62,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "moveTo",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "Mapper",
      "method_type": "method"
    },
    {
      "name": "getTypes",
      "signature": "private Class<?>[] getTypes(Object... args) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Mapper.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getClass"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        Class<?>[] types = new Class<?>[args.length];\n        for (int i = 0; i < args.length; i++) {\n            types[i] = simplifyType(args[i].getClass());\n        }\n        return types;\n    }",
      "line_number": 109,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldUnderstandInterfaceFields",
          "signature": "public void shouldUnderstandInterfaceFields() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        assertEquals(EXAMPLE_SIZE_IN_BYTES, mapper.getSizeInBytes());\n        StubFlyweight example = newFlyweight();\n        assertNotNull(example);\n        assertTrue(example instanceof Example);\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [
            "newFlyweight",
            "getSizeInBytes"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToReadAndWriteData",
          "signature": "public void shouldBeAbleToReadAndWriteData() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 50,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldBeAbleToMoveFlyweights",
          "signature": "public void shouldBeAbleToMoveFlyweights() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mapping/MapperTest.java",
          "source_code": "        Example writer = (Example) newFlyweight();\n        Example reader = (Example) newFlyweight();\n\n        StubFlyweight writeCursor = (StubFlyweight) writer;\n        StubFlyweight readCursor = (StubFlyweight) reader;\n\n        writeCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n        readCursor.moveTo(startAddress + EXAMPLE_SIZE_IN_BYTES);\n\n        writer.setFoo(5);\n        assertEquals(5, reader.getFoo());\n\n        writer.setBar(6L);\n        assertEquals(6L, reader.getBar());\n    }",
          "line_number": 62,
          "tested_class": "",
          "tested_methods": [
            "setBar",
            "setFoo",
            "newFlyweight",
            "moveTo",
            "getBar",
            "getFoo"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "Mapper",
      "method_type": "method"
    },
    {
      "name": "Variable",
      "signature": "public Variable(String type, String name, int fieldOffset, String unsafeMethodSuffix) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Variable.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this.type = type;\n        this.name = name;\n        this.fieldOffset = fieldOffset;\n        this.unsafeMethodSuffix = unsafeMethodSuffix;\n    }",
      "line_number": 10,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "Variable",
      "method_type": "constructor"
    },
    {
      "name": "of",
      "signature": "static Primitive of(Class<?> type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Primitive.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "toUpperCase",
        "valueOf",
        "getName",
        "Primitive.valueOf",
        "type.getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\tString name = type.getName().toUpperCase();\n\t\treturn Primitive.valueOf(name);\n\t}",
      "line_number": 55,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "Primitive",
      "method_type": "method"
    },
    {
      "name": "replaceWithPrimitive",
      "signature": "static Class<?> replaceWithPrimitive(Class<?> boxedJavaType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Primitive.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "values",
        "Primitive.values"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 2,
      "source_code": "        for (Primitive primitive: Primitive.values())\n            if (primitive.boxedJavaType == boxedJavaType)\n                return primitive.javaEquivalent;\n\n        return boxedJavaType;\n    }",
      "line_number": 60,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "Primitive",
      "method_type": "method"
    },
    {
      "name": "simplifyType",
      "signature": "public static Class<?> simplifyType(Class<?> type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Primitive.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        type = replaceWithPrimitive(type);\n        type = usePublicApiClass(type);\n        return type;\n    }",
      "line_number": 68,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "Primitive",
      "method_type": "method"
    },
    {
      "name": "usePublicApiClass",
      "signature": "private static Class<?> usePublicApiClass(Class<?> type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/Primitive.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "isAssignableFrom",
        "getSimpleName",
        "type.getSimpleName",
        "equals",
        "class.isAssignableFrom"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (\"DirectByteBuffer\".equals(type.getSimpleName()))\n            return ByteBuffer.class;\n\n        if (ChannelReceiver.class.isAssignableFrom(type))\n            return ChannelReceiver.class;\n\n        return type;\n    }",
      "line_number": 74,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "Primitive",
      "method_type": "method"
    },
    {
      "name": "className",
      "signature": "public String className() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/ClassViewModel.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "structInterface.getSimpleName",
        "getSimpleName",
        "implementationParent.getSimpleName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return implementationParent.getSimpleName() + \"_\" + structInterface.getSimpleName();\n    }",
      "line_number": 39,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ClassViewModel",
      "method_type": "method"
    },
    {
      "name": "cleanClassName",
      "signature": "private String cleanClassName(Class<?> cls) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/ClassViewModel.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "replace",
        "cls.getName",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return cls.getName().replace('$', '.');\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ClassViewModel",
      "method_type": "method"
    },
    {
      "name": "constructorParams",
      "signature": "public List<Variable> constructorParams() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/ClassViewModel.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "add",
        "variables.add",
        "getName",
        "ArrayList",
        "Variable"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        List<Variable> variables = new ArrayList<Variable>(constructorParams.length);\n        for (int i = 0; i < constructorParams.length; i++) {\n            variables.add(new Variable(constructorParams[i].getName(), \"arg\" + i, 0, \"\"));\n        }\n        return variables;\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ClassViewModel",
      "method_type": "method"
    },
    {
      "name": "fields",
      "signature": "public List<Variable> fields() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mapping/ClassViewModel.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "of",
        "type.unsafeMethodSuffix",
        "fields.add",
        "add",
        "method.getReturnType",
        "getName",
        "Primitive.of",
        "ArrayList",
        "unsafeMethodSuffix",
        "Variable",
        "substring",
        "method.getName",
        "getReturnType",
        "javaEquivalent.getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        int fieldOffset = SpscOffHeapFixedSizeRingBuffer.MESSAGE_INDICATOR_SIZE;\n        List<Variable> fields = new ArrayList<Variable>();\n        for (Method method : inspector.getters) {\n            Primitive type = Primitive.of(method.getReturnType());\n            String name = method.getName().substring(3);\n            fields.add(new Variable(type.javaEquivalent.getName(), name, fieldOffset, type.unsafeMethodSuffix()));\n            fieldOffset += type.sizeInBytes;\n        }\n        return fields;\n    }",
      "line_number": 64,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ClassViewModel",
      "method_type": "method"
    },
    {
      "name": "getLookaheadStep",
      "signature": "public static int getLookaheadStep(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "min",
        "Math.min"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return Math.min(capacity / 4, MAX_LOOK_AHEAD_STEP);\n    }",
      "line_number": 42,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "SpscOffHeapFixedSizeRingBuffer",
      "signature": "public SpscOffHeapFixedSizeRingBuffer(final int capacity, final int messageSize, final int referenceMessageSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this(allocateAlignedByteBuffer(getRequiredBufferSize(capacity, messageSize), CACHE_LINE_SIZE),\n                Pow2.roundToPowerOfTwo(capacity),\n                true,\n                true,\n                true,\n                messageSize,\n                createReferenceArray(capacity, referenceMessageSize),\n                referenceMessageSize);\n    }",
      "line_number": 46,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "memory_management",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "constructor"
    },
    {
      "name": "writeAcquire",
      "signature": "protected final long writeAcquire() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        final long producerIndex = lpProducerIndex();\n        final long producerLookAhead = lpLookAheadCache();\n        final long producerOffset = offsetForIndex(bufferAddress, mask, messageSize, producerIndex);\n        // verify next lookAheadStep messages are clear to write\n        if (producerIndex >= producerLookAhead) {\n            final long nextLookAhead = producerIndex + lookAheadStep;\n            if (isReadReleased(offsetForIndex(nextLookAhead))) {\n                spLookAheadCache(nextLookAhead);\n            }\n            // OK, can't look ahead, but maybe just next item is ready?\n            else if (!isReadReleased(producerOffset)) {\n                return EOF;\n            }\n        }\n        soProducerIndex(producerIndex + 1); // StoreStore\n//        writeAcquireState(producerOffset);\n        // return offset for current producer index\n        return producerOffset;\n    }",
      "line_number": 97,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeRelease",
      "signature": "protected final void writeRelease(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        writeReleaseState(offset);\n    }",
      "line_number": 119,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeRelease",
      "signature": "protected final void writeRelease(long offset, int type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        assert type != 0;\n        UNSAFE.putOrderedInt(null, offset, type);\n    }",
      "line_number": 124,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readAcquire",
      "signature": "protected final long readAcquire() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long consumerIndex = lpConsumerIndex();\n        final long consumerOffset = offsetForIndex(consumerIndex);\n        if (isReadReleased(consumerOffset)) {\n            return EOF;\n        }\n        soConsumerIndex(consumerIndex + 1); // StoreStore\n//        readAcquireState(consumerOffset);\n        return consumerOffset;\n    }",
      "line_number": 130,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readRelease",
      "signature": "protected final void readRelease(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        readReleaseState(offset);\n\n    }",
      "line_number": 142,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "lpLookAheadCache",
      "signature": "private long lpLookAheadCache() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(null, producerLookAheadCacheAddress);\n    }",
      "line_number": 147,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "memory_management",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "spLookAheadCache",
      "signature": "private void spLookAheadCache(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putLong",
        "UNSAFE.putLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putLong(producerLookAheadCacheAddress, value);\n    }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "memory_management",
      "class_name": "SpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "SpscChannel",
      "signature": "public SpscChannel(final ByteBuffer buffer, final int requestedCapacity, final Class<E> type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscChannel.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Mapper",
        "mapper.getSizeInBytes",
        "getSizeInBytes",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this.requestedCapacity = requestedCapacity;\n        this.maximumCapacity = getMaximumCapacity(requestedCapacity);\n        this.buffer = buffer;\n        mapper = new Mapper<E>(type, debugEnabled);\n        elementSize = mapper.getSizeInBytes();\n\n        checkSufficientCapacity();\n        checkByteBuffer();\n\n        producer = newProducer(type, buffer, maximumCapacity, elementSize);\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldKnowItsCapacity",
          "signature": "public void shouldKnowItsCapacity() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEquals(REQUESTED_CAPACITY, channel.requestedCapacity());\n        assertEquals(MAXIMUM_CAPACITY, channel.maximumCapacity());\n    }",
          "line_number": 36,
          "tested_class": "",
          "tested_methods": [
            "maximumCapacity",
            "requestedCapacity"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldInitiallyBeEmpty",
          "signature": "public void shouldInitiallyBeEmpty() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEmpty();\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [],
          "test_type": "unit"
        },
        {
          "name": "shouldWriteAnObject",
          "signature": "public void shouldWriteAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setFoo(5);\n        writer.setBar(10L);\n        assertTrue(producer.commit());\n        assertSize(1);\n    }",
          "line_number": 47,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "setFoo",
            "currentElement",
            "commit"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldReadAnObject",
          "signature": "public void shouldReadAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        shouldWriteAnObject();\n\n        assertTrue(consumer.read());\n        assertEmpty();\n    }",
          "line_number": 58,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "shouldWriteAnObject",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadFromEmptyChannel",
          "signature": "public void shouldNotReadFromEmptyChannel() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertEmpty();\n        assertFalse(consumer.read());\n    }",
          "line_number": 68,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadUnCommittedMessages",
          "signature": "public void shouldNotReadUnCommittedMessages() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setBar(10L);\n\n        assertFalse(consumer.read());\n    }",
          "line_number": 76,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "read",
            "newConsumer",
            "currentElement"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotOverrunBuffer",
          "signature": "public void shouldNotOverrunBuffer() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        for (int i = 0; i < REQUESTED_CAPACITY; i++) {\n            assertTrue(producer.claim());\n            assertTrue(producer.commit());\n        }\n\n        for (int i = REQUESTED_CAPACITY; i < MAXIMUM_CAPACITY; i++) {\n            // Unknown what happens here.\n            producer.claim();\n            producer.commit();\n        }\n\n        assertFalse(producer.claim());\n        assertTrue(channel.size() >= REQUESTED_CAPACITY);\n        assertTrue(channel.size() <= MAXIMUM_CAPACITY);\n    }",
          "line_number": 88,
          "tested_class": "",
          "tested_methods": [
            "for",
            "claim",
            "commit"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "SpscChannel",
      "method_type": "constructor"
    },
    {
      "name": "getMaximumCapacity",
      "signature": "private int getMaximumCapacity(int requestedCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscChannel.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return Pow2.roundToPowerOfTwo(requestedCapacity + getLookaheadStep(requestedCapacity));\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldKnowItsCapacity",
          "signature": "public void shouldKnowItsCapacity() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEquals(REQUESTED_CAPACITY, channel.requestedCapacity());\n        assertEquals(MAXIMUM_CAPACITY, channel.maximumCapacity());\n    }",
          "line_number": 36,
          "tested_class": "",
          "tested_methods": [
            "maximumCapacity",
            "requestedCapacity"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldInitiallyBeEmpty",
          "signature": "public void shouldInitiallyBeEmpty() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEmpty();\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [],
          "test_type": "unit"
        },
        {
          "name": "shouldWriteAnObject",
          "signature": "public void shouldWriteAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setFoo(5);\n        writer.setBar(10L);\n        assertTrue(producer.commit());\n        assertSize(1);\n    }",
          "line_number": 47,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "setFoo",
            "currentElement",
            "commit"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldReadAnObject",
          "signature": "public void shouldReadAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        shouldWriteAnObject();\n\n        assertTrue(consumer.read());\n        assertEmpty();\n    }",
          "line_number": 58,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "shouldWriteAnObject",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadFromEmptyChannel",
          "signature": "public void shouldNotReadFromEmptyChannel() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertEmpty();\n        assertFalse(consumer.read());\n    }",
          "line_number": 68,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadUnCommittedMessages",
          "signature": "public void shouldNotReadUnCommittedMessages() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setBar(10L);\n\n        assertFalse(consumer.read());\n    }",
          "line_number": 76,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "read",
            "newConsumer",
            "currentElement"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotOverrunBuffer",
          "signature": "public void shouldNotOverrunBuffer() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        for (int i = 0; i < REQUESTED_CAPACITY; i++) {\n            assertTrue(producer.claim());\n            assertTrue(producer.commit());\n        }\n\n        for (int i = REQUESTED_CAPACITY; i < MAXIMUM_CAPACITY; i++) {\n            // Unknown what happens here.\n            producer.claim();\n            producer.commit();\n        }\n\n        assertFalse(producer.claim());\n        assertTrue(channel.size() >= REQUESTED_CAPACITY);\n        assertTrue(channel.size() <= MAXIMUM_CAPACITY);\n    }",
          "line_number": 88,
          "tested_class": "",
          "tested_methods": [
            "for",
            "claim",
            "commit"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "SpscChannel",
      "method_type": "method"
    },
    {
      "name": "checkSufficientCapacity",
      "signature": "private void checkSufficientCapacity() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscChannel.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "buffer.capacity",
        "capacity"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final int requiredCapacityInBytes = getRequiredBufferSize(maximumCapacity, elementSize);\n        if (buffer.capacity() < requiredCapacityInBytes) {\n            throw new IllegalArgumentException(\"Failed to meet required maximumCapacity in bytes: \"\n                    + requiredCapacityInBytes);\n        }\n    }",
      "line_number": 71,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldKnowItsCapacity",
          "signature": "public void shouldKnowItsCapacity() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEquals(REQUESTED_CAPACITY, channel.requestedCapacity());\n        assertEquals(MAXIMUM_CAPACITY, channel.maximumCapacity());\n    }",
          "line_number": 36,
          "tested_class": "",
          "tested_methods": [
            "maximumCapacity",
            "requestedCapacity"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldInitiallyBeEmpty",
          "signature": "public void shouldInitiallyBeEmpty() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEmpty();\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [],
          "test_type": "unit"
        },
        {
          "name": "shouldWriteAnObject",
          "signature": "public void shouldWriteAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setFoo(5);\n        writer.setBar(10L);\n        assertTrue(producer.commit());\n        assertSize(1);\n    }",
          "line_number": 47,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "setFoo",
            "currentElement",
            "commit"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldReadAnObject",
          "signature": "public void shouldReadAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        shouldWriteAnObject();\n\n        assertTrue(consumer.read());\n        assertEmpty();\n    }",
          "line_number": 58,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "shouldWriteAnObject",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadFromEmptyChannel",
          "signature": "public void shouldNotReadFromEmptyChannel() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertEmpty();\n        assertFalse(consumer.read());\n    }",
          "line_number": 68,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadUnCommittedMessages",
          "signature": "public void shouldNotReadUnCommittedMessages() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setBar(10L);\n\n        assertFalse(consumer.read());\n    }",
          "line_number": 76,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "read",
            "newConsumer",
            "currentElement"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotOverrunBuffer",
          "signature": "public void shouldNotOverrunBuffer() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        for (int i = 0; i < REQUESTED_CAPACITY; i++) {\n            assertTrue(producer.claim());\n            assertTrue(producer.commit());\n        }\n\n        for (int i = REQUESTED_CAPACITY; i < MAXIMUM_CAPACITY; i++) {\n            // Unknown what happens here.\n            producer.claim();\n            producer.commit();\n        }\n\n        assertFalse(producer.claim());\n        assertTrue(channel.size() >= REQUESTED_CAPACITY);\n        assertTrue(channel.size() <= MAXIMUM_CAPACITY);\n    }",
          "line_number": 88,
          "tested_class": "",
          "tested_methods": [
            "for",
            "claim",
            "commit"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "SpscChannel",
      "method_type": "method"
    },
    {
      "name": "newProducer",
      "signature": "private SpscChannelProducer<E> newProducer(final Class<E> type, final Object... args) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscChannel.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "mapper.newFlyweight",
        "newFlyweight",
        "Template.fromFile",
        "fromFile",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return mapper.newFlyweight(SpscChannelProducer.class, \"ChannelProducerTemplate.java\",\n                Template.fromFile(Channel.class, \"ChannelProducerTemplate.java\"), args);\n    }",
      "line_number": 105,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java"
      ],
      "test_functions": [
        {
          "name": "shouldKnowItsCapacity",
          "signature": "public void shouldKnowItsCapacity() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEquals(REQUESTED_CAPACITY, channel.requestedCapacity());\n        assertEquals(MAXIMUM_CAPACITY, channel.maximumCapacity());\n    }",
          "line_number": 36,
          "tested_class": "",
          "tested_methods": [
            "maximumCapacity",
            "requestedCapacity"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldInitiallyBeEmpty",
          "signature": "public void shouldInitiallyBeEmpty() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertEmpty();\n    }",
          "line_number": 42,
          "tested_class": "",
          "tested_methods": [],
          "test_type": "unit"
        },
        {
          "name": "shouldWriteAnObject",
          "signature": "public void shouldWriteAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setFoo(5);\n        writer.setBar(10L);\n        assertTrue(producer.commit());\n        assertSize(1);\n    }",
          "line_number": 47,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "setFoo",
            "currentElement",
            "commit"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldReadAnObject",
          "signature": "public void shouldReadAnObject() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        shouldWriteAnObject();\n\n        assertTrue(consumer.read());\n        assertEmpty();\n    }",
          "line_number": 58,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "shouldWriteAnObject",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadFromEmptyChannel",
          "signature": "public void shouldNotReadFromEmptyChannel() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertEmpty();\n        assertFalse(consumer.read());\n    }",
          "line_number": 68,
          "tested_class": "",
          "tested_methods": [
            "newConsumer",
            "read"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotReadUnCommittedMessages",
          "signature": "public void shouldNotReadUnCommittedMessages() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        ChannelConsumer consumer = newConsumer();\n\n        assertTrue(producer.claim());\n\n        Example writer = producer.currentElement();\n        writer.setBar(10L);\n\n        assertFalse(consumer.read());\n    }",
          "line_number": 76,
          "tested_class": "",
          "tested_methods": [
            "claim",
            "setBar",
            "read",
            "newConsumer",
            "currentElement"
          ],
          "test_type": "unit"
        },
        {
          "name": "shouldNotOverrunBuffer",
          "signature": "public void shouldNotOverrunBuffer() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscChannelTest.java",
          "source_code": "        for (int i = 0; i < REQUESTED_CAPACITY; i++) {\n            assertTrue(producer.claim());\n            assertTrue(producer.commit());\n        }\n\n        for (int i = REQUESTED_CAPACITY; i < MAXIMUM_CAPACITY; i++) {\n            // Unknown what happens here.\n            producer.claim();\n            producer.commit();\n        }\n\n        assertFalse(producer.claim());\n        assertTrue(channel.size() >= REQUESTED_CAPACITY);\n        assertTrue(channel.size() <= MAXIMUM_CAPACITY);\n    }",
          "line_number": 88,
          "tested_class": "",
          "tested_methods": [
            "for",
            "claim",
            "commit"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "producer_consumer",
      "class_name": "SpscChannel",
      "method_type": "method"
    },
    {
      "name": "claim",
      "signature": "public final boolean claim() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscChannelProducer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        pointer = writeAcquire();\n        return pointer != EOF;\n    }",
      "line_number": 38,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SpscChannelProducer",
      "method_type": "method"
    },
    {
      "name": "commit",
      "signature": "public final boolean commit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/spsc/SpscChannelProducer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 1,
      "source_code": "        if (pointer == EOF)\n            return false;\n\n        writeRelease(pointer);\n        return true;\n    }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SpscChannelProducer",
      "method_type": "method"
    },
    {
      "name": "printClassBytes",
      "signature": "private static void printClassBytes(byte[] byteCode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "PrintWriter",
        "TraceClassVisitor",
        "ClassReader",
        "accept"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 2,
      "source_code": "        if (DEBUG) {\n            TraceClassVisitor visitor = new TraceClassVisitor(new PrintWriter(System.out));\n            new ClassReader(byteCode).accept(visitor, 0);\n        }\n    }",
      "line_number": 34,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "writeAcquireWithWaitStrategy",
      "signature": "public static long writeAcquireWithWaitStrategy(ProxyChannelRingBuffer channelBackend, WaitStrategy waitStrategy) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "static"
      ],
      "dependencies": [
        "writeAcquire",
        "idle",
        "waitStrategy.idle",
        "channelBackend.writeAcquire"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long wOffset;\n        int idleCounter = 0;\n        while ((wOffset = channelBackend.writeAcquire()) == ProxyChannelRingBuffer.EOF) {\n            idleCounter = waitStrategy.idle(idleCounter);\n        }\n        return wOffset;\n    }",
      "line_number": 41,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "implementUserMethods",
      "signature": "private static void implementUserMethods(ClassWriter classWriter, List<Method> relevantMethods, String generatedName, Class<?extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "Method"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 2,
      "source_code": "        int type = START_TYPE_ID;\n        for (Method method : relevantMethods) {\n            implementUserMethod(method, classWriter, type++, generatedName, backendType);\n        }\n    }",
      "line_number": 185,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "findRelevantMethods",
      "signature": "private static List<Method> findRelevantMethods(Class<?> iFace) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "isAbstract",
        "add",
        "iFace.getMethods",
        "Modifier.isAbstract",
        "relevantMethods.add",
        "ArrayList",
        "getMethods",
        "Method",
        "getModifiers",
        "method.getModifiers"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        Method[] methods = iFace.getMethods();\n        List<Method> relevantMethods = new ArrayList<Method>(methods.length);\n        for (Method method : methods) {\n            if (Modifier.isAbstract(method.getModifiers())) {\n                relevantMethods.add(method);\n            }\n        }\n        return relevantMethods;\n    }",
      "line_number": 192,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "findExisting",
      "signature": "private static Class<?> findExisting(String generatedName, Class<?> iFace) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "forName",
        "generatedName.replace",
        "iFace.getClassLoader",
        "Class.forName",
        "getClassLoader",
        "replace"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        try {\n            String className = generatedName.replace(\"/\", \".\");\n            return Class.forName(className, true, iFace.getClassLoader());\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }",
      "line_number": 203,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "implementInstanceFields",
      "signature": "private static void implementInstanceFields(ClassVisitor classVisitor) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "static",
        "final"
      ],
      "dependencies": [
        "getDescriptor",
        "visitField",
        "Type.getDescriptor",
        "classVisitor.visitField"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        classVisitor.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL,\n                \"waitStrategy\",\n                Type.getDescriptor(WaitStrategy.class),\n                null,\n                null);\n    }",
      "line_number": 379,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "implementProxyInstance",
      "signature": "private static void implementProxyInstance(ClassVisitor classVisitor, Class<?> iFace, String generatedName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitVarInsn",
        "methodVisitor.visitInsn",
        "methodVisitor.visitMaxs",
        "visitCode",
        "visitMaxs",
        "visitInsn",
        "visitEnd",
        "methodVisitor.visitCode",
        "classVisitor.visitMethod",
        "methodVisitor.visitVarInsn",
        "visitMethod",
        "methodVisitor.visitEnd"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 5,
      "source_code": "        MethodVisitor methodVisitor = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,\n                \"proxyInstance\",\n                methodDescriptor(iFace, iFace),\n                null,\n                null);\n        methodVisitor.visitCode();\n\n        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitInsn(Opcodes.ARETURN);\n\n        methodVisitor.visitMaxs(-1, -1);\n        methodVisitor.visitEnd();\n        \n        implementBridgeMethod(classVisitor, generatedName, \"proxyInstance\", iFace, iFace);\n    }",
      "line_number": 429,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "implementProxy",
      "signature": "private static void implementProxy(ClassVisitor classVisitor, Class<?> iFace, String generatedName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitVarInsn",
        "methodVisitor.visitInsn",
        "methodVisitor.visitMaxs",
        "visitCode",
        "visitMaxs",
        "visitInsn",
        "visitEnd",
        "methodVisitor.visitCode",
        "classVisitor.visitMethod",
        "methodVisitor.visitVarInsn",
        "visitMethod",
        "methodVisitor.visitEnd"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 3,
      "source_code": "        MethodVisitor methodVisitor = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,\n                \"proxy\",\n                methodDescriptor(iFace),\n                null,\n                null);\n\n        methodVisitor.visitCode();\n\n        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitInsn(Opcodes.ARETURN);\n\n        methodVisitor.visitMaxs(-1, -1);\n        methodVisitor.visitEnd();\n        \n        implementBridgeMethod(classVisitor, generatedName, \"proxy\", iFace);\n    }",
      "line_number": 446,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "implementBridgeMethod",
      "signature": "private static void implementBridgeMethod(ClassVisitor classVisitor, String generatedName, String methodName, Class<?> returnType, Class<?>... parameterTypes) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "methodVisitor.visitMaxs",
        "visitMaxs",
        "visitEnd",
        "methodVisitor.visitCode",
        "Type.getType",
        "newLocal",
        "methodVisitor.visitEnd",
        "visitVarInsn",
        "getOpcode",
        "visitTypeInsn",
        "methodVisitor.visitMethodInsn",
        "getInternalName",
        "LocalsHelper.forInstanceMethod",
        "parameterType.isPrimitive",
        "visitMethodInsn",
        "locals.newLocal",
        "visitInsn",
        "methodVisitor.visitVarInsn",
        "methodVisitor.visitTypeInsn",
        "getType",
        "returnType.isPrimitive",
        "forInstanceMethod",
        "isPrimitive",
        "methodVisitor.visitInsn",
        "Type.getInternalName",
        "visitCode",
        "classVisitor.visitMethod",
        "visitMethod"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        Class<?> bridgeMethodReturnType = returnType.isPrimitive() ? returnType : Object.class;\n        Class<?>[] bridgeMethodParameterTypes = new Class<?>[parameterTypes.length];\n        int parameterIndex = 0;\n        // Bridge methods use only Object's, so replace all non-Object types.\n        for (Class<?> parameterType : parameterTypes) {\n            bridgeMethodParameterTypes[parameterIndex++] = parameterType.isPrimitive() ? parameterType : Object.class;\n        }\n        \n        MethodVisitor methodVisitor = classVisitor.visitMethod(Opcodes.ACC_BRIDGE | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC,\n                methodName,\n                methodDescriptor(bridgeMethodReturnType, bridgeMethodParameterTypes),\n                null,\n                null);\n\n        methodVisitor.visitCode();\n\n        LocalsHelper locals = LocalsHelper.forInstanceMethod();\n\n        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        for (Class<?> parameterType : parameterTypes) {\n            int localIndexOfParameter = locals.newLocal(parameterType);\n            int loadOpCode = Type.getType(parameterType).getOpcode(Opcodes.ILOAD);\n            methodVisitor.visitVarInsn(loadOpCode, localIndexOfParameter);\n            \n            if (!parameterType.isPrimitive()) {\n                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(parameterType));\n            }\n        }\n        \n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n                generatedName,\n                methodName,\n                methodDescriptor(returnType, parameterTypes),\n                false);\n        \n        if (!returnType.isPrimitive()) {\n            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(returnType));\n        }\n        int returnOpcode = Type.getType(returnType).getOpcode(Opcodes.IRETURN);\n        methodVisitor.visitInsn(returnOpcode);\n        \n        methodVisitor.visitMaxs(-1, -1);\n        methodVisitor.visitEnd();\n    ",
      "line_number": 464,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "producerReferenceArrayIndex",
      "signature": "private static void producerReferenceArrayIndex(MethodVisitor methodVisitor, int localIndexOfWOffset, Class<? extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitMethodInsn",
        "visitVarInsn",
        "Type.getInternalName",
        "methodVisitor.visitVarInsn",
        "methodVisitor.visitMethodInsn",
        "getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitVarInsn(Opcodes.LLOAD, localIndexOfWOffset);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(backendType), \"producerReferenceArrayIndex\", \"(J)J\", false);\n    }",
      "line_number": 603,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "consumerReferenceArrayIndex",
      "signature": "private static void consumerReferenceArrayIndex(MethodVisitor methodVisitor, int localIndexOfROffset, Class<? extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitMethodInsn",
        "visitVarInsn",
        "Type.getInternalName",
        "methodVisitor.visitVarInsn",
        "methodVisitor.visitMethodInsn",
        "getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitVarInsn(Opcodes.LLOAD, localIndexOfROffset);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(backendType), \"consumerReferenceArrayIndex\", \"(J)J\", false);\n    }",
      "line_number": 609,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "writeAcquireWithWaitStrategy",
      "signature": "private static void writeAcquireWithWaitStrategy(MethodVisitor methodVisitor, String generatedName, Class<? extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "static"
      ],
      "dependencies": [
        "visitFieldInsn",
        "visitMethodInsn",
        "visitVarInsn",
        "Type.getDescriptor",
        "Type.getInternalName",
        "getDescriptor",
        "methodVisitor.visitVarInsn",
        "methodVisitor.visitFieldInsn",
        "methodVisitor.visitMethodInsn",
        "getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        // One of these is for the getfield bytecode, the other is as the first arg to the writeAcquireWithWaitStrategy\n        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, generatedName, \"waitStrategy\", Type.getDescriptor(WaitStrategy.class));\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,\n                Type.getInternalName(ProxyChannelFactory.class),\n                \"writeAcquireWithWaitStrategy\",\n                methodDescriptor(long.class, ProxyChannelRingBuffer.class, WaitStrategy.class),\n                false);\n    }",
      "line_number": 615,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "writeRelease",
      "signature": "private static void writeRelease(MethodVisitor methodVisitor, int wOffset, int type, Class<? extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitMethodInsn",
        "visitVarInsn",
        "methodVisitor.visitVarInsn",
        "Type.getInternalName",
        "methodVisitor.visitLdcInsn",
        "visitLdcInsn",
        "methodVisitor.visitMethodInsn",
        "getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitVarInsn(Opcodes.LLOAD, wOffset);\n        methodVisitor.visitLdcInsn(type);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(backendType), \"writeRelease\", \"(JI)V\", false);\n    }",
      "line_number": 627,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "readAcquire",
      "signature": "private static void readAcquire(MethodVisitor methodVisitor, Class<? extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitMethodInsn",
        "visitVarInsn",
        "Type.getInternalName",
        "methodVisitor.visitVarInsn",
        "methodVisitor.visitMethodInsn",
        "getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(backendType), \"readAcquire\", \"()J\", false);\n    }",
      "line_number": 634,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "readRelease",
      "signature": "private static void readRelease(MethodVisitor methodVisitor, int wOffset, Class<? extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitMethodInsn",
        "visitVarInsn",
        "Type.getInternalName",
        "methodVisitor.visitVarInsn",
        "methodVisitor.visitMethodInsn",
        "getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitVarInsn(Opcodes.ALOAD, LOCALS_INDEX_THIS);\n        methodVisitor.visitVarInsn(Opcodes.LLOAD, wOffset);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(backendType), \"readRelease\", \"(J)V\", false);\n    }",
      "line_number": 639,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "getUnsafe",
      "signature": "private static int getUnsafe(MethodVisitor methodVisitor, Class<?> parameterType, int localIndexOfROffset, int rOffsetDelta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        loadUnsafe(methodVisitor);\n        loadWOffset(methodVisitor, parameterType, localIndexOfROffset, rOffsetDelta);\n        return parameterTypeUnsafe(methodVisitor, parameterType, false);\n    }",
      "line_number": 645,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "putUnsafe",
      "signature": "private static int putUnsafe(MethodVisitor methodVisitor, Class<?> parameterType, int wOffset, int wOffsetDelta, int varOffset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitVarInsn",
        "Type.getType",
        "getOpcode",
        "methodVisitor.visitVarInsn",
        "getType"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        loadUnsafe(methodVisitor);\n        loadWOffset(methodVisitor, parameterType, wOffset, wOffsetDelta);\n        methodVisitor.visitVarInsn(Type.getType(parameterType).getOpcode(Opcodes.ILOAD), varOffset);\n        return parameterTypeUnsafe(methodVisitor, parameterType, true);\n    }",
      "line_number": 651,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "loadUnsafe",
      "signature": "private static void loadUnsafe(MethodVisitor methodVisitor) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitFieldInsn",
        "getInternalName",
        "methodVisitor.visitFieldInsn",
        "Type.getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, Type.getInternalName(UnsafeAccess.class), \"UNSAFE\", \"L\" + Type.getInternalName(Unsafe.class) + \";\");\n    }",
      "line_number": 684,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "loadWOffset",
      "signature": "private static void loadWOffset(MethodVisitor methodVisitor, Class<?> parameterType, int baseOffset, long wOffsetDelta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitInsn",
        "methodVisitor.visitInsn"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (parameterType == boolean.class) {\n            methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n        }\n        loadLocalIndexAndApplyDelta(methodVisitor, baseOffset, wOffsetDelta);\n    }",
      "line_number": 688,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "loadLocalIndexAndApplyDelta",
      "signature": "private static void loadLocalIndexAndApplyDelta(MethodVisitor methodVisitor, int localVariableIndex, long delta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "visitVarInsn",
        "methodVisitor.visitVarInsn",
        "methodVisitor.visitInsn",
        "visitInsn",
        "methodVisitor.visitLdcInsn",
        "visitLdcInsn"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 2,
      "source_code": "        methodVisitor.visitVarInsn(Opcodes.LLOAD, localVariableIndex);\n        if (delta != 0) {\n            methodVisitor.visitLdcInsn(delta);\n            methodVisitor.visitInsn(Opcodes.LADD);\n        }\n    }",
      "line_number": 695,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "parameterTypeUnsafe",
      "signature": "private static int parameterTypeUnsafe(MethodVisitor methodVisitor, Class<?> parameterType, boolean write) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "toUpperCase",
        "getSize",
        "type.getDescriptor",
        "type.getSize",
        "visitMethodInsn",
        "isPrimitive",
        "Character.toUpperCase",
        "Type.getInternalName",
        "getDescriptor",
        "type.getClassName",
        "Type.getType",
        "substring",
        "methodVisitor.visitMethodInsn",
        "getType",
        "getInternalName",
        "getClassName",
        "charAt",
        "parameterType.isPrimitive"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        parameterType = parameterType.isPrimitive() ? parameterType : Object.class;\n        Type type = Type.getType(parameterType);\n        String boolDescriptor = parameterType == boolean.class ? \"Ljava/lang/Object;\" : \"\";\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n                Type.getInternalName(Unsafe.class),\n                (write ? \"put\" : \"get\") + Character.toUpperCase(type.getClassName().charAt(0)) + type.getClassName().substring(1),\n                write ? (\"(\" + boolDescriptor + \"J\" + type.getDescriptor() + \")V\") : (\"(\" + boolDescriptor + \"J)\" + type.getDescriptor()),\n                false);\n        return type.getSize();\n    }",
      "line_number": 703,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "writeReference",
      "signature": "private static void writeReference(MethodVisitor methodVisitor, Class<? extends ProxyChannelRingBuffer> backendType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "methodVisitor.visitMethodInsn",
        "getInternalName",
        "visitMethodInsn",
        "Type.getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n                Type.getInternalName(backendType),\n                \"writeReference\",\n                (\"(JLjava/lang/Object;)V\"),\n                false);\n    }",
      "line_number": 715,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "readReference",
      "signature": "private static void readReference(MethodVisitor methodVisitor, Class<? extends ProxyChannelRingBuffer> backend) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "methodVisitor.visitMethodInsn",
        "getInternalName",
        "visitMethodInsn",
        "Type.getInternalName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n                Type.getInternalName(backend),\n                \"readReference\",\n                (\"(J)Ljava/lang/Object;\"),\n                false);\n    }",
      "line_number": 723,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "primitiveMemorySize",
      "signature": "private static int primitiveMemorySize(Class<?> type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "isPrimitive",
        "type.isPrimitive"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 2,
      "source_code": "        if (!type.isPrimitive()) {\n            throw new IllegalArgumentException(\"Cannot handle non-primtive parameter type: \" + type);\n        }\n        return type == long.class || type == double.class ? 8 : 4;\n    }",
      "line_number": 731,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "methodDescriptor",
      "signature": "private static String methodDescriptor(Class<?> returnType, Class<?>... parameterTypes) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "Type.getMethodDescriptor",
        "getType",
        "Type.getType",
        "getMethodDescriptor"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        Type[] argumentTypes = new Type[parameterTypes.length];\n        int typeIndex = 0;\n        for (Class<?> parameterType : parameterTypes) {\n            argumentTypes[typeIndex++] = Type.getType(parameterType);\n        }\n        return Type.getMethodDescriptor(Type.getType(returnType), argumentTypes);\n    }",
      "line_number": 738,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProxyChannelFactory",
      "method_type": "method"
    },
    {
      "name": "initialize",
      "signature": "private static DefineClassStrategy initialize() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/DefineClassHelper.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 8,
      "source_code": "        try {\n            try {\n                return usingUnsafe();\n            } catch (Exception ignored) {\n                return usingMethodHandles();\n            }\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Cannot initialize suitable defineClass implementation\", e);\n        }\n    }",
      "line_number": 85,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "DefineClassHelper",
      "method_type": "method"
    },
    {
      "name": "usingUnsafe",
      "signature": "private static DefineClassStrategy usingUnsafe() throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/DefineClassHelper.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "class.getMethod",
        "getMethod",
        "UsingUnsafe"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        Method defineClassMethod = Unsafe.class.getMethod(\"defineClass\",\n                String.class,\n                byte[].class,\n                int.class,\n                int.class,\n                ClassLoader.class,\n                ProtectionDomain.class);\n        return new UsingUnsafe(defineClassMethod);\n    }",
      "line_number": 97,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "DefineClassHelper",
      "method_type": "method"
    },
    {
      "name": "usingMethodHandles",
      "signature": "private static DefineClassStrategy usingMethodHandles() throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/DefineClassHelper.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "forName",
        "lookupClass.getMethod",
        "methodHandlesClass.getMethod",
        "getMethod",
        "Class.forName",
        "UsingMethodHandles"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        Class<?> lookupClass = Class.forName(\"java.lang.invoke.MethodHandles$Lookup\", false, null);\n        Class<?> methodHandlesClass = Class.forName(\"java.lang.invoke.MethodHandles\", false, null);\n\n        Method lookupMethod = methodHandlesClass.getMethod(\"lookup\");\n        Method privateLookupInMethod = methodHandlesClass.getMethod(\"privateLookupIn\", Class.class, lookupClass);\n        Method defineClassMethod = lookupClass.getMethod(\"defineClass\", byte[].class);\n\n        return new UsingMethodHandles(lookupMethod, privateLookupInMethod, defineClassMethod);\n    }",
      "line_number": 113,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "DefineClassHelper",
      "method_type": "method"
    },
    {
      "name": "defineClass",
      "signature": "static Class<?> defineClass(Class<?> iFace, String name, byte[] bytes) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/DefineClassHelper.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "DEFINE_CLASS_STRATEGY.defineClass",
        "defineClass"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 2,
      "source_code": "        return DEFINE_CLASS_STRATEGY.defineClass(iFace, name, bytes);\n    }",
      "line_number": 124,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "DefineClassHelper",
      "method_type": "method"
    },
    {
      "name": "newLocal",
      "signature": "public int newLocal(Class<?> cls) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/LocalsHelper.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getType",
        "Type.getType"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        Type type = Type.getType(cls);\n        return newLocal(type);\n    }",
      "line_number": 13,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "LocalsHelper",
      "method_type": "method"
    },
    {
      "name": "newLocal",
      "signature": "private int newLocal(Type type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/LocalsHelper.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getSize",
        "type.getSize"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final int myIndex = nextLocalIndex;\n        nextLocalIndex += type.getSize();\n        return myIndex;\n    }",
      "line_number": 19,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "LocalsHelper",
      "method_type": "method"
    },
    {
      "name": "forStaticMethod",
      "signature": "public static LocalsHelper forStaticMethod() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/LocalsHelper.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "LocalsHelper"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        return new LocalsHelper();\n    }",
      "line_number": 25,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "LocalsHelper",
      "method_type": "method"
    },
    {
      "name": "forInstanceMethod",
      "signature": "public static LocalsHelper forInstanceMethod() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/LocalsHelper.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "LocalsHelper",
        "helper.newLocal",
        "newLocal"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        LocalsHelper helper = new LocalsHelper();\n        helper.newLocal(Object.class);\n        return helper;\n    }",
      "line_number": 29,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "LocalsHelper",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/proxy/LocalsHelper.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "out.println",
        "println",
        "helper.newLocal",
        "forInstanceMethod",
        "newLocal",
        "LocalsHelper.forInstanceMethod"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        LocalsHelper helper =\n                LocalsHelper.forInstanceMethod();\n        out.println(helper.newLocal(int.class));\n        out.println(helper.newLocal(int.class));\n        out.println(helper.newLocal(long.class));\n        out.println(helper.newLocal(double.class));\n        out.println(helper.newLocal(boolean.class));\n        out.println(helper.newLocal(Object.class));\n        out.println(helper.newLocal(Object.class));\n        out.println(helper.newLocal(Object.class));\n        out.println();\n    }",
      "line_number": 35,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "LocalsHelper",
      "method_type": "method"
    },
    {
      "name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "signature": "public MpscFFLamportOffHeapFixedSizeRingBuffer(final int capacity, final int primitiveMessageSize, final int referenceMessageSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "      this(allocateAlignedByteBuffer(getRequiredBufferSize(capacity, primitiveMessageSize), PortableJvmInfo.CACHE_LINE_SIZE), Pow2.roundToPowerOfTwo(capacity), true, true, true, primitiveMessageSize, createReferenceArray(capacity, referenceMessageSize), referenceMessageSize);\n   }",
      "line_number": 37,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "constructor"
    },
    {
      "name": "slowPathWriteAcquire",
      "signature": "private long slowPathWriteAcquire(final long wrapPoint) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "      final long currHead = lvConsumerIndex(); // LoadLoad\n      if (currHead <= wrapPoint) {\n         return EOF; // FULL :(\n      }\n      else {\n         // update cached value of the consumerIndex\n         spConsumerIndexCache(currHead);\n         return currHead;\n      }\n   }",
      "line_number": 67,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeAcquire",
      "signature": "protected final long writeAcquire() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "      final long mask = this.mask;\n      final long capacity = mask + 1;\n      long consumerIndexCache = lpConsumerIndexCache();\n      long currentProducerIndex;\n      do {\n         currentProducerIndex = lvProducerIndex(); // LoadLoad\n         final long wrapPoint = currentProducerIndex - capacity;\n         if (consumerIndexCache <= wrapPoint) {\n            // update on stack copy, we might need this value again if we lose the CAS.\n            consumerIndexCache = slowPathWriteAcquire(wrapPoint);\n            if (consumerIndexCache == EOF) {\n               return EOF;\n            }\n         }\n      } while (!casProducerIndex(currentProducerIndex, currentProducerIndex + 1));\n        /*\n         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on\n         * the index visibility to read it, we would need to handle the case where the element is not visible.\n         */\n      // Won CAS, move on to storing\n      final long offsetForIndex = offsetForIndex(currentProducerIndex);\n      // return offset for current producer index\n      return offsetForIndex;\n   }",
      "line_number": 80,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeRelease",
      "signature": "protected final void writeRelease(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      //Store-Store: ensure publishing for the consumer - only one single writer per offset\n      writeReleaseState(offset);\n   }",
      "line_number": 107,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeRelease",
      "signature": "protected final void writeRelease(long offset, int callTypeId) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "       UNSAFE.putOrderedInt(null, offset, callTypeId);\n   }",
      "line_number": 113,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readAcquire",
      "signature": "protected final long readAcquire() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "      final long consumerIndex = lpConsumerIndex();\n      final long offset = offsetForIndex(consumerIndex);\n      // If we can't see the next available element we can't poll\n      if (isReadReleased(offset)) { // LoadLoad\n            /*\n             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after\n             * winning the CAS on offer but before storing the element in the queue. Other producers may go on\n             * to fill up the queue after this element.\n             */\n         if (consumerIndex != lvProducerIndex()) {\n            while (isReadReleased(offset)) {\n               //NOP\n            }\n         }\n         else {\n            return EOF;\n         }\n      }\n      return offset;\n   }",
      "line_number": 118,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readRelease",
      "signature": "protected final void readRelease(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "      //it will not used by producer hence it can be a plain store\n      spReadReleaseState(offset);\n      //retrieve the old stored consumer index\n      //TO_TEST: on-heap variable vs off-heap\n      final long consumerIndex = lpConsumerIndex();\n      //ensure visibility of the new index AFTER writing on the slot!!!\n      soConsumerIndex(consumerIndex + 1); // StoreStore\n   }",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "private boolean casProducerIndex(final long expected, long update) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "      return UNSAFE.compareAndSwapLong(null, producerIndexAddress, expected, update);\n   }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndexCache",
      "signature": "private long lpConsumerIndexCache() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "      return UNSAFE.getLong(null, consumerIndexCacheAddress);\n   }",
      "line_number": 155,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "spConsumerIndexCache",
      "signature": "private void spConsumerIndexCache(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putLong",
        "UNSAFE.putLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "      UNSAFE.putLong(null, consumerIndexCacheAddress, value);\n   }",
      "line_number": 159,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "spReadReleaseState",
      "signature": "private static void spReadReleaseState(final long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscFFLamportOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "UNSAFE.putInt",
        "putInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "      UNSAFE.putInt(null, offset, READ_RELEASE_INDICATOR);\n   }",
      "line_number": 163,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscFFLamportOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "MpscOffHeapFixedSizeRingBuffer",
      "signature": "public MpscOffHeapFixedSizeRingBuffer(final int capacity, final int messageSize, int referenceMessageSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this(allocateAlignedByteBuffer(getRequiredBufferSize(capacity, messageSize), PortableJvmInfo.CACHE_LINE_SIZE),\n                Pow2.roundToPowerOfTwo(capacity),\n                true,\n                true,\n                true,\n                messageSize,\n                createReferenceArray(capacity, referenceMessageSize),\n                referenceMessageSize);\n    }",
      "line_number": 33,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "memory_management",
      "class_name": "MpscOffHeapFixedSizeRingBuffer",
      "method_type": "constructor"
    },
    {
      "name": "writeAcquire",
      "signature": "protected final long writeAcquire() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "this.isReadReleased",
        "isReadReleased"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        long producerIndex;\n        long offset;\n\n        do {\n            producerIndex = lvProducerIndex(); // LoadLoad\n            offset = offsetForIndex(producerIndex);\n\n            // This is a bug! we need to replace with a solution a-la Vyukuv MPMC or similar slot 'phase' indicator\n            if (!this.isReadReleased(offset)) {\n                // It is possible that due to another producer passing us we are seeing that producer completed message,\n                // if that is the case then we must retry.\n                if (producerIndex != lvProducerIndex()) {\n                    continue;// go around again\n                }\n                return EOF;\n            }\n        } while (!casProducerIndex(producerIndex, producerIndex + 1));\n        // return offset for current producer index\n        return offset;\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "MpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeRelease",
      "signature": "protected final void writeRelease(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        writeReleaseState(offset);\n    }",
      "line_number": 85,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "MpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "writeRelease",
      "signature": "protected final void writeRelease(long offset, int callTypeId) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        assert callTypeId != 0;\n        UNSAFE.putOrderedInt(null, offset, callTypeId);\n    }",
      "line_number": 90,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "MpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readAcquire",
      "signature": "protected final long readAcquire() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long currentHead = lpConsumerIndex();\n        final long offset = offsetForIndex(currentHead);\n        if (isReadReleased(offset)) {\n            return EOF;\n        }\n        soConsumerIndex(currentHead + 1); // StoreStore\n        return offset;\n    }",
      "line_number": 96,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "MpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "readRelease",
      "signature": "protected final void readRelease(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        readReleaseState(offset);\n    }",
      "line_number": 107,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "MpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "private boolean casProducerIndex(final long expected, long update) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBuffer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(null, producerIndexAddress, expected, update);\n    }",
      "line_number": 111,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "atomic_operations",
      "class_name": "MpscOffHeapFixedSizeRingBuffer",
      "method_type": "method"
    },
    {
      "name": "claim",
      "signature": "public final boolean claim() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscChannelProducer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        pointer = writeAcquire();\n        return pointer != EOF;\n    }",
      "line_number": 38,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "MpscChannelProducer",
      "method_type": "method"
    },
    {
      "name": "commit",
      "signature": "public final boolean commit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscChannelProducer.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 1,
      "source_code": "        if (pointer == EOF)\n            return false;\n\n        writeRelease(pointer);\n        return true;\n    }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "MpscChannelProducer",
      "method_type": "method"
    },
    {
      "name": "MpscChannel",
      "signature": "public MpscChannel(final ByteBuffer buffer, final int requestedCapacity, final Class<E> type) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscChannel.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Mapper",
        "mapper.getSizeInBytes",
        "getSizeInBytes",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this.requestedCapacity = requestedCapacity;\n        this.maximumCapacity = getMaximumCapacity(requestedCapacity);\n        this.buffer = buffer;\n        mapper = new Mapper<E>(type, debugEnabled);\n        elementSize = mapper.getSizeInBytes();\n\n        checkSufficientCapacity();\n        checkByteBuffer();\n\n        producer = newProducer(type, buffer, maximumCapacity, elementSize);\n    }",
      "line_number": 47,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscChannel",
      "method_type": "constructor"
    },
    {
      "name": "getMaximumCapacity",
      "signature": "private int getMaximumCapacity(int requestedCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscChannel.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return Pow2.roundToPowerOfTwo(requestedCapacity);\n    }",
      "line_number": 60,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "MpscChannel",
      "method_type": "method"
    },
    {
      "name": "checkSufficientCapacity",
      "signature": "private void checkSufficientCapacity() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscChannel.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "buffer.capacity",
        "capacity"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final int requiredCapacityInBytes = getRequiredBufferSize(maximumCapacity, elementSize);\n        if (buffer.capacity() < requiredCapacityInBytes) {\n            throw new IllegalArgumentException(\"Failed to meet required maximumCapacity in bytes: \"\n                    + requiredCapacityInBytes);\n        }\n    }",
      "line_number": 70,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscChannel",
      "method_type": "method"
    },
    {
      "name": "newProducer",
      "signature": "private MpscChannelProducer<E> newProducer(final Class<E> type, final Object... args) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/main/java/org/jctools/channels/mpsc/MpscChannel.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "mapper.newFlyweight",
        "newFlyweight",
        "Template.fromFile",
        "fromFile",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return mapper.newFlyweight(MpscChannelProducer.class, \"ChannelProducerTemplate.java\",\n                Template.fromFile(Channel.class, \"ChannelProducerTemplate.java\"), args);\n    }",
      "line_number": 104,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscChannel",
      "method_type": "method"
    },
    {
      "name": "queueClass",
      "signature": "private static Class queueClass(String queueType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/queues/MessagePassingQueueByTypeFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "forName",
        "Class.forName",
        "IllegalArgumentException"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern"
      ],
      "complexity_score": 19,
      "source_code": "        try {\n            return Class.forName(\"org.jctools.queues.\"+queueType);\n        } catch (ClassNotFoundException e) {\n        }\n\n        try {\n            return Class.forName(\"org.jctools.queues.atomic.\"+queueType);\n        } catch (ClassNotFoundException e) {\n        }\n        \n        try {\n            return Class.forName(queueType);\n        } catch (ClassNotFoundException e) {\n        }\n        throw new IllegalArgumentException(\"class not found:\");\n    }",
      "line_number": 46,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MessagePassingQueueByTypeFactory",
      "method_type": "method"
    },
    {
      "name": "queueClass",
      "signature": "private static Class queueClass(String queueType) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/queues/QueueByTypeFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "forName",
        "Class.forName",
        "IllegalArgumentException"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern"
      ],
      "complexity_score": 31,
      "source_code": "        try {\n            return Class.forName(\"org.jctools.queues.\"+queueType);\n        } catch (ClassNotFoundException e) {\n        }\n        try {\n            return Class.forName(\"org.jctools.queues.atomic.\"+queueType);\n        } catch (ClassNotFoundException e) {\n        }\n        try {\n            return Class.forName(\"java.util.\"+queueType);\n        } catch (ClassNotFoundException e) {\n        }\n        try {\n            return Class.forName(\"java.util.concurrent.\"+queueType);\n        } catch (ClassNotFoundException e) {\n        }\n        try {\n            return Class.forName(queueType);\n        } catch (ClassNotFoundException e) {\n        }\n        throw new IllegalArgumentException(\"class not found:\");\n    }",
      "line_number": 117,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "QueueByTypeFactory",
      "method_type": "method"
    },
    {
      "name": "createQueue",
      "signature": "public static ConcurrentQueue<Integer> createQueue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/queues/alt/ConcurrentQueueByTypeFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "SpscLinkedQueue",
        "MpmcArrayQueue",
        "Integer",
        "MpscArrayConcurrentQueue",
        "MpscOnSpscQueue",
        "MpscCompoundQueue",
        "MpmcArrayConcurrentQueue",
        "IllegalArgumentException",
        "SpscArrayQueue",
        "SpscArrayConcurrentQueue",
        "SpmcArrayQueue"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 11,
      "source_code": "        switch (QUEUE_TYPE) {\n        case -1:\n            return new ConcurrentQueueFactory.GenericQueue<Integer>();\n//        case 3:\n//            return new SpscArrayQueue<Integer>(QUEUE_CAPACITY);\n        case 30:\n            return new SpscArrayConcurrentQueue<Integer>(QUEUE_CAPACITY);\n//        case 31:\n//            return new SpscLinkedQueue<Integer>();\n//        case 5:\n//            return new SpmcArrayQueue<Integer>(QUEUE_CAPACITY);\n//        case 6:\n//            return new MpscArrayConcurrentQueue<Integer>(QUEUE_CAPACITY);\n//        case 61:\n//            return new MpscCompoundQueue<Integer>(QUEUE_CAPACITY);\n//        case 62:\n//            return new MpscOnSpscQueue<Integer>(QUEUE_CAPACITY);\n//        case 7:\n//            return new MpmcArrayQueue<Integer>(QUEUE_CAPACITY);\n        case 70:\n            return new MpmcArrayConcurrentQueue<Integer>(QUEUE_CAPACITY);\n\n        }\n        throw new IllegalArgumentException(\"Type: \" + QUEUE_TYPE);\n    }",
      "line_number": 7,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentQueueByTypeFactory",
      "method_type": "method"
    },
    {
      "name": "ping",
      "signature": "public void ping(Control cnt) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/baseline/BaselinePingPong.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "flag.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        while (!cnt.stopMeasurement && !flag.compareAndSet(false, true)) {\n            // this body is intentionally left blank\n        }\n    }",
      "line_number": 31,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BaselinePingPong",
      "method_type": "method"
    },
    {
      "name": "pong",
      "signature": "public void pong(Control cnt) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/baseline/BaselinePingPong.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "flag.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        while (!cnt.stopMeasurement && !flag.compareAndSet(true, false)) {\n            // this body is intentionally left blank\n        }\n    }",
      "line_number": 39,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BaselinePingPong",
      "method_type": "method"
    },
    {
      "name": "offerAndPollLoops",
      "signature": "public int offerAndPollLoops() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/baseline/QueueOfferPoll.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "poll",
        "offer",
        "q.offer",
        "q.poll"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "        final int burstSize = this.burstSize;\n        for (int i = 0; i < burstSize; i++) {\n            q.offer(DUMMY_MESSAGE);\n        }\n        Integer result = DUMMY_MESSAGE;\n        for (int i = 0; i < burstSize; i++) {\n            result = q.poll();\n        }\n        return result;\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "QueueOfferPoll",
      "method_type": "method"
    },
    {
      "name": "init",
      "signature": "public void init() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/QueueAsPoolBurstCost.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "q.poll",
        "Integer.parseInt",
        "QueueByTypeFactory.buildQ",
        "IllegalStateException",
        "QueueByTypeFactory.createQueue",
        "q.offer",
        "createQueue",
        "Object",
        "parseInt",
        "poll",
        "offer",
        "buildQ",
        "qType.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 14,
      "source_code": "      final boolean noQ = qType.equals(\"None\");\n      if (!noQ && warmup) {\n         q = QueueByTypeFactory.createQueue(qType, 128);\n\n         final Object o = new Object();\n\n         // stretch the queue to the limit, working through resizing and full\n         // 128 * 2 account for the xadd qs that pool by default 2 chunks\n         for (int i = 0; i < ((128 * 2) + 100); i++) {\n            q.offer(o);\n         }\n         for (int i = 0; i < ((128 * 2) + 100); i++) {\n            q.poll();\n         }\n         // make sure the important common case is exercised\n         for (int i = 0; i < 20000; i++) {\n            q.offer(o);\n            q.poll();\n         }\n      }\n      q = noQ ? null : QueueByTypeFactory.buildQ(qType, qCapacity);\n      // fill the qs, if any\n      final Object o = new Object();\n      if (q != null) {\n         for (int i = 0; i < Integer.parseInt(qCapacity); i++) {\n            if (!q.offer(o)) {\n               throw new IllegalStateException(\"qCapacity isn't enough to hold all elements for \" + qType);\n            }\n         }\n      }\n   }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "QueueAsPoolBurstCost",
      "method_type": "method"
    },
    {
      "name": "acquireAndRelease",
      "signature": "public void acquireAndRelease(ThreadLocalPool tlPool) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/QueueAsPoolBurstCost.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "Thread",
        "ThreadLocal"
      ],
      "dependencies": [
        "consumeCPU",
        "tmp.offer",
        "pool.poll",
        "pollLast",
        "Object",
        "Blackhole.consumeCPU",
        "poll",
        "offer",
        "tmp.pollLast",
        "pool.offer"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "      final int work = this.work;\n      final int burst = burstSize;\n      final Queue<Object> pool = q == null ? tlPool.pool : q;\n      final ArrayDeque<Object> tmp = tlPool.acquired;\n      for (int i = 0; i < burst; i++) {\n         tmp.offer(pool.poll());\n      }\n      if (work > 0) {\n         Blackhole.consumeCPU(work);\n      }\n      for (int i = 0; i < burst; i++) {\n         pool.offer(tmp.pollLast());\n      }\n   }",
      "line_number": 91,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "QueueAsPoolBurstCost",
      "method_type": "method"
    },
    {
      "name": "init",
      "signature": "public void init(QueueAsPoolBurstCost benchmark) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/QueueAsPoolBurstCost.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "add",
        "ArrayDeque",
        "Object",
        "pool.add",
        "equals"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "         acquired = new ArrayDeque<Object>(benchmark.burstSize);\n         pool = new ArrayDeque<Object>(benchmark.burstSize);\n         if (\"None\".equals(benchmark.qType)) {\n            final Object o = new Object();\n            for (int i = 0; i < benchmark.burstSize; i++) {\n               pool.add(o);\n            }\n         }\n      }",
      "line_number": 114,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "QueueAsPoolBurstCost",
      "method_type": "method"
    },
    {
      "name": "backoff",
      "signature": "protected void backoff() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/QueueThroughputBackoffYield.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "yield",
        "Thread.yield"
      ],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "        Thread.yield();\n    }",
      "line_number": 19,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "QueueThroughputBackoffYield",
      "method_type": "method"
    },
    {
      "name": "pollNoR",
      "signature": "public void pollNoR(PollCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "poll",
        "consumeCPU",
        "Blackhole.consumeCPU",
        "q.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 5,
      "source_code": "        Integer e = q.poll();\n        if (e == null) {\n            counters.pollsFailed++;\n            backoff();\n        } else if (e == TEST_ELEMENT) {\n            counters.pollsMade++;\n        } else {\n            escape = e;\n        }\n        if (DELAY_CONSUMER != 0) {\n            Blackhole.consumeCPU(DELAY_CONSUMER);\n        }\n    }",
      "line_number": 113,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "pollBothR",
      "signature": "public void pollBothR(PollCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "consumeCPU",
        "Blackhole.consumeCPU",
        "relaxedPoll",
        "q.relaxedPoll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 5,
      "source_code": "        Integer e = q.relaxedPoll();\n        if (e == null) {\n            counters.pollsFailed++;\n            backoff();\n        } else if (e == TEST_ELEMENT) {\n            counters.pollsMade++;\n        } else {\n            escape = e;\n        }\n        if (DELAY_CONSUMER != 0) {\n            Blackhole.consumeCPU(DELAY_CONSUMER);\n        }\n    }",
      "line_number": 144,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "pollPR",
      "signature": "public void pollPR(PollCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "poll",
        "consumeCPU",
        "Blackhole.consumeCPU",
        "q.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 5,
      "source_code": "        Integer e = q.poll();\n        if (e == null) {\n            counters.pollsFailed++;\n            backoff();\n        } else if (e == TEST_ELEMENT) {\n            counters.pollsMade++;\n        } else {\n            escape = e;\n        }\n        if (DELAY_CONSUMER != 0) {\n            Blackhole.consumeCPU(DELAY_CONSUMER);\n        }\n    }",
      "line_number": 175,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "pollCR",
      "signature": "public void pollCR(PollCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "consumeCPU",
        "Blackhole.consumeCPU",
        "relaxedPoll",
        "q.relaxedPoll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 5,
      "source_code": "        Integer e = q.relaxedPoll();\n        if (e == null) {\n            counters.pollsFailed++;\n            backoff();\n        } else if (e == TEST_ELEMENT) {\n            counters.pollsMade++;\n        } else {\n            escape = e;\n        }\n        if (DELAY_CONSUMER != 0) {\n            Blackhole.consumeCPU(DELAY_CONSUMER);\n        }\n    }",
      "line_number": 206,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "emptyQ",
      "signature": "public void emptyQ() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "synchronized"
      ],
      "dependencies": [
        "poll",
        "q.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 8,
      "source_code": "        synchronized (q)\n        {\n            while (q.poll() != null)\n                ;\n        }\n    }",
      "line_number": 222,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "MpqThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "createQandPrimeCompilation",
      "signature": "public void createQandPrimeCompilation() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/QueueThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "q.poll",
        "QueueByTypeFactory.buildQ",
        "QueueByTypeFactory.createQueue",
        "q.offer",
        "createQueue",
        "poll",
        "offer",
        "buildQ"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        final String qType = this.qType;\n\n        q = QueueByTypeFactory.createQueue(qType, 128);\n        // stretch the queue to the limit, working through resizing and full\n        for (int i = 0; i < 128+100; i++) {\n            q.offer(element);\n        }\n        for (int i = 0; i < 128+100; i++) {\n            q.poll();\n\n        }\n        // make sure the important common case is exercised\n        for (int i = 0; i < 20000; i++) {\n            q.offer(element);\n            q.poll();\n        }\n        final String qCapacity = this.qCapacity;\n\n        this.q = QueueByTypeFactory.buildQ(qType, qCapacity);\n    }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "QueueThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public void poll(PollCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/QueueThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "poll",
        "consumeCPU",
        "Blackhole.consumeCPU",
        "q.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 5,
      "source_code": "        Integer e = q.poll();\n        if (e == null) {\n            counters.pollsFailed++;\n            backoff();\n        } else if (e == TEST_ELEMENT) {\n            counters.pollsMade++;\n        } else {\n            escape = e;\n        }\n        if (DELAY_CONSUMER != 0) {\n            Blackhole.consumeCPU(DELAY_CONSUMER);\n        }\n    }",
      "line_number": 98,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "QueueThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "emptyQ",
      "signature": "public void emptyQ() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/QueueThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "synchronized"
      ],
      "dependencies": [
        "clear",
        "q.clear"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 6,
      "source_code": "        synchronized (q)\n        {\n            q.clear();\n        }\n    }",
      "line_number": 114,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "QueueThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public void poll(PollCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpscIntrusiveLinkedQueueThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "poll",
        "consumeCPU",
        "Blackhole.consumeCPU",
        "q.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 4,
      "source_code": "        Node n = q.poll();\n        if (n == null) {\n            counters.pollsFailed++;\n            backoff();\n        } else {\n            counters.pollsMade++;\n        }\n        if (DELAY_CONSUMER != 0) {\n            Blackhole.consumeCPU(DELAY_CONSUMER);\n        }\n    }",
      "line_number": 82,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueueThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "consumerClearQueue",
      "signature": "public void consumerClearQueue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpscIntrusiveLinkedQueueThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "synchronized"
      ],
      "dependencies": [
        "clear",
        "q.clear"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 6,
      "source_code": "        synchronized (q)\n        {\n            q.clear();\n        }\n    }",
      "line_number": 100,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueueThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "backoff",
      "signature": "protected void backoff() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/QueueThroughputBackoffNano.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "LockSupport.parkNanos",
        "parkNanos"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        LockSupport.parkNanos(1L);\n    }",
      "line_number": 21,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "QueueThroughputBackoffNano",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(final OfferCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqDrainFillThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "q.fill",
        "fill"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        long filled = q.fill(counters);\n        if (filled == 0) {\n            counters.offersFailed++;\n            backoff();\n        }\n    }",
      "line_number": 91,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqDrainFillThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(final PollCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqDrainFillThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "drain",
        "q.drain"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        long drained = q.drain(counters);\n        if (drained == 0) {\n            counters.pollsFailed++;\n            backoff();\n        }\n    }",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqDrainFillThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "emptyQ",
      "signature": "public void emptyQ() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqDrainFillThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "synchronized"
      ],
      "dependencies": [
        "poll",
        "q.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 8,
      "source_code": "        synchronized (q)\n        {\n            while (q.poll() != null)\n                ;\n        }\n    }",
      "line_number": 110,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "MpqDrainFillThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "build",
      "signature": "static Counter build(CounterType type, int stripes) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "static"
      ],
      "dependencies": [
        "ConcurrentAutoTableCounter",
        "LongAdderCounter",
        "FixedSizeStripedCounter",
        "AtomicLongCounter",
        "IllegalArgumentException"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern",
        "lock_free_algorithm"
      ],
      "complexity_score": 11,
      "source_code": "        switch (type) {\n        case AtomicLong:\n            return new AtomicLongCounter();\n        case LongAdder:\n            return new LongAdderCounter();\n        case FixedSizeStripedV6:\n            return new FixedSizeStripedCounter(createFixedSizeStripedCounterV6(stripes));\n        case FixedSizeStripedV8:\n            return new FixedSizeStripedCounter(createFixedSizeStripedCounterV8(stripes));\n        case CAT:\n            return new ConcurrentAutoTableCounter();\n        default:\n            throw new IllegalArgumentException();\n        }\n    }",
      "line_number": 25,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "inc",
      "signature": "public void inc() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [
        "incrementAndGet"
      ],
      "dependencies": [
        "incrementAndGet",
        "counter.incrementAndGet"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            counter.incrementAndGet();\n        }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "counter.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return counter.get();\n        }",
      "line_number": 53,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "counter.sum",
        "sum"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return counter.sum();\n        }",
      "line_number": 67,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "counter.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return counter.get();\n        }",
      "line_number": 85,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "counter.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return counter.get();\n        }",
      "line_number": 103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "prepare",
      "signature": "public void prepare() throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/SetOps.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "r.nextInt",
        "add",
        "nextInt",
        "Random",
        "Key",
        "set.add"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        set = createSet(type, size);\n        Random r = new Random(666);\n\n        for (int i = 0; i < occupancy - 1; i++) {\n            set.add(new Key(r.nextInt(keyBound)));\n        }\n        key = new Key(r.nextInt(keyBound));\n        set.add(key);\n    }",
      "line_number": 54,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SetOps",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/SetOps.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "set.add",
        "add"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return set.add(key);\n    }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SetOps",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/SetOps.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "remove",
        "set.remove"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return set.remove(key);\n    }",
      "line_number": 71,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SetOps",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/SetOps.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "set.contains",
        "contains"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return set.contains(key);\n    }",
      "line_number": 76,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SetOps",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public int sum() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/SetOps.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        int sum = 0;\n        for(Key k : set) {\n            sum += k.hash;\n        }\n        return sum;\n    }",
      "line_number": 81,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SetOps",
      "method_type": "method"
    },
    {
      "name": "createSet",
      "signature": "public static Set<Key> createSet(String queueType, final int capacity) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/SetOps.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "forName",
        "constructor.newInstance",
        "newInstance",
        "HashObjSets.newMutableSet",
        "getConstructor",
        "clazz.getConstructor",
        "Class.forName",
        "queueType.equals",
        "newMutableSet",
        "Key",
        "equals"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "//        if(queueType.equals(\"koloboke\")) {\n//            return HashObjSets.newMutableSet(capacity);\n//        }\n\n        Class clazz = Class.forName(queueType);\n        Constructor constructor;\n        constructor = clazz.getConstructor(Integer.TYPE);\n        return (Set<Key>) constructor.newInstance(capacity);\n    }",
      "line_number": 90,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SetOps",
      "method_type": "method"
    },
    {
      "name": "createSet",
      "signature": "public void createSet(ThreadParams threads) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        createImplementation(threads);\n        setRatios();\n    }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSetThroughput",
      "method_type": "method"
    },
    {
      "name": "createImplementation",
      "signature": "private void createImplementation(ThreadParams threads) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread",
        "ConcurrentHashMap"
      ],
      "dependencies": [
        "SingleWriterHashSet",
        "threads.getSubgroupThreadCount",
        "threads.getGroupIndex",
        "getGroupIndex",
        "threads.getSubgroupIndex",
        "ConcurrentHashMap",
        "String",
        "IllegalArgumentException",
        "getSubgroupIndex",
        "Collections.newSetFromMap",
        "newSetFromMap",
        "NonBlockingHashSet",
        "equalsIgnoreCase",
        "getSubgroupThreadCount"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "        if (\"ConcurrentHashSet\".equalsIgnoreCase(implementation)) {\n            set = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());\n        } else if (\"NonBlockingHashSet\".equalsIgnoreCase(implementation)) {\n            set = new NonBlockingHashSet<String>();\n        } else if (\"SingleWriterHashSet\".equalsIgnoreCase(implementation)) {\n            if (threads.getGroupIndex() == 0 && threads.getSubgroupIndex() == 0 && threads.getSubgroupThreadCount() != 1) {\n                throw new IllegalArgumentException(\"Trying to benchmark SingleWriterHashSet with multiple writer threads\");\n            }\n            set = new SingleWriterHashSet<String>(16);\n        } else {\n            throw new IllegalArgumentException(\"Unsupported map: \" + implementation);\n        }\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSetThroughput",
      "method_type": "method"
    },
    {
      "name": "setRatios",
      "signature": "private void setRatios() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        containsRatio = (readRatio << 20) / 100;\n        addRatio = (((1 << 20) - containsRatio) >> 1) + containsRatio;\n    }",
      "line_number": 72,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSetThroughput",
      "method_type": "method"
    },
    {
      "name": "prepareSet",
      "signature": "public void prepareSet() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "size",
        "add",
        "valueOf",
        "nextInt",
        "AssertionError",
        "roundToPowerOfTwo",
        "rand.nextInt",
        "set.remove",
        "Random",
        "set.size",
        "set.add",
        "remove",
        "String.valueOf",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        testData = new String[Pow2.roundToPowerOfTwo(tableSize)];\n        for (int i = 0; i < testData.length; i++) {\n            testData[i] = String.valueOf(i) + \"abc\" + String.valueOf(i * 17 + 123);\n        }\n\n        Random rand = new Random();\n\n        int sz = set.size();\n        while (sz + 1024 < tableSize) {\n            int idx = rand.nextInt();\n            for (int i = 0; i < 1024; i++) {\n                String key = testData[idx & (testData.length - 1)];\n                set.add(key);\n                idx++;\n            }\n            sz = set.size();\n        }\n\n        while (sz < ((tableSize >> 1) + (tableSize >> 3))) {\n            int trip = 0;\n            int idx = rand.nextInt();\n            while (true) {\n                String key = testData[idx & (testData.length - 1)];\n                if (sz < tableSize) {\n                    if (set.add(key)) {\n                        sz++;\n                        break;\n                    }\n                } else if (set.remove(key)) {\n                    sz--;\n                    break;\n                }\n                idx++;\n                if ((trip & 15) == 15) {\n                    idx = rand.nextInt();\n                }\n                ++trip;\n            }\n        }\n\n        if (sz != set.size()) {\n            throw new AssertionError(\"Size does not match table contents sz=\" + sz + \" size()=\" + set.size());\n        }\n    }",
      "line_number": 78,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSetThroughput",
      "method_type": "method"
    },
    {
      "name": "randomContainsAddRemove",
      "signature": "public boolean randomContainsAddRemove(ThreadState state) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "contains",
        "add",
        "next",
        "set.contains",
        "set.remove",
        "state.next",
        "set.add",
        "remove"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        String key = testData[state.next() & (testData.length - 1)];\n        int x = state.next() & ((1 << 20) - 1);\n        if (x < containsRatio) {\n            return set.contains(key);\n        } else if (x < addRatio) {\n            return set.add(key);\n        } else {\n            return set.remove(key);\n        }\n    }",
      "line_number": 126,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSetThroughput",
      "method_type": "method"
    },
    {
      "name": "randomGet",
      "signature": "public boolean randomGet(ThreadState state) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "set.contains",
        "contains",
        "state.next",
        "next"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        String key = testData[state.next() & (testData.length - 1)];\n        return set.contains(key);\n    }",
      "line_number": 140,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSetThroughput",
      "method_type": "method"
    },
    {
      "name": "initialValue",
      "signature": "protected Integer initialValue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "getAndIncrement",
        "idx.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return idx.getAndIncrement();\n        }",
      "line_number": 74,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "RingBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "Link",
      "signature": "public Link() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tlIndex.get",
        "get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            int id = tlIndex.get();\n            // the old in out, in out\n            this.in = chain[id % CHAIN_LENGTH];\n            this.out = chain[(id + 1) % CHAIN_LENGTH];\n        }",
      "line_number": 90,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "RingBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "link",
      "signature": "public void link() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "poll",
        "offer",
        "in.poll",
        "out.offer"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 2,
      "source_code": "            // we could use the control here, but there's no reason as it is use externally and we only\n            // really want to measure the ping method\n            Integer e = in.poll();\n            if (e != null) {\n                out.offer(e);\n            }\n        }",
      "line_number": 97,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "RingBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "Source",
      "signature": "public Source() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tlIndex.get",
        "get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            int id = tlIndex.get();\n            // the source ties the knot in our ring\n            this.end = chain[id % CHAIN_LENGTH];\n            this.start = chain[(id + 1) % CHAIN_LENGTH];\n        }",
      "line_number": 128,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "RingBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "prepareChain",
      "signature": "public void prepareChain() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "QueueByTypeFactory.createQueue",
        "createQueue"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        // can't have group threads set to zero on a method, so can't handle the length of 1 case\n        if (CHAIN_LENGTH < 2) {\n            throw new IllegalArgumentException(\"Chain length must be 2 or more\");\n        }\n        // This is an estimate, but for bounded queues if the burst size is more than actual ring capacity\n        // the benchmark will hang/\n        if (BURST_SIZE > QueueByTypeFactory.QUEUE_CAPACITY * CHAIN_LENGTH >> 1) {\n            throw new IllegalArgumentException(\"Batch size exceeds estimated capacity\");\n        }\n        // initialize the chain\n        for (int i = 0; i < CHAIN_LENGTH; i++) {\n            chain[i] = QueueByTypeFactory.createQueue();\n        }\n    }",
      "line_number": 156,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RingBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "initialValue",
      "signature": "protected Integer initialValue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingCqBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "getAndIncrement",
        "idx.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return idx.getAndIncrement();\n        }",
      "line_number": 76,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "RingCqBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "Link",
      "signature": "public Link() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingCqBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "consumer",
        "get",
        "producer",
        "tlIndex.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            int id = tlIndex.get();\n            // the old in out, in out\n            this.in = chain[id % CHAIN_LENGTH].consumer();\n            this.out = chain[(id + 1) % CHAIN_LENGTH].producer();\n        }",
      "line_number": 92,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "RingCqBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "link",
      "signature": "public void link() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingCqBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "poll",
        "offer",
        "in.poll",
        "out.offer"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 2,
      "source_code": "            // we could use the control here, but there's no reason as it is use externally and we only\n            // really want to measure the ping method\n            Integer e = in.poll();\n            if (e != null) {\n                out.offer(e);\n            }\n        }",
      "line_number": 99,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "RingCqBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "Source",
      "signature": "public Source() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingCqBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "consumer",
        "get",
        "producer",
        "tlIndex.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            int id = tlIndex.get();\n            // the source ties the knot in our ring\n            this.end = chain[id % CHAIN_LENGTH].consumer();\n            this.start = chain[(id + 1) % CHAIN_LENGTH].producer();\n        }",
      "line_number": 130,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "RingCqBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "prepareChain",
      "signature": "public void prepareChain() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingCqBurstRoundTripWithGroups.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "ConcurrentQueueByTypeFactory.createQueue",
        "createQueue"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        // can't have group threads set to zero on a method, so can't handle the length of 1 case\n        if (CHAIN_LENGTH < 2) {\n            throw new IllegalArgumentException(\"Chain length must be 2 or more\");\n        }\n        // This is an estimate, but for bounded queues if the burst size is more than actual ring capacity\n        // the benchmark will hang/\n        if (BURST_SIZE > ConcurrentQueueByTypeFactory.QUEUE_CAPACITY * CHAIN_LENGTH >> 1) {\n            throw new IllegalArgumentException(\"Batch size exceeds estimated capacity\");\n        }\n        // initialize the chain\n        for (int i = 0; i < CHAIN_LENGTH; i++) {\n            chain[i] = ConcurrentQueueByTypeFactory.createQueue();\n        }\n    }",
      "line_number": 158,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RingCqBurstRoundTripWithGroups",
      "method_type": "method"
    },
    {
      "name": "handle",
      "signature": "void handle() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/MpqRelaxedBurstCost.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            lazySet(true);\n        }",
      "line_number": 54,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpqRelaxedBurstCost",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/MpqRelaxedBurstCost.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "handle",
        "relaxedPoll",
        "AbstractEvent",
        "q.relaxedPoll",
        "e.handle"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "            final MessagePassingQueue<AbstractEvent> q = this.q;\n            while (isRunning) {\n                AbstractEvent e = null;\n                while ((e = q.relaxedPoll()) == null);\n                e.handle();\n            }\n        }",
      "line_number": 68,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqRelaxedBurstCost",
      "method_type": "method"
    },
    {
      "name": "setupQueueAndConsumer",
      "signature": "public void setupQueueAndConsumer() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/MpqRelaxedBurstCost.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "MessagePassingQueueByTypeFactory.createQueue",
        "relaxedPoll",
        "createQueue",
        "relaxedOffer",
        "q.relaxedOffer",
        "Thread",
        "q.relaxedPoll",
        "start",
        "Consumer",
        "consumerThread.start"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        q = MessagePassingQueueByTypeFactory.createQueue(qType, 128);\n\n        // stretch the queue to the limit, working through resizing and full\n        for (int i = 0; i < 128 + 100; i++) {\n            q.relaxedOffer(GO);\n        }\n        for (int i = 0; i < 128 + 100; i++) {\n            q.relaxedPoll();\n        }\n        // make sure the important common case is exercised\n        for (int i = 0; i < 20000; i++) {\n            q.relaxedOffer(GO);\n            q.relaxedPoll();\n        }\n        q = MessagePassingQueueByTypeFactory.createQueue(qType, 128 * 1024);\n        consumer = new Consumer(q);\n        consumerThread = new Thread(consumer);\n        consumerThread.start();\n    }",
      "line_number": 94,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqRelaxedBurstCost",
      "method_type": "method"
    },
    {
      "name": "burstCost",
      "signature": "public void burstCost() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/MpqRelaxedBurstCost.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "stop.lazySet",
        "get",
        "AbstractEvent",
        "relaxedOffer",
        "q.relaxedOffer",
        "stop.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final Stop stop = this.stop;\n        final int burst = burstSize;\n        final MessagePassingQueue<AbstractEvent> q = this.q;\n        final Go go = GO;\n        stop.lazySet(false);\n        for (int i = 0; i < burst - 1; i++) {\n            while (!q.relaxedOffer(go));\n        }\n\n        while (!q.relaxedOffer(stop));\n\n        while (!stop.get());\n    }",
      "line_number": 116,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpqRelaxedBurstCost",
      "method_type": "method"
    },
    {
      "name": "killConsumer",
      "signature": "public void killConsumer() throws InterruptedException {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/MpqRelaxedBurstCost.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "relaxedOffer",
        "q.relaxedOffer",
        "consumerThread.join",
        "join"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        consumer.isRunning = false;\n        while (!q.relaxedOffer(GO));\n        consumerThread.join();\n    }",
      "line_number": 132,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpqRelaxedBurstCost",
      "method_type": "method"
    },
    {
      "name": "setup",
      "signature": "public void setup(final Blackhole blackhole) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/channels/ChannelThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "producer",
        "Ping",
        "channel.producer",
        "channel.consumer",
        "ChannelReceiver",
        "MpscChannel",
        "roundToPowerOfTwo",
        "allocateDirect",
        "blackhole.consume",
        "OfferCounters",
        "IllegalArgumentException",
        "consumer",
        "PollCounters",
        "consume",
        "SpscChannel",
        "getValue",
        "element.getValue",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        receiver = new ChannelReceiver<Ping>() {\n            @Override\n            public void accept(Ping element) {\n                blackhole.consume(element.getValue());\n            }\n        };\n        buffer = ByteBuffer\n                .allocateDirect(Pow2.roundToPowerOfTwo(capacity * 2) * (8 + 4) + PortableJvmInfo.CACHE_LINE_SIZE * 5);\n\n        switch (type) {\n        case Spsc:\n            channel = new SpscChannel<Ping>(buffer, capacity, Ping.class);\n            break;\n        case Mpsc:\n            channel = new MpscChannel<Ping>(buffer, capacity, Ping.class);\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        producer = channel.producer();\n        consumer = channel.consumer(receiver);\n        OfferCounters oc = new OfferCounters();\n        PollCounters pc = new PollCounters();\n        for (int i = 0; i < 100000; i++) {\n            offer(oc);\n            poll(pc, null);\n        }\n    }",
      "line_number": 72,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ChannelThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "accept",
      "signature": "public void accept(Ping element) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/channels/ChannelThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getValue",
        "blackhole.consume",
        "consume",
        "element.getValue"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "                blackhole.consume(element.getValue());\n            }",
      "line_number": 75,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ChannelThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "ConsumerMarker",
      "signature": "public ConsumerMarker() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/channels/ChannelThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "marker.set",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            marker.set(this);\n        }",
      "line_number": 120,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ChannelThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public void offer(OfferCounters counters) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/channels/ChannelThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "consumeCPU",
        "claim",
        "lProducer.claim",
        "Ping",
        "setValue",
        "lProducer.currentElement",
        "currentElement",
        "lProducer.commit",
        "Blackhole.consumeCPU",
        "element.setValue",
        "commit"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        ChannelProducer<Ping> lProducer = producer;\n        if (!lProducer.claim()) {\n            counters.offersFailed++;\n        } else {\n            Ping element = lProducer.currentElement();\n            element.setValue(writeValue);\n            lProducer.commit();\n            counters.offersMade++;\n        }\n        if (DELAY_PRODUCER != 0) {\n            Blackhole.consumeCPU(DELAY_PRODUCER);\n        }\n    }",
      "line_number": 127,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ChannelThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "emptyQ",
      "signature": "public void emptyQ() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/channels/ChannelThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "marker.get",
        "get",
        "read",
        "consumer.read"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        if (marker.get() == null)\n            return;\n        // sadly the iteration tear down is performed from each participating thread, so we need to guess\n        // which is which (can't have concurrent access to poll).\n        while (consumer.read())\n            ;\n    }",
      "line_number": 156,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ChannelThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws RunnerException {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/channels/ChannelThroughputBackoffNone.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "getSimpleName",
        "OptionsBuilder",
        "Runner",
        "param",
        "class.getSimpleName",
        "run",
        "build",
        "forks",
        "include"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        Options opt = new OptionsBuilder().forks(0)\n                .include(ChannelThroughputBackoffNone.class.getSimpleName()).param(\"type\", \"Mpsc\")\n                .build();\n\n        new Runner(opt).run();\n    }",
      "line_number": 164,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "ChannelThroughputBackoffNone",
      "method_type": "method"
    },
    {
      "name": "createQandPrimeCompilation",
      "signature": "public void createQandPrimeCompilation() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/channels/spsc/QueueThroughputBaseline.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueByTypeFactory.buildQ",
        "MessagePassingQueueByTypeFactory.createQueue",
        "relaxedPoll",
        "createQueue",
        "relaxedOffer",
        "q.relaxedOffer",
        "q.relaxedPoll",
        "buildQ"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        final String qType = this.qType;\n\n        q = MessagePassingQueueByTypeFactory.createQueue(qType, 128);\n        // stretch the queue to the limit, working through resizing and full\n        for (int i = 0; i < 128+100; i++) {\n            q.relaxedOffer(ONE);\n        }\n        for (int i = 0; i < 128+100; i++) {\n            q.relaxedPoll();\n\n        }\n        // make sure the important common case is exercised\n        for (int i = 0; i < 20000; i++) {\n            q.relaxedOffer(ONE);\n            q.relaxedPoll();\n        }\n        final String qCapacity = this.qCapacity;\n\n        this.q = MessagePassingQueueByTypeFactory.buildQ(qType, qCapacity);\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "QueueThroughputBaseline",
      "method_type": "method"
    },
    {
      "name": "ConsumerMarker",
      "signature": "public ConsumerMarker() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/channels/spsc/QueueThroughputBaseline.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "marker.set",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            marker.set(this);\n        }",
      "line_number": 80,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "QueueThroughputBaseline",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public void poll(PollCounters counters, ConsumerMarker cm, Blackhole bh) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/channels/spsc/QueueThroughputBaseline.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "relaxedPoll",
        "bh.consume",
        "consume",
        "q.relaxedPoll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 2,
      "source_code": "        Integer e = q.relaxedPoll();\n        if (e == null) {\n            counters.pollsFailed++;\n        } else {\n            bh.consume(e);\n            counters.pollsMade++;\n        }\n    }",
      "line_number": 98,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "QueueThroughputBaseline",
      "method_type": "method"
    },
    {
      "name": "emptyQ",
      "signature": "public void emptyQ() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-benchmarks/src/main/java/org/jctools/channels/spsc/QueueThroughputBaseline.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "marker.get",
        "get",
        "clear",
        "q.clear"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        if (marker.get() == null)\n            return;\n        // sadly the iteration tear down is performed from each participating thread, so we need to guess\n        // which is which (can't have concurrent access to poll).\n        q.clear();\n    }",
      "line_number": 109,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "QueueThroughputBaseline",
      "method_type": "method"
    },
    {
      "name": "AbstractEntry",
      "signature": "public AbstractEntry(final TypeK key, final TypeV val) { _key = key;        _val = val; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/AbstractEntry.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 33,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "AbstractEntry",
      "method_type": "constructor"
    },
    {
      "name": "AbstractEntry",
      "signature": "public AbstractEntry(final Map.Entry<TypeK,TypeV> e  ) { _key = e.getKey(); _val = e.getValue(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/AbstractEntry.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getKey",
        "TypeK",
        "e.getKey",
        "e.getValue",
        "getValue"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 34,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AbstractEntry",
      "method_type": "constructor"
    },
    {
      "name": "getKey",
      "signature": "public TypeK getKey  () { return _key;  }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/AbstractEntry.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 38,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "AbstractEntry",
      "method_type": "method"
    },
    {
      "name": "getValue",
      "signature": "public TypeV getValue() { return _val;  }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/AbstractEntry.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "AbstractEntry",
      "method_type": "method"
    },
    {
      "name": "equals",
      "signature": "public boolean equals(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/AbstractEntry.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "e.getKey",
        "getValue",
        "getKey",
        "e.getValue"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "    if (!(o instanceof Map.Entry)) return false;\n    final Map.Entry e = (Map.Entry)o;\n    return eq(_key, e.getKey()) && eq(_val, e.getValue());\n  }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AbstractEntry",
      "method_type": "method"
    },
    {
      "name": "eq",
      "signature": "private static boolean eq(final Object o1, final Object o2) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/AbstractEntry.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "o1.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return (o1 == null ? o2 == null : o1.equals(o2));\n  }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "AbstractEntry",
      "method_type": "method"
    },
    {
      "name": "rawIndex",
      "signature": "private static long rawIndex(final Object[] ary, final int idx) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    assert idx >= 0 && idx < ary.length;\n    // Note the long-math requirement, to handle arrays of more than 2^31 bytes\n    // - or 2^28 - or about 268M - 8-byte pointer elements.\n    return _Obase + ((long)idx << _Olog);\n  }",
      "line_number": 95,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_kvs",
      "signature": "private final boolean CAS_kvs( final Object[] oldkvs, final Object[] newkvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject(this, _kvs_offset, oldkvs, newkvs );\n  }",
      "line_number": 105,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "unbox",
      "signature": "static Object unbox( Object V ) { return V instanceof Prime ? ((Prime)V)._V : V; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 113,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "hash",
      "signature": "private static final int hash(final Object key) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "hashCode",
        "key.hashCode"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "    int h = key.hashCode();     // The real hashCode call\n    h ^= (h>>>20) ^ (h>>>12);\n    h ^= (h>>> 7) ^ (h>>> 4);\n\th += h<<7; // smear low bits up high, for hashcodes that only differ by 1\n    return h;\n  }",
      "line_number": 120,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "chm",
      "signature": "private static final CHM   chm   (Object[] kvs) { return (CHM  )kvs[0]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 140,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "hashes",
      "signature": "private static final int[] hashes(Object[] kvs) { return (int[])kvs[1]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "len",
      "signature": "private static final int len(Object[] kvs) { return (kvs.length-2)>>1; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 143,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "key",
      "signature": "private static final Object key(Object[] kvs,int idx) { return kvs[(idx<<1)+2]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 177,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "val",
      "signature": "private static final Object val(Object[] kvs,int idx) { return kvs[(idx<<1)+3]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 178,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_key",
      "signature": "private static final boolean CAS_key( Object[] kvs, int idx, Object old, Object key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject( kvs, rawIndex(kvs,(idx<<1)+2), old, key );\n  }",
      "line_number": 179,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_val",
      "signature": "private static final boolean CAS_val( Object[] kvs, int idx, Object old, Object val ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject( kvs, rawIndex(kvs,(idx<<1)+3), old, val );\n  }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "public final void print() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    System.out.println(\"=========\");\n    print2(_kvs);\n    System.out.println(\"=========\");\n  }",
      "line_number": 189,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "private final void print( Object[] kvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "println",
        "Prime.unbox",
        "U.toString",
        "K.toString",
        "unbox",
        "toString"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "    for( int i=0; i<len(kvs); i++ ) {\n      Object K = key(kvs,i);\n      if( K != null ) {\n        String KS = (K == TOMBSTONE) ? \"XXX\" : K.toString();\n        Object V = val(kvs,i);\n        Object U = Prime.unbox(V);\n        String p = (V==U) ? \"\" : \"prime_\";\n        String US = (U == TOMBSTONE) ? \"tombstone\" : U.toString();\n        System.out.println(\"\"+i+\" (\"+KS+\",\"+p+US+\")\");\n      }\n    }\n    Object[] newkvs = chm(kvs)._newkvs; // New table, if any\n    if( newkvs != null ) {\n      System.out.println(\"----\");\n      print(newkvs);\n    }\n  }",
      "line_number": 195,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print2",
      "signature": "private final void print2( Object[] kvs) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "println",
        "unbox",
        "Prime.unbox"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "    for( int i=0; i<len(kvs); i++ ) {\n      Object key = key(kvs,i);\n      Object val = val(kvs,i);\n      Object U = Prime.unbox(val);\n      if( key != null && key != TOMBSTONE &&  // key is sane\n          val != null && U   != TOMBSTONE ) { // val is sane\n        String p = (val==U) ? \"\" : \"prime_\";\n        System.out.println(\"\"+i+\" (\"+key+\",\"+p+val+\")\");\n      }\n    }\n    Object[] newkvs = chm(kvs)._newkvs; // New table, if any\n    if( newkvs != null ) {\n      System.out.println(\"----\");\n      print2(newkvs);\n    }\n  }",
      "line_number": 214,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "reprobes",
      "signature": "public long reprobes() { long r = _reprobes.get(); _reprobes = new ConcurrentAutoTable(); return r; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "_reprobes.get",
        "get",
        "ConcurrentAutoTable"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 239,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "reprobe_limit",
      "signature": "private static int reprobe_limit( int len ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "    return REPROBE_LIMIT + (len>>4);\n  }",
      "line_number": 247,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingHashMap",
      "signature": "public NonBlockingHashMap( ) { this(MIN_SIZE); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 256,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingHashMap",
      "signature": "public NonBlockingHashMap( final int initial_sz ) { initialize(initial_sz); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 263,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "initialize",
      "signature": "private final void initialize( int initial_sz ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "RangeUtil.checkPositiveOrZero",
        "System.currentTimeMillis",
        "ConcurrentAutoTable",
        "CHM",
        "checkPositiveOrZero",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 7,
      "source_code": "    RangeUtil.checkPositiveOrZero(initial_sz, \"initial_sz\");\n    int i;                      // Convert to next largest power-of-2\n    if( initial_sz > 1024*1024 ) initial_sz = 1024*1024;\n    for( i=MIN_SIZE_LOG; (1<<i) < (initial_sz<<2); i++ ) ;\n    // Double size for K,V pairs, add 1 for CHM and 1 for hashes\n    _kvs = new Object[((1<<i)<<1)+2];\n    _kvs[0] = new CHM(new ConcurrentAutoTable()); // CHM in slot 0\n    _kvs[1] = new int[1<<i];          // Matching hash entries\n    _last_resize_milli = System.currentTimeMillis();\n  }",
      "line_number": 264,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "initialize",
      "signature": "protected final void initialize() { initialize(MIN_SIZE); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 276,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "containsKey",
      "signature": "public boolean containsKey( Object key )            { return get(key) != null; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 293,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public TypeV   put        ( TypeK  key, TypeV val ) { return putIfMatch( key,      val, NO_MATCH_OLD); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 315,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfAbsent",
      "signature": "public TypeV   putIfAbsent( TypeK  key, TypeV val ) { return putIfMatch( key,      val, TOMBSTONE   ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 324,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public TypeV   remove     ( Object key )            { return putIfMatch( key,TOMBSTONE, NO_MATCH_OLD); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 332,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove     ( Object key,Object val ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "    return objectsEquals(putIfMatch( key,TOMBSTONE, val ), val);\n  }",
      "line_number": 337,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "replace",
      "signature": "public TypeV   replace    ( TypeK  key, TypeV val ) { return putIfMatch( key,      val,MATCH_ANY   ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 345,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "replace",
      "signature": "public boolean replace    ( TypeK  key, TypeV  oldValue, TypeV newValue ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "    return objectsEquals(putIfMatch( key, newValue, oldValue ), oldValue);\n  }",
      "line_number": 351,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "objectsEquals",
      "signature": "private static boolean objectsEquals(Object a, Object b) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "a.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "    return (a == b) || (a != null && a.equals(b));\n  }",
      "line_number": 354,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfMatchAllowNull",
      "signature": "public final TypeV putIfMatchAllowNull( Object key, Object newVal, Object oldVal ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "    if( oldVal == null ) oldVal = TOMBSTONE;\n    if( newVal == null ) newVal = TOMBSTONE;\n    final TypeV res = (TypeV) putIfMatch0(this, _kvs, key, newVal, oldVal );\n    assert !(res instanceof Prime);\n    //assert res != null;\n    return res == TOMBSTONE ? null : res;\n  }",
      "line_number": 362,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfMatch",
      "signature": "public final TypeV putIfMatch( Object key, Object newVal, Object oldVal ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "    if (oldVal == null || newVal == null) throw new NullPointerException();\n    final Object res = putIfMatch0(this, _kvs, key, newVal, oldVal );\n    assert !(res instanceof Prime);\n    assert res != null;\n    return res == TOMBSTONE ? null : (TypeV)res;\n  }",
      "line_number": 378,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putAll",
      "signature": "public void putAll(Map<? extends TypeK, ? extends TypeV> m) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "entrySet",
        "getKey",
        "e.getKey",
        "e.getValue",
        "m.entrySet",
        "getValue"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "    for (Map.Entry<? extends TypeK, ? extends TypeV> e : m.entrySet())\n      put(e.getKey(), e.getValue());\n  }",
      "line_number": 391,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void clear() {         // Smack a new empty table down",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "NonBlockingHashMap"
      ],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "    Object[] newkvs = new NonBlockingHashMap(MIN_SIZE)._kvs;\n    while( !CAS_kvs(_kvs,newkvs) ) // Spin until the clear works\n      ;\n  }",
      "line_number": 398,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "containsValue",
      "signature": "public boolean containsValue( final Object val ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "V.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "    if( val == null ) throw new NullPointerException();\n    for( TypeV V : values() )\n      if( V == val || V.equals(val) )\n        return true;\n    return false;\n  }",
      "line_number": 411,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clone",
      "signature": "public Object clone() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "t.put",
        "put",
        "TypeK",
        "InternalError",
        "super.clone",
        "clear",
        "t.clear",
        "clone"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "    try {\n      // Must clone, to get the class right; NBHM might have been\n      // extended so it would be wrong to just make a new NBHM.\n      NonBlockingHashMap<TypeK,TypeV> t = (NonBlockingHashMap<TypeK,TypeV>) super.clone();\n      // But I don't have an atomic clone operation - the underlying _kvs\n      // structure is undergoing rapid change.  If I just clone the _kvs\n      // field, the CHM in _kvs[0] won't be in sync.\n      //\n      // Wipe out the cloned array (it was shallow anyways).\n      t.clear();\n      // Now copy sanely\n      for( TypeK K : keySet() ) {\n        final TypeV V = get(K);  // Do an official 'get'\n        t.put(K,V);\n      }\n      return t;\n    } catch (CloneNotSupportedException e) {\n      // this shouldn't happen, since we are Cloneable\n      throw new InternalError();\n    }\n  }",
      "line_number": 433,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "i.hasNext",
        "hasNext",
        "getKey",
        "next",
        "StringBuilder",
        "TypeK",
        "e.getKey",
        "e.getValue",
        "iterator",
        "append",
        "sb.append",
        "i.next",
        "getValue",
        "toString"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "    Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n    if( !i.hasNext())\n      return \"{}\";\n\n    StringBuilder sb = new StringBuilder();\n    sb.append('{');\n    for (;;) {\n      Entry<TypeK,TypeV> e = i.next();\n      TypeK key = e.getKey();\n      TypeV value = e.getValue();\n      sb.append(key   == this ? \"(this Map)\" : key);\n      sb.append('=');\n      sb.append(value == this ? \"(this Map)\" : value);\n      if( !i.hasNext())\n        return sb.append('}').toString();\n      sb.append(\", \");\n    }\n  }",
      "line_number": 469,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "keyeq",
      "signature": "private static boolean keyeq( Object K, Object key, int[] hashes, int hash, int fullhash ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "key.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "    return\n      K==key ||                 // Either keys match exactly OR\n      // hash exists and matches?  hash can be zero during the install of a\n      // new key/value pair.\n      ((hashes[hash] == 0 || hashes[hash] == fullhash) &&\n       // Do not call the users' \"equals()\" call with a Tombstone, as this can\n       // surprise poorly written \"equals()\" calls that throw exceptions\n       // instead of simply returning false.\n       K != TOMBSTONE &&        // Do not call users' equals call with a Tombstone\n       // Do the match the hard way - with the users' key being the loop-\n       // invariant \"this\" pointer.  I could have flipped the order of\n       // operands (since equals is commutative), but I'm making mega-morphic\n       // v-calls in a re-probing loop and nailing down the 'this' argument\n       // gives both the JIT and the hardware a chance to prefetch the call target.\n       key.equals(K));          // Finally do the hard match\n  }",
      "line_number": 493,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public TypeV get( Object key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    final Object V = get_impl(this,_kvs,key);\n    assert !(V instanceof Prime); // Never return a Prime\n    assert V != TOMBSTONE;\n    return (TypeV)V;\n  }",
      "line_number": 521,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "get_impl",
      "signature": "private static final Object get_impl( final NonBlockingHashMap topmap, final Object[] kvs, final Object key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "volatile",
        "Lock",
        "final",
        "lock"
      ],
      "dependencies": [
        "copy_slot_and_check",
        "help_copy",
        "chm.copy_slot_and_check",
        "topmap.help_copy"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 55,
      "source_code": "    final int fullhash= hash (key); // throws NullPointerException if key is null\n    final int len     = len  (kvs); // Count of key/value pairs, reads kvs.length\n    final CHM chm     = chm  (kvs); // The CHM, for a volatile read below; reads slot 0 of kvs\n    final int[] hashes=hashes(kvs); // The memoized hashes; reads slot 1 of kvs\n\n    int idx = fullhash & (len-1); // First key hash\n\n    // Main spin/reprobe loop, looking for a Key hit\n    int reprobe_cnt=0;\n    while( true ) {\n      // Probe table.  Each read of 'val' probably misses in cache in a big\n      // table; hopefully the read of 'key' then hits in cache.\n      final Object K = key(kvs,idx); // Get key   before volatile read, could be null\n      final Object V = val(kvs,idx); // Get value before volatile read, could be null or Tombstone or Prime\n      if( K == null ) return null;   // A clear miss\n\n      // We need a volatile-read here to preserve happens-before semantics on\n      // newly inserted Keys.  If the Key body was written just before inserting\n      // into the table a Key-compare here might read the uninitialized Key body.\n      // Annoyingly this means we have to volatile-read before EACH key compare.\n      // .\n      // We also need a volatile-read between reading a newly inserted Value\n      // and returning the Value (so the user might end up reading the stale\n      // Value contents).  Same problem as with keys - and the one volatile\n      // read covers both.\n      final Object[] newkvs = chm._newkvs; // VOLATILE READ before key compare\n\n      // Key-compare\n      if( keyeq(K,key,hashes,idx,fullhash) ) {\n        // Key hit!  Check for no table-copy-in-progress\n        if( !(V instanceof Prime) ) // No copy?\n          return (V == TOMBSTONE) ? null : V; // Return the value\n        // Key hit - but slot is (possibly partially) copied to the new table.\n        // Finish the copy & retry in the new table.\n        return get_impl(topmap,chm.copy_slot_and_check(topmap,kvs,idx,key),key); /",
      "line_number": 528,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "getk",
      "signature": "public TypeK getk( TypeK key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    return (TypeK)getk_impl(this,_kvs,key);\n  }",
      "line_number": 581,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "getk_impl",
      "signature": "private static final Object getk_impl( final NonBlockingHashMap topmap, final Object[] kvs, final Object key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "volatile",
        "Lock",
        "final",
        "lock"
      ],
      "dependencies": [
        "help_copy",
        "topmap.help_copy"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 45,
      "source_code": "    final int fullhash= hash (key); // throws NullPointerException if key is null\n    final int len     = len  (kvs); // Count of key/value pairs, reads kvs.length\n    final CHM chm     = chm  (kvs); // The CHM, for a volatile read below; reads slot 0 of kvs\n    final int[] hashes=hashes(kvs); // The memoized hashes; reads slot 1 of kvs\n\n    int idx = fullhash & (len-1); // First key hash\n\n    // Main spin/reprobe loop, looking for a Key hit\n    int reprobe_cnt=0;\n    while( true ) {\n      // Probe table.\n      final Object K = key(kvs,idx); // Get key before volatile read, could be null\n      if( K == null ) return null;   // A clear miss\n\n      // We need a volatile-read here to preserve happens-before semantics on\n      // newly inserted Keys.  If the Key body was written just before inserting\n      // into the table a Key-compare here might read the uninitialized Key body.\n      // Annoyingly this means we have to volatile-read before EACH key compare.\n      // .\n      // We also need a volatile-read between reading a newly inserted Value\n      // and returning the Value (so the user might end up reading the stale\n      // Value contents).  Same problem as with keys - and the one volatile\n      // read covers both.\n      final Object[] newkvs = chm._newkvs; // VOLATILE READ before key compare\n\n      // Key-compare\n      if( keyeq(K,key,hashes,idx,fullhash) )\n        return K;              // Return existing Key!\n\n      // get and put must have the same key lookup logic!  But only 'put'\n      // needs to force a table-resize for a too-long key-reprobe sequence.\n      // Check for too-many-reprobes on get - and flip to the new table.\n      if( ++reprobe_cnt >= reprobe_limit(len) || // too many probes\n          K == TOMBSTONE ) { // found a TOMBSTONE key, means no more keys in this table\n        return newkvs == null ? null : getk_impl(topmap,topmap.help_copy(newkvs),key); // Retry in the new table\n      }\n\n      idx = (idx+1)&(len-1);    // Reprobe by 1!  (could n",
      "line_number": 585,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "help_copy",
      "signature": "private final Object[] help_copy( Object[] helper ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "help_copy_impl",
        "topchm.help_copy_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "    // Read the top-level KVS only once.  We'll try to help this copy along,\n    // even if it gets promoted out from under us (i.e., the copy completes\n    // and another KVS becomes the top-level copy).\n    Object[] topkvs = _kvs;\n    CHM topchm = chm(topkvs);\n    if( topchm._newkvs == null ) return helper; // No copy in-progress\n    topchm.help_copy_impl(this,topkvs,false);\n    return helper;\n  }",
      "line_number": 818,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size () { return (int)_size.get(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "_size.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 835,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "slots",
      "signature": "public int slots() { return (int)_slots.get(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "_slots.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 848,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_newkvs",
      "signature": "boolean CAS_newkvs( Object[] newkvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "_newkvsUpdater.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "      while( _newkvs == null )\n        if( _newkvsUpdater.compareAndSet(this,null,newkvs) )\n          return true;\n      return false;\n    }",
      "line_number": 861,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "tableFull",
      "signature": "private final boolean tableFull( int reprobe_cnt, int len ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_slots.estimate_get",
        "estimate_get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      return\n        // Do the cheap check first: we allow some number of reprobes always\n        reprobe_cnt >= REPROBE_LIMIT &&\n        (reprobe_cnt >= reprobe_limit(len) ||\n         // More expensive check: see if the table is > 1/2 full.\n         _slots.estimate_get() >= (len>>1));\n    }",
      "line_number": 900,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private final Object[] resize( NonBlockingHashMap topmap, Object[] kvs) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "volatile",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "notifyAll",
        "notify",
        "lock"
      ],
      "dependencies": [
        "out.print",
        "12.5",
        "nanoTime",
        "sleep",
        "println",
        "compareAndSet",
        "print",
        "System.currentTimeMillis",
        "_resizerUpdater.compareAndSet",
        "5",
        "out.println",
        "topmap.rehash",
        "rehash",
        "Thread.sleep",
        "CHM",
        "RuntimeException",
        "System.nanoTime",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "observer_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 84,
      "source_code": "      assert chm(kvs) == this;\n\n      // Check for resize already in progress, probably triggered by another thread\n      Object[] newkvs = _newkvs; // VOLATILE READ\n      if( newkvs != null )       // See if resize is already in progress\n        return newkvs;           // Use the new table already\n\n      // No copy in-progress, so start one.  First up: compute new table size.\n      int oldlen = len(kvs);    // Old count of K,V pairs allowed\n      int sz = size();          // Get current table count of active K,V pairs\n      int newsz = sz;           // First size estimate\n\n      // Heuristic to determine new size.  We expect plenty of dead-slots-with-keys\n      // and we need some decent padding to avoid endless reprobing.\n      if( sz >= (oldlen>>2) ) { // If we are >25% full of keys then...\n        newsz = oldlen<<1;      // Double size, so new table will be between 12.5% and 25% full\n        // For tables less than 1M entries, if >50% full of keys then...\n        // For tables more than 1M entries, if >75% full of keys then...\n        if( 4L*sz >= ((oldlen>>20)!=0?3L:2L)*oldlen )\n          newsz = oldlen<<2;    // Double double size, so new table will be between %12.5 (18.75%) and 25% (25%)\n      }\n      // This heuristic in the next 2 lines leads to a much denser table\n      // with a higher reprobe rate\n      //if( sz >= (oldlen>>1) ) // If we are >50% full of keys then...\n      //  newsz = oldlen<<1;    // Double size\n\n      // Last (re)size operation was very recent?  Then double again\n      // despite having few live keys; slows down resize operations\n      // for tables subject to a high key churn rate - but do not\n      // forever grow the table.  If there is a high key churn rate\n      // the table needs a steady state of rare same-size resize\n      // operations to clean out the dead keys.\n      long tm = System.currentTimeMillis();\n      if( newsz <= oldlen && // New table would shrink or hold steady?\n          tm <= topmap._last_resize_milli+10000)  ",
      "line_number": 915,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "help_copy_impl",
      "signature": "private final void help_copy_impl( NonBlockingHashMap topmap, Object[] oldkvs, boolean copy_all ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "Math.min",
        "_copyIdxUpdater.compareAndSet",
        "min",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 43,
      "source_code": "      assert chm(oldkvs) == this;\n      Object[] newkvs = _newkvs;\n      assert newkvs != null;    // Already checked by caller\n      int oldlen = len(oldkvs); // Total amount to copy\n      final int MIN_COPY_WORK = Math.min(oldlen,1024); // Limit per-thread work\n\n      // ---\n      int panic_start = -1;\n      int copyidx=-9999;            // Fool javac to think it's initialized\n      while( _copyDone < oldlen ) { // Still needing to copy?\n        // Carve out a chunk of work.  The counter wraps around so every\n        // thread eventually tries to copy every slot repeatedly.\n\n        // We \"panic\" if we have tried TWICE to copy every slot - and it still\n        // has not happened.  i.e., twice some thread somewhere claimed they\n        // would copy 'slot X' (by bumping _copyIdx) but they never claimed to\n        // have finished (by bumping _copyDone).  Our choices become limited:\n        // we can wait for the work-claimers to finish (and become a blocking\n        // algorithm) or do the copy work ourselves.  Tiny tables with huge\n        // thread counts trying to copy the table often 'panic'.\n        if( panic_start == -1 ) { // No panic?\n          copyidx = (int)_copyIdx;\n          while( !_copyIdxUpdater.compareAndSet(this,copyidx,copyidx+MIN_COPY_WORK) )\n            copyidx = (int)_copyIdx;      // Re-read\n          if( !(copyidx < (oldlen<<1)) )  // Panic!\n            panic_start = copyidx;        // Record where we started to panic-copy\n        }\n\n        // We now know what to copy.  Try to copy.\n        int workdone = 0;\n        for( int i=0; i<MIN_COPY_WORK; i++ )\n          if( copy_slot(topmap,(copyidx+i)&(oldlen-1),oldkvs,newkvs) ) // Made an oldtable slot go dead?\n            workdone++;         // Yes!\n        if( workdone > 0 )      // Report work-done occasionally\n          copy_check_and_promote( topmap, oldkvs, workdone );// See if we can promote\n        //for( int i=0; i<MIN_COPY_WORK; i++ )\n        //  if( copy_slot(topmap,(copyidx+i)&(oldlen",
      "line_number": 1040,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_slot_and_check",
      "signature": "private final Object[] copy_slot_and_check( NonBlockingHashMap topmap, Object[] oldkvs, int idx, Object should_help ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "help_copy",
        "topmap.help_copy"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 9,
      "source_code": "      assert chm(oldkvs) == this;\n      Object[] newkvs = _newkvs; // VOLATILE READ\n      // We're only here because the caller saw a Prime, which implies a\n      // table-copy is in progress.\n      assert newkvs != null;\n      if( copy_slot(topmap,idx,oldkvs,_newkvs) )   // Copy the desired slot\n        copy_check_and_promote(topmap, oldkvs, 1); // Record the slot copied\n      // Generically help along any copy (except if called recursively from a helper)\n      return (should_help == null) ? newkvs : topmap.help_copy(newkvs);\n    }",
      "line_number": 1103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_check_and_promote",
      "signature": "private final void copy_check_and_promote( NonBlockingHashMap topmap, Object[] oldkvs, int workdone ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "CAS_kvs",
        "compareAndSet",
        "System.currentTimeMillis",
        "topmap.CAS_kvs",
        "_copyDoneUpdater.compareAndSet",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "      assert chm(oldkvs) == this;\n      int oldlen = len(oldkvs);\n      // We made a slot unusable and so did some of the needed copy work\n      long copyDone = _copyDone;\n      assert (copyDone+workdone) <= oldlen;\n      if( workdone > 0 ) {\n        while( !_copyDoneUpdater.compareAndSet(this,copyDone,copyDone+workdone) ) {\n          copyDone = _copyDone; // Reload, retry\n          assert (copyDone+workdone) <= oldlen;\n        }\n      }\n\n      // Check for copy being ALL done, and promote.  Note that we might have\n      // nested in-progress copies and manage to finish a nested copy before\n      // finishing the top-level copy.  We only promote top-level copies.\n      if( copyDone+workdone == oldlen && // Ready to promote this table?\n          topmap._kvs == oldkvs &&       // Looking at the top-level table?\n          // Attempt to promote\n          topmap.CAS_kvs(oldkvs,_newkvs) ) {\n        topmap._last_resize_milli = System.currentTimeMillis(); // Record resize time for next check\n      }\n    }",
      "line_number": 1116,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_slot",
      "signature": "private boolean copy_slot( NonBlockingHashMap topmap, int idx, Object[] oldkvs, Object[] newkvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread",
        "final"
      ],
      "dependencies": [
        "Prime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 31,
      "source_code": "      // Blindly set the key slot from null to TOMBSTONE, to eagerly stop\n      // fresh put's from inserting new values in the old table when the old\n      // table is mid-resize.  We don't need to act on the results here,\n      // because our correctness stems from box'ing the Value field.  Slamming\n      // the Key field is a minor speed optimization.\n      Object key;\n      while( (key=key(oldkvs,idx)) == null )\n        CAS_key(oldkvs,idx, null, TOMBSTONE);\n\n      // ---\n      // Prevent new values from appearing in the old table.\n      // Box what we see in the old table, to prevent further updates.\n      Object oldval = val(oldkvs,idx); // Read OLD table\n      while( !(oldval instanceof Prime) ) {\n        final Prime box = (oldval == null || oldval == TOMBSTONE) ? TOMBPRIME : new Prime(oldval);\n        if( CAS_val(oldkvs,idx,oldval,box) ) { // CAS down a box'd version of oldval\n          // If we made the Value slot hold a TOMBPRIME, then we both\n          // prevented further updates here but also the (absent)\n          // oldval is vacuously available in the new table.  We\n          // return with true here: any thread looking for a value for\n          // this key can correctly go straight to the new table and\n          // skip looking in the old table.\n          if( box == TOMBPRIME )\n            return true;\n          // Otherwise we boxed something, but it still needs to be\n          // copied into the new table.\n          oldval = box;         // Record updated oldval\n          break;                // Break loop; oldval is now boxed by us\n        }\n        oldval = val(oldkvs,idx); // Else try, try again\n      }\n      if( oldval == TOMBPRIME ) return false; // Copy already complete here!\n\n      // ---\n      // Copy the value into the new table, but only if we overwrite a null.\n      // If another value is already in the new table, then somebody else\n      // wrote something there and that write is happens-after any value that\n      // appears in the old",
      "line_number": 1150,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "SnapshotV",
      "signature": "public SnapshotV() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "help_copy_impl",
        "topchm.help_copy_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "      while( true ) {           // Verify no table-copy-in-progress\n        Object[] topkvs = _kvs;\n        CHM topchm = chm(topkvs);\n        if( topchm._newkvs == null ) { // No table-copy-in-progress\n          // The \"linearization point\" for the iteration.  Every key in this\n          // table will be visited, but keys added later might be skipped or\n          // even be added to a following table (also not iterated over).\n          _sskvs = topkvs;\n          break;\n        }\n        // Table copy in-progress - so we cannot get a clean iteration.  We\n        // must help finish the table copy before we can start iterating.\n        topchm.help_copy_impl(NonBlockingHashMap.this,topkvs,true);\n      }\n      // Warm-up the iterator\n      next();\n    }",
      "line_number": 1211,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "key",
      "signature": "Object key(int idx) { return NonBlockingHashMap.key(_sskvs,idx); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "NonBlockingHashMap.key",
        "key"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1230,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public TypeV next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "NoSuchElementException",
        "_nextK"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "      // 'next' actually knows what the next value will be - it had to\n      // figure that out last go-around lest 'hasNext' report true and\n      // some other thread deleted the last value.  Instead, 'next'\n      // spends all its effort finding the key that comes after the\n      // 'next' key.\n      if( _idx != 0 && _nextV == null ) throw new NoSuchElementException();\n      _prevK = _nextK;          // This will become the previous key\n      _prevV = _nextV;          // This will become the previous value\n      _nextV = null;            // We have no more next-key\n      // Attempt to set <_nextK,_nextV> to the next K,V pair.\n      // _nextV is the trigger: stop searching when it is != null\n      while( _idx<length() ) {  // Scan array\n        _nextK = key(_idx++); // Get a key that definitely is in the set (for the moment!)\n        if( _nextK != null && // Found something?\n            _nextK != TOMBSTONE &&\n            (_nextV=get(_nextK)) != null )\n          break;                // Got it!  _nextK is a valid Key\n      }                         // Else keep scanning\n      return _prevV;            // Return current value.\n    }",
      "line_number": 1235,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "removeKey",
      "signature": "public void removeKey() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "IllegalStateException",
        "putIfMatch",
        "this.putIfMatch"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 6,
      "source_code": "      if( _prevV == null ) throw new IllegalStateException();\n      NonBlockingHashMap.this.putIfMatch(_prevK, TOMBSTONE, NO_MATCH_OLD);\n      _prevV = null;\n    }",
      "line_number": 1257,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "values",
      "signature": "public Collection<TypeV> values() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "TypeV",
        "size",
        "this.containsValue",
        "clear",
        "SnapshotV",
        "containsValue",
        "AbstractCollection",
        "this.clear",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 15,
      "source_code": "    return new AbstractCollection<TypeV>() {\n      @Override public void    clear   (          ) {        NonBlockingHashMap.this.clear        ( ); }\n      @Override public int     size    (          ) { return NonBlockingHashMap.this.size         ( ); }\n      @Override public boolean contains( Object v ) { return NonBlockingHashMap.this.containsValue(v); }\n      @Override public Iterator<TypeV> iterator()   { return new SnapshotV(); }\n    };\n  }",
      "line_number": 1295,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "@Override public void    clear   (          ) {        NonBlockingHashMap.this.clear        ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1297,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "@Override public int     size    (          ) { return NonBlockingHashMap.this.size         ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1298,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "@Override public boolean contains( Object v ) { return NonBlockingHashMap.this.containsValue(v); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "containsValue",
        "this.containsValue"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1299,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "keySet",
      "signature": "public Set<TypeK> keySet() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "TypeK",
        "SnapshotK",
        "containsKey",
        "this.size",
        "getComponentType",
        "AbstractSet",
        "unbox",
        "this.containsKey",
        "arraycopy",
        "min",
        "newInstance",
        "copyOf",
        "a.getClass",
        "T",
        "this.remove",
        "getClass",
        "this.clear",
        "System.arraycopy",
        "OutOfMemoryError",
        "size",
        "Prime.unbox",
        "Math.min",
        "Array.newInstance",
        "clear",
        "Arrays.copyOf",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 29,
      "source_code": "    return new AbstractSet<TypeK> () {\n      @Override public void    clear   (          ) {        NonBlockingHashMap.this.clear   ( ); }\n      @Override public int     size    (          ) { return NonBlockingHashMap.this.size    ( ); }\n      @Override public boolean contains( Object k ) { return NonBlockingHashMap.this.containsKey(k); }\n      @Override public boolean remove  ( Object k ) { return NonBlockingHashMap.this.remove  (k) != null; }\n      @Override public Iterator<TypeK> iterator()   { return new SnapshotK(); }\n      // This is an efficient implementation of toArray instead of the standard\n      // one.  In particular it uses a smart iteration over the NBHM.\n      @Override public <T> T[] toArray(T[] a) {\n        Object[] kvs = raw_array();\n        // Estimate size of array; be prepared to see more or fewer elements\n        int sz = size();\n        T[] r = a.length >= sz ? a :\n          (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), sz);\n        // Fast efficient element walk.\n        int j=0;\n        for( int i=0; i<len(kvs); i++ ) {\n          Object K = key(kvs,i);\n          Object V = Prime.unbox(val(kvs,i));\n          if( K != null && K != TOMBSTONE && V != null && V != TOMBSTONE ) {\n            if( j >= r.length ) {\n              int sz2 = (int)Math.min(Integer.MAX_VALUE-8,((long)j)<<1);\n              if( sz2<=r.length ) throw new OutOfMemoryError(\"Required array size too large\");\n              r = Arrays.copyOf(r,sz2);\n            }\n            r[j++] = (T)K;\n          }\n        }\n        if( j <= a.length ) {   // Fit in the original array?\n          if( a!=r ) System.arraycopy(r,0,a,0,j);\n          if( j<a.length ) r[j++]=null; // One final null not in the spec but in the default impl\n          return a;             // Return the original\n        }\n        return Arrays.copyOf(r,j);\n      }\n    };\n  }",
      "line_number": 1334,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "@Override public void    clear   (          ) {        NonBlockingHashMap.this.clear   ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1336,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "@Override public int     size    (          ) { return NonBlockingHashMap.this.size    ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1337,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "@Override public boolean contains( Object k ) { return NonBlockingHashMap.this.containsKey(k); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "this.containsKey",
        "containsKey"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "@Override public boolean remove  ( Object k ) { return NonBlockingHashMap.this.remove  (k) != null; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "remove",
        "this.remove"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1339,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "@Override public <T> T[] toArray(T[] a) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "OutOfMemoryError",
        "Prime.unbox",
        "getComponentType",
        "min",
        "newInstance",
        "copyOf",
        "Math.min",
        "a.getClass",
        "Array.newInstance",
        "T",
        "unbox",
        "Arrays.copyOf",
        "getClass",
        "arraycopy",
        "System.arraycopy"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        Object[] kvs = raw_array();\n        // Estimate size of array; be prepared to see more or fewer elements\n        int sz = size();\n        T[] r = a.length >= sz ? a :\n          (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), sz);\n        // Fast efficient element walk.\n        int j=0;\n        for( int i=0; i<len(kvs); i++ ) {\n          Object K = key(kvs,i);\n          Object V = Prime.unbox(val(kvs,i));\n          if( K != null && K != TOMBSTONE && V != null && V != TOMBSTONE ) {\n            if( j >= r.length ) {\n              int sz2 = (int)Math.min(Integer.MAX_VALUE-8,((long)j)<<1);\n              if( sz2<=r.length ) throw new OutOfMemoryError(\"Required array size too large\");\n              r = Arrays.copyOf(r,sz2);\n            }\n            r[j++] = (T)K;\n          }\n        }\n        if( j <= a.length ) {   // Fit in the original array?\n          if( a!=r ) System.arraycopy(r,0,a,0,j);\n          if( j<a.length ) r[j++]=null; // One final null not in the spec but in the default impl\n          return a;             // Return the original\n        }\n        return Arrays.copyOf(r,j);\n      }",
      "line_number": 1343,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "setValue",
      "signature": "public TypeV setValue(final TypeV val) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      if( val == null ) throw new NullPointerException();\n      _val = val;\n      return put(_key, val);\n    }",
      "line_number": 1378,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "@Override public void    clear   (          ) {        NonBlockingHashMap.this.clear( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1421,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "@Override public int     size    (          ) { return NonBlockingHashMap.this.size ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1422,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "@Override public boolean remove( final Object o ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "getKey",
        "e.getKey",
        "e.getValue",
        "this.remove",
        "getValue",
        "remove"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if( !(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        return NonBlockingHashMap.this.remove(e.getKey(), e.getValue());\n      }",
      "line_number": 1423,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "@Override public boolean contains(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getKey",
        "v.equals",
        "e.getKey",
        "e.getValue",
        "getValue",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if( !(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        TypeV v = get(e.getKey());\n        return v != null && v.equals(e.getValue());\n      }",
      "line_number": 1428,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "writeObject",
      "signature": "private void writeObject(java.io.ObjectOutputStream s) throws IOException  {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "s.defaultWriteObject",
        "TypeK",
        "writeObject",
        "s.writeObject",
        "defaultWriteObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "    s.defaultWriteObject();     // Nothing to write\n    for( Object K : keySet() ) {\n      final Object V = get(K);  // Do an official 'get'\n      s.writeObject(K);         // Write the <TypeK,TypeV> pair\n      s.writeObject(V);\n    }\n    s.writeObject(null);        // Sentinel to indicate end-of-data\n    s.writeObject(null);\n  }",
      "line_number": 1440,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "readObject",
      "signature": "private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "defaultReadObject",
        "s.readObject",
        "s.defaultReadObject",
        "readObject"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "    s.defaultReadObject();      // Read nothing\n    initialize(MIN_SIZE);\n    for(;;) {\n      final TypeK K = (TypeK) s.readObject();\n      final TypeV V = (TypeV) s.readObject();\n      if( K == null ) break;\n      put(K,V);                 // Insert with an offical put\n    }\n  }",
      "line_number": 1453,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_nbsi",
      "signature": "private final boolean CAS_nbsi( NBSI old, NBSI nnn ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject(this, _nbsi_offset, old, nnn );\n  }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "NonBlockingSetInt",
      "signature": "public NonBlockingSetInt( ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "NBSI",
        "ConcurrentAutoTable"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "    _nbsi = new NBSI(63, new ConcurrentAutoTable(), this); // The initial 1-word set\n  }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "constructor"
    },
    {
      "name": "add",
      "signature": "public boolean add ( final Integer i ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "intValue",
        "i.intValue"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return add(i.intValue());\n  }",
      "line_number": 77,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains( final Object  o ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "intValue"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return o instanceof Integer && contains(((Integer) o).intValue());\n  }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove( final Object  o ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "intValue"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return o instanceof Integer && remove(((Integer) o).intValue());\n  }",
      "line_number": 97,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add( final int i ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "checkPositiveOrZero",
        "RangeUtil.checkPositiveOrZero",
        "_nbsi.add",
        "add"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    RangeUtil.checkPositiveOrZero(i, \"i\");\n    return _nbsi.add(i);\n  }",
      "line_number": 108,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains( final int i ) { return i >= 0 && _nbsi.contains(i); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "contains",
        "_nbsi.contains"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 117,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove  ( final int i ) { return i >= 0 && _nbsi.remove(i); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "remove",
        "_nbsi.remove"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "advance",
      "signature": "private void advance() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "_nbsi2.contains"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 8,
      "source_code": "      while( true ) {\n        _idx++;                 // Next index\n        while( (_idx>>6) >= _nbsi2._bits.length ) { // Index out of range?\n          if( _nbsi2._new == null ) { // New table?\n            _idx = -2;          // No, so must be all done\n            return;             //\n          }\n          _nbsi2 = _nbsi2._new; // Carry on, in the new table\n        }\n        if( _nbsi2.contains(_idx) ) return;\n      }\n    }",
      "line_number": 156,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "writeObject",
      "signature": "private void writeObject(java.io.ObjectOutputStream s) throws IOException  {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "contains",
        "s.writeInt",
        "s.defaultWriteObject",
        "writeInt",
        "s.writeBoolean",
        "_nbsi.contains",
        "defaultWriteObject",
        "writeBoolean"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 1,
      "source_code": "    s.defaultWriteObject();     // Nothing to write\n    final NBSI nbsi = _nbsi;    // The One Field is transient\n    final int len = _nbsi._bits.length<<6;\n    s.writeInt(len);            // Write max element\n    for( int i=0; i<len; i++ )\n      s.writeBoolean( _nbsi.contains(i) );\n  }",
      "line_number": 184,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "readObject",
      "signature": "private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException  {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "s.defaultReadObject",
        "readBoolean",
        "add",
        "s.readBoolean",
        "ConcurrentAutoTable",
        "s.readInt",
        "defaultReadObject",
        "readInt",
        "NBSI",
        "_nbsi.add"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "    s.defaultReadObject();      // Read nothing\n    final int len = s.readInt(); // Read max element\n    _nbsi = new NBSI(len, new ConcurrentAutoTable(), this);\n    for( int i=0; i<len; i++ )  // Read all bits\n      if( s.readBoolean() )\n        _nbsi.add(i);\n  }",
      "line_number": 195,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "rawIndex",
      "signature": "private static long rawIndex(final long[] ary, final int idx) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "      assert idx >= 0 && idx < ary.length;\n      return _Lbase + (idx * (long)_Lscale);\n    }",
      "line_number": 217,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "CAS",
      "signature": "private final boolean CAS( int idx, long old, long nnn ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "      return UNSAFE.compareAndSwapLong( _bits, rawIndex(_bits, idx), old, nnn );\n    }",
      "line_number": 221,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "CAS_new",
      "signature": "private final boolean CAS_new( NBSI nnn ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "      return UNSAFE.compareAndSwapObject(this, _new_offset, null, nnn );\n    }",
      "line_number": 231,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "mask",
      "signature": "private static final long mask( int i ) { return 1L<<(i&63); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 239,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "NBSI",
      "signature": "private NBSI( int max_elem, ConcurrentAutoTable ctr, NonBlockingSetInt nonb ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "AtomicInteger"
      ],
      "dependencies": [
        "NBSI",
        "AtomicInteger"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "      super();\n      _non_blocking_set_int = nonb;\n      _size = ctr;\n      _copyIdx  = ctr == null ? null : new AtomicInteger();\n      _copyDone = ctr == null ? null : new AtomicInteger();\n      // The main array of bits\n      _bits = new long[(int)(((long)max_elem+63)>>>6)];\n      // Every 64th bit is moved off to it's own subarray, so that the\n      // sign-bit is free for other purposes\n      _nbsi64 = ((max_elem+1)>>>6) == 0 ? null : new NBSI((max_elem+1)>>>6, null, null);\n      _sum_bits_length = _bits.length + (_nbsi64==null ? 0 : _nbsi64._sum_bits_length);\n    }",
      "line_number": 250,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add( final int i ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "CAS",
        "add",
        "_size.add",
        "help_copy",
        "nbsi.CAS"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "      // Check for out-of-range for the current size bit vector.\n      // If so we need to grow the bit vector.\n      if( (i>>6) >= _bits.length )\n        return install_larger_new_bits(i). // Install larger pile-o-bits (duh)\n          help_copy().add(i);              // Finally, add to the new table\n\n      // Handle every 64th bit via using a nested array\n      NBSI nbsi = this;         // The bit array being added into\n      int j = i;                // The bit index being added\n      while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n        nbsi = nbsi._nbsi64;    // Recurse\n        j = j>>6;               // Strip off low 6 bits (all set)\n      }\n\n      final long mask = mask(j);\n      long old;\n      do {\n        old = nbsi._bits[j>>6]; // Read old bits\n        if( old < 0 )           // Not mutable?\n          // Not mutable: finish copy of word, and retry on copied word\n          return help_copy_impl(i).help_copy().add(i);\n        if( (old & mask) != 0 ) return false; // Bit is already set?\n      } while( !nbsi.CAS( j>>6, old, old | mask ) );\n      _size.add(1);\n      return true;\n    }",
      "line_number": 266,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove( final int i ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "CAS",
        "add",
        "remove",
        "_size.add",
        "help_copy",
        "nbsi.CAS"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "      if( (i>>6) >= _bits.length ) // Out of bounds?  Not in this array!\n        return _new != null && help_copy().remove(i);\n\n      // Handle every 64th bit via using a nested array\n      NBSI nbsi = this;         // The bit array being added into\n      int j = i;                // The bit index being added\n      while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n        nbsi = nbsi._nbsi64;    // Recurse\n        j = j>>6;               // Strip off low 6 bits (all set)\n      }\n\n      final long mask = mask(j);\n      long old;\n      do {\n        old = nbsi._bits[j>>6]; // Read old bits\n        if( old < 0 )           // Not mutable?\n          // Not mutable: finish copy of word, and retry on copied word\n          return help_copy_impl(i).help_copy().remove(i);\n        if( (old & mask) == 0 ) return false; // Bit is already clear?\n      } while( !nbsi.CAS( j>>6, old, old & ~mask ) );\n      _size.add(-1);\n      return true;\n    }",
      "line_number": 294,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains( final int i ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "contains",
        "help_copy"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "      if( (i>>6) >= _bits.length ) // Out of bounds?  Not in this array!\n        return _new != null && help_copy().contains(i);\n\n      // Handle every 64th bit via using a nested array\n      NBSI nbsi = this;         // The bit array being added into\n      int j = i;                // The bit index being added\n      while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n        nbsi = nbsi._nbsi64;    // Recurse\n        j = j>>6;               // Strip off low 6 bits (all set)\n      }\n\n      final long mask = mask(j);\n      long old = nbsi._bits[j>>6]; // Read old bits\n      if( old < 0 )             // Not mutable?\n        // Not mutable: finish copy of word, and retry on copied word\n        return help_copy_impl(i).help_copy().contains(i);\n      // Yes mutable: test & return bit\n      return (old & mask) != 0;\n    }",
      "line_number": 319,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() { return (int)_size.get(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "_size.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 340,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "install_larger_new_bits",
      "signature": "private NBSI install_larger_new_bits( final int i ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread",
        "final"
      ],
      "dependencies": [
        "NBSI"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "      if( _new == null ) {\n        // Grow by powers of 2, to avoid minor grow-by-1's.\n        // Note: must grow by exact powers-of-2 or the by-64-bit trick doesn't work right\n        int sz = (_bits.length<<6)<<1;\n        // CAS to install a new larger size.  Did it work?  Did it fail?  We\n        // don't know and don't care.  Only One can be installed, so if\n        // another thread installed a too-small size, we can't help it - we\n        // must simply install our new larger size as a nested-resize table.\n        CAS_new(new NBSI(sz, _size, _non_blocking_set_int));\n      }\n      // Return self for 'fluid' programming style\n      return this;\n    }",
      "line_number": 343,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "help_copy",
      "signature": "private NBSI help_copy() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Lock",
        "final",
        "getAndAdd",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "top_nbsi.help_copy_impl",
        "println",
        "_copyIdx.getAndAdd",
        "_copyDone.get",
        "_non_blocking_set_int.CAS_nbsi",
        "CAS_nbsi",
        "get",
        "getAndAdd",
        "help_copy_impl"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "      // Pick some words to help with - but only help copy the top-level NBSI.\n      // Nested NBSI waits until the top is done before we start helping.\n      NBSI top_nbsi = _non_blocking_set_int._nbsi;\n      final int HELP = 8;       // Tuning number: how much copy pain are we willing to inflict?\n      // We \"help\" by forcing individual bit indices to copy.  However, bits\n      // come in lumps of 64 per word, so we just advance the bit counter by 64's.\n      int idx = top_nbsi._copyIdx.getAndAdd(64*HELP);\n      for( int i=0; i<HELP; i++ ) {\n        int j = idx+i*64;\n        j %= (top_nbsi._bits.length<<6); // Limit, wrap to array size; means we retry indices\n        top_nbsi.help_copy_impl(j   );\n        top_nbsi.help_copy_impl(j+63); // Also force the nested-by-64 bit\n      }\n\n      // Top level guy ready to promote?\n      // Note: WE may not be the top-level guy!\n      if( top_nbsi._copyDone.get() == top_nbsi._sum_bits_length )\n        // One shot CAS to promote - it may fail since we are racing; others\n        // may promote as well\n        if( _non_blocking_set_int.CAS_nbsi( top_nbsi, top_nbsi._new ) ) {\n          //System.out.println(\"Promote at top level to size \"+(_non_blocking_set_int._nbsi._bits.length<<6));\n        }\n\n      // Return the new bitvector for 'fluid' programming style\n      return _new;\n    }",
      "line_number": 360,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "help_copy_impl",
      "signature": "private NBSI help_copy_impl( int i ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [
        "addAndGet",
        "Immutable"
      ],
      "dependencies": [
        "CAS",
        "nnn.CAS",
        "_copyDone.addAndGet",
        "old.CAS",
        "addAndGet",
        "if"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "      // Handle every 64th bit via using a nested array\n      NBSI old = this;          // The bit array being copied from\n      NBSI nnn = _new;          // The bit array being copied to\n      if( nnn == null ) return this; // Promoted already\n      int j = i;                // The bit index being added\n      while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n        old = old._nbsi64;      // Recurse\n        nnn = nnn._nbsi64;      // Recurse\n        j = j>>6;               // Strip off low 6 bits (all set)\n      }\n\n      // Transit from state 1: word is not immutable yet\n      // Immutable is in bit 63, the sign bit.\n      long bits = old._bits[j>>6];\n      while( bits >= 0 ) {      // Still in state (1)?\n        long oldbits = bits;\n        bits |= mask(63);       // Target state of bits: sign-bit means immutable\n        if( old.CAS( j>>6, oldbits, bits ) ) {\n          if( oldbits == 0 ) _copyDone.addAndGet(1);\n          break;                // Success - old array word is now immutable\n        }\n        bits = old._bits[j>>6]; // Retry if CAS failed\n      }\n\n      // Transit from state 2: non-zero in old and zero in new\n      if( bits != mask(63) ) {  // Non-zero in old?\n        long new_bits = nnn._bits[j>>6];\n        if( new_bits == 0 ) {   // New array is still zero\n          new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n          // One-shot CAS attempt, no loop, from 0 to non-zero.\n          // If it fails, somebody else did the copy for us\n          if( !nnn.CAS( j>>6, 0, new_bits ) )\n            new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n          assert new_bits != 0;\n        }\n\n        // Transit from state 3: non-zero in old and non-zero in new\n        // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n        if( old.CAS( j>>6, bits, mask(63) ) )\n          _copyDone.addAndGet(1); // One more word finished copying\n      }\n\n      // Now in state 4: zero (and immutable) in o",
      "line_number": 395,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "private void print(int d) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.print",
        "buf.toString",
        "out.println",
        "println",
        "print",
        "_copyDone.get",
        "_copyIdx.get",
        "Long.toHexString",
        "toHexString",
        "get",
        "buf.append",
        "StringBuilder",
        "_new.print",
        "append",
        "toString"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "      StringBuilder buf = new StringBuilder();\n      buf.append(\"NBSI - _bits.len=\");\n      NBSI x = this;\n      while( x != null ) {\n        buf.append(\" \"+x._bits.length);\n        x = x._nbsi64;\n      }\n      print(d,buf.toString());\n\n      x = this;\n      while( x != null ) {\n        for( int i=0; i<x._bits.length; i++ )\n          System.out.print(Long.toHexString(x._bits[i])+\" \");\n        x = x._nbsi64;\n        System.out.println();\n      }\n\n      if( _copyIdx.get() != 0 || _copyDone.get() != 0 )\n        print(d,\"_copyIdx=\"+_copyIdx.get()+\" _copyDone=\"+_copyDone.get()+\" _words_to_cpy=\"+_sum_bits_length);\n      if( _new != null ) {\n        print(d,\"__has_new - \");\n        _new.print(d+1);\n      }\n    }",
      "line_number": 450,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "NonBlockingSetInt",
      "method_type": "method"
    },
    {
      "name": "rawIndex",
      "signature": "private static long rawIndex(final Object[] ary, final int idx) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    assert idx >= 0 && idx < ary.length;\n    return _Obase + (idx * (long)_Oscale);\n  }",
      "line_number": 99,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_kvs",
      "signature": "private final boolean CAS_kvs( final Object[] oldkvs, final Object[] newkvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject(this, _kvs_offset, oldkvs, newkvs );\n  }",
      "line_number": 107,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "unbox",
      "signature": "static Object unbox( Object V ) { return V instanceof Prime ? ((Prime)V)._V : V; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 115,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "hash",
      "signature": "private static final int hash(final Object key) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "identityHashCode",
        "NullPointerException",
        "System.identityHashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 1,
      "source_code": "    if (key == null) throw new NullPointerException();\n    int h = System.identityHashCode(key); // The real hashCode call\n    // I assume that System.identityHashCode is well implemented with a good\n    // spreader, and a second bit-spreader is redundant.\n    return h;\n  }",
      "line_number": 120,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "chm",
      "signature": "private static final CHM   chm   (Object[] kvs) { return (CHM  )kvs[0]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 140,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "hashes",
      "signature": "private static final int[] hashes(Object[] kvs) { return (int[])kvs[1]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "len",
      "signature": "private static final int len(Object[] kvs) { return (kvs.length-2)>>1; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 143,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "key",
      "signature": "private static final Object key(Object[] kvs,int idx) { return kvs[(idx<<1)+2]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 177,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "val",
      "signature": "private static final Object val(Object[] kvs,int idx) { return kvs[(idx<<1)+3]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 178,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_key",
      "signature": "private static final boolean CAS_key( Object[] kvs, int idx, Object old, Object key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject( kvs, rawIndex(kvs,(idx<<1)+2), old, key );\n  }",
      "line_number": 179,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_val",
      "signature": "private static final boolean CAS_val( Object[] kvs, int idx, Object old, Object val ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject( kvs, rawIndex(kvs,(idx<<1)+3), old, val );\n  }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "public final void print() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    System.out.println(\"=========\");\n    print2(_kvs);\n    System.out.println(\"=========\");\n  }",
      "line_number": 189,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "private final void print( Object[] kvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "println",
        "Prime.unbox",
        "U.toString",
        "K.toString",
        "unbox",
        "toString"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "    for( int i=0; i<len(kvs); i++ ) {\n      Object K = key(kvs,i);\n      if( K != null ) {\n        String KS = (K == TOMBSTONE) ? \"XXX\" : K.toString();\n        Object V = val(kvs,i);\n        Object U = Prime.unbox(V);\n        String p = (V==U) ? \"\" : \"prime_\";\n        String US = (U == TOMBSTONE) ? \"tombstone\" : U.toString();\n        System.out.println(\"\"+i+\" (\"+KS+\",\"+p+US+\")\");\n      }\n    }\n    Object[] newkvs = chm(kvs)._newkvs; // New table, if any\n    if( newkvs != null ) {\n      System.out.println(\"----\");\n      print(newkvs);\n    }\n  }",
      "line_number": 195,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print2",
      "signature": "private final void print2( Object[] kvs) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "println",
        "unbox",
        "Prime.unbox"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "    for( int i=0; i<len(kvs); i++ ) {\n      Object key = key(kvs,i);\n      Object val = val(kvs,i);\n      Object U = Prime.unbox(val);\n      if( key != null && key != TOMBSTONE &&  // key is sane\n          val != null && U   != TOMBSTONE ) { // val is sane\n        String p = (val==U) ? \"\" : \"prime_\";\n        System.out.println(\"\"+i+\" (\"+key+\",\"+p+val+\")\");\n      }\n    }\n    Object[] newkvs = chm(kvs)._newkvs; // New table, if any\n    if( newkvs != null ) {\n      System.out.println(\"----\");\n      print2(newkvs);\n    }\n  }",
      "line_number": 214,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "reprobes",
      "signature": "public long reprobes() { long r = _reprobes.get(); _reprobes = new ConcurrentAutoTable(); return r; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "_reprobes.get",
        "get",
        "ConcurrentAutoTable"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 239,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "reprobe_limit",
      "signature": "private static final int reprobe_limit( int len ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    return REPROBE_LIMIT + (len>>2);\n  }",
      "line_number": 247,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingIdentityHashMap",
      "signature": "public NonBlockingIdentityHashMap( ) { this(MIN_SIZE); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 256,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingIdentityHashMap",
      "signature": "public NonBlockingIdentityHashMap( final int initial_sz ) { initialize(initial_sz); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 263,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "initialize",
      "signature": "private final void initialize( int initial_sz ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "RangeUtil.checkPositiveOrZero",
        "System.currentTimeMillis",
        "ConcurrentAutoTable",
        "CHM",
        "checkPositiveOrZero",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 7,
      "source_code": "    RangeUtil.checkPositiveOrZero(initial_sz, \"initial_sz\");\n    int i;                      // Convert to next largest power-of-2\n    if( initial_sz > 1024*1024 ) initial_sz = 1024*1024;\n    for( i=MIN_SIZE_LOG; (1<<i) < (initial_sz<<2); i++ ) ;\n    // Double size for K,V pairs, add 1 for CHM and 1 for hashes\n    _kvs = new Object[((1<<i)<<1)+2];\n    _kvs[0] = new CHM(new ConcurrentAutoTable()); // CHM in slot 0\n    _kvs[1] = new int[1<<i];          // Matching hash entries\n    _last_resize_milli = System.currentTimeMillis();\n  }",
      "line_number": 264,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "initialize",
      "signature": "protected final void initialize() { initialize(MIN_SIZE); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 276,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "containsKey",
      "signature": "public boolean containsKey( Object key )            { return get(key) != null; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 293,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public TypeV   put        ( TypeK  key, TypeV val ) { return putIfMatch( key,      val, NO_MATCH_OLD); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 315,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfAbsent",
      "signature": "public TypeV   putIfAbsent( TypeK  key, TypeV val ) { return putIfMatch( key,      val, TOMBSTONE   ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 324,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public TypeV   remove     ( Object key )            { return putIfMatch( key,TOMBSTONE, NO_MATCH_OLD); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 332,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove     ( Object key,Object val ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "    return objectsEquals(putIfMatch( key,TOMBSTONE, val ), val);\n  }",
      "line_number": 337,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "replace",
      "signature": "public TypeV   replace    ( TypeK  key, TypeV val ) { return putIfMatch( key,      val,MATCH_ANY   ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 345,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "replace",
      "signature": "public boolean replace    ( TypeK  key, TypeV  oldValue, TypeV newValue ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "    return objectsEquals(putIfMatch( key, newValue, oldValue ), oldValue);\n  }",
      "line_number": 351,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "objectsEquals",
      "signature": "private static boolean objectsEquals(Object a, Object b) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "a.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "    return (a == b) || (a != null && a.equals(b));\n  }",
      "line_number": 354,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfMatch",
      "signature": "private final TypeV putIfMatch( Object key, Object newVal, Object oldVal ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "    if (oldVal == null || newVal == null) throw new NullPointerException();\n    final Object res = putIfMatch0( this, _kvs, key, newVal, oldVal );\n    assert !(res instanceof Prime);\n    assert res != null;\n    return res == TOMBSTONE ? null : (TypeV)res;\n  }",
      "line_number": 358,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putAll",
      "signature": "public void putAll(Map<? extends TypeK, ? extends TypeV> m) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "entrySet",
        "getKey",
        "e.getKey",
        "e.getValue",
        "m.entrySet",
        "getValue"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "    for (Map.Entry<? extends TypeK, ? extends TypeV> e : m.entrySet())\n      put(e.getKey(), e.getValue());\n  }",
      "line_number": 371,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void clear() {         // Smack a new empty table down",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "NonBlockingIdentityHashMap"
      ],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "    Object[] newkvs = new NonBlockingIdentityHashMap(MIN_SIZE)._kvs;\n    while( !CAS_kvs(_kvs,newkvs) ) // Spin until the clear works\n      ;\n  }",
      "line_number": 378,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "containsValue",
      "signature": "public boolean containsValue( final Object val ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "V.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "    if( val == null ) throw new NullPointerException();\n    for( TypeV V : values() )\n      if( V == val || V.equals(val) )\n        return true;\n    return false;\n  }",
      "line_number": 391,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clone",
      "signature": "public Object clone() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "t.put",
        "put",
        "TypeK",
        "InternalError",
        "super.clone",
        "clear",
        "t.clear",
        "clone"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "    try {\n      // Must clone, to get the class right; NBHM might have been\n      // extended so it would be wrong to just make a new NBHM.\n      NonBlockingIdentityHashMap<TypeK,TypeV> t = (NonBlockingIdentityHashMap<TypeK,TypeV>) super.clone();\n      // But I don't have an atomic clone operation - the underlying _kvs\n      // structure is undergoing rapid change.  If I just clone the _kvs\n      // field, the CHM in _kvs[0] won't be in sync.\n      //\n      // Wipe out the cloned array (it was shallow anyways).\n      t.clear();\n      // Now copy sanely\n      for( TypeK K : keySet() ) {\n        final TypeV V = get(K);  // Do an official 'get'\n        t.put(K,V);\n      }\n      return t;\n    } catch (CloneNotSupportedException e) {\n      // this shouldn't happen, since we are Cloneable\n      throw new InternalError();\n    }\n  }",
      "line_number": 413,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "i.hasNext",
        "hasNext",
        "getKey",
        "next",
        "StringBuilder",
        "TypeK",
        "e.getKey",
        "e.getValue",
        "iterator",
        "append",
        "sb.append",
        "i.next",
        "getValue",
        "toString"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "    Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n    if( !i.hasNext())\n      return \"{}\";\n\n    StringBuilder sb = new StringBuilder();\n    sb.append('{');\n    for (;;) {\n      Entry<TypeK,TypeV> e = i.next();\n      TypeK key = e.getKey();\n      TypeV value = e.getValue();\n      sb.append(key   == this ? \"(this Map)\" : key);\n      sb.append('=');\n      sb.append(value == this ? \"(this Map)\" : value);\n      if( !i.hasNext())\n        return sb.append('}').toString();\n      sb.append(\", \");\n    }\n  }",
      "line_number": 449,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public TypeV get( Object key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    final Object V = get_impl(this,_kvs,key);\n    assert !(V instanceof Prime); // Never return a Prime\n    assert V != TOMBSTONE;\n    return (TypeV)V;\n  }",
      "line_number": 479,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "get_impl",
      "signature": "private static final Object get_impl( final NonBlockingIdentityHashMap topmap, final Object[] kvs, final Object key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "volatile",
        "Lock",
        "final",
        "lock"
      ],
      "dependencies": [
        "copy_slot_and_check",
        "help_copy",
        "chm.copy_slot_and_check",
        "topmap.help_copy"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 55,
      "source_code": "    final int fullhash= hash (key); // throws NullPointerException if key is null\n    final int len     = len  (kvs); // Count of key/value pairs, reads kvs.length\n    final CHM chm     = chm  (kvs); // The CHM, for a volatile read below; reads slot 0 of kvs\n\n    int idx = fullhash & (len-1); // First key hash\n\n    // Main spin/reprobe loop, looking for a Key hit\n    int reprobe_cnt=0;\n    while( true ) {\n      // Probe table.  Each read of 'val' probably misses in cache in a big\n      // table; hopefully the read of 'key' then hits in cache.\n      final Object K = key(kvs,idx); // Get key   before volatile read, could be null\n      final Object V = val(kvs,idx); // Get value before volatile read, could be null or Tombstone or Prime\n      if( K == null ) return null;   // A clear miss\n\n      // We need a volatile-read here to preserve happens-before semantics on\n      // newly inserted Keys.  If the Key body was written just before inserting\n      // into the table a Key-compare here might read the uninitialized Key body.\n      // Annoyingly this means we have to volatile-read before EACH key compare.\n      // .\n      // We also need a volatile-read between reading a newly inserted Value\n      // and returning the Value (so the user might end up reading the stale\n      // Value contents).  Same problem as with keys - and the one volatile\n      // read covers both.\n      final Object[] newkvs = chm._newkvs; // VOLATILE READ before key compare\n\n      // Key-compare\n      if( K == key ) {\n        // Key hit!  Check for no table-copy-in-progress\n        if( !(V instanceof Prime) ) // No copy?\n          return (V == TOMBSTONE) ? null : V; // Return the value\n        // Key hit - but slot is (possibly partially) copied to the new table.\n        // Finish the copy & retry in the new table.\n        return get_impl(topmap,chm.copy_slot_and_check(topmap,kvs,idx,key),key); // Retry in the new table\n      }\n      // get and put must have the same key lookup logic!  But only 'pu",
      "line_number": 486,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfMatch0",
      "signature": "private static final Object putIfMatch0(final NonBlockingIdentityHashMap topmap, final Object[] kvs, final Object key, final Object putval, final Object expVal ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "static",
        "volatile",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "_reprobes.add",
        "expVal.equals",
        "tableFull",
        "chm.resize",
        "add",
        "topmap.help_copy",
        "resize",
        "chm.copy_slot_and_check",
        "copy_slot_and_check",
        "_slots.add",
        "table",
        "chm.tableFull",
        "_size.add",
        "help_copy",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 101,
      "source_code": "    assert putval != null;\n    assert !(putval instanceof Prime);\n    assert !(expVal instanceof Prime);\n    final int fullhash = hash  (key); // throws NullPointerException if key null\n    final int len      = len   (kvs); // Count of key/value pairs, reads kvs.length\n    final CHM chm      = chm   (kvs); // Reads kvs[0]\n    int idx = fullhash & (len-1);\n\n    // ---\n    // Key-Claim stanza: spin till we can claim a Key (or force a resizing).\n    int reprobe_cnt=0;\n    Object K=null, V=null;\n    Object[] newkvs=null;\n    while( true ) {             // Spin till we get a Key slot\n      V = val(kvs,idx);         // Get old value (before volatile read below!)\n      K = key(kvs,idx);         // Get current key\n      if( K == null ) {         // Slot is free?\n        // Found an empty Key slot - which means this Key has never been in\n        // this table.  No need to put a Tombstone - the Key is not here!\n        if( putval == TOMBSTONE ) return TOMBSTONE; // Not-now & never-been in this table\n        if( expVal == MATCH_ANY ) return TOMBSTONE; // Will not match, even after K inserts\n        // Claim the null key-slot\n        if( CAS_key(kvs,idx, null, key ) ) { // Claim slot for Key\n          chm._slots.add(1);      // Raise key-slots-used count\n          break;                  // Got it!\n        }\n        // CAS to claim the key-slot failed.\n        //\n        // This re-read of the Key points out an annoying short-coming of Java\n        // CAS.  Most hardware CAS's report back the existing value - so that\n        // if you fail you have a *witness* - the value which caused the CAS to\n        // fail.  The Java API turns this into a boolean destroying the\n        // witness.  Re-reading does not recover the witness because another\n        // thread can write over the memory after the CAS.  Hence we can be in\n        // the unfortunate situation of having a CAS fail *for cause* but\n        // having that cause removed by a later store.  This turns a\n        // non-spu",
      "line_number": 539,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "help_copy",
      "signature": "private final Object[] help_copy( Object[] helper ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "help_copy_impl",
        "topchm.help_copy_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "    // Read the top-level KVS only once.  We'll try to help this copy along,\n    // even if it gets promoted out from under us (i.e., the copy completes\n    // and another KVS becomes the top-level copy).\n    Object[] topkvs = _kvs;\n    CHM topchm = chm(topkvs);\n    if( topchm._newkvs == null ) return helper; // No copy in-progress\n    topchm.help_copy_impl(this,topkvs,false);\n    return helper;\n  }",
      "line_number": 704,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size () { return (int)_size.get(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "_size.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 721,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "slots",
      "signature": "public int slots() { return (int)_slots.get(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "_slots.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 734,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_newkvs",
      "signature": "boolean CAS_newkvs( Object[] newkvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "_newkvsUpdater.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "      while( _newkvs == null )\n        if( _newkvsUpdater.compareAndSet(this,null,newkvs) )\n          return true;\n      return false;\n    }",
      "line_number": 747,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "tableFull",
      "signature": "private final boolean tableFull( int reprobe_cnt, int len ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_slots.estimate_get",
        "estimate_get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      return\n        // Do the cheap check first: we allow some number of reprobes always\n        reprobe_cnt >= REPROBE_LIMIT &&\n        // More expensive check: see if the table is > 1/4 full.\n        _slots.estimate_get() >= reprobe_limit(len);\n    }",
      "line_number": 786,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private final Object[] resize( NonBlockingIdentityHashMap topmap, Object[] kvs) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "volatile",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "notifyAll",
        "notify",
        "lock"
      ],
      "dependencies": [
        "out.print",
        "nanoTime",
        "sleep",
        "println",
        "compareAndSet",
        "print",
        "System.currentTimeMillis",
        "_resizerUpdater.compareAndSet",
        "_slots.estimate_get",
        "out.println",
        "topmap.rehash",
        "estimate_get",
        "rehash",
        "Thread.sleep",
        "CHM",
        "System.nanoTime",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "observer_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 75,
      "source_code": "      assert chm(kvs) == this;\n\n      // Check for resize already in progress, probably triggered by another thread\n      Object[] newkvs = _newkvs; // VOLATILE READ\n      if( newkvs != null )       // See if resize is already in progress\n        return newkvs;           // Use the new table already\n\n      // No copy in-progress, so start one.  First up: compute new table size.\n      int oldlen = len(kvs);    // Old count of K,V pairs allowed\n      int sz = size();          // Get current table count of active K,V pairs\n      int newsz = sz;           // First size estimate\n\n      // Heuristic to determine new size.  We expect plenty of dead-slots-with-keys\n      // and we need some decent padding to avoid endless reprobing.\n      if( sz >= (oldlen>>2) ) { // If we are >25% full of keys then...\n        newsz = oldlen<<1;      // Double size\n        if( sz >= (oldlen>>1) ) // If we are >50% full of keys then...\n          newsz = oldlen<<2;    // Double double size\n      }\n      // This heuristic in the next 2 lines leads to a much denser table\n      // with a higher reprobe rate\n      //if( sz >= (oldlen>>1) ) // If we are >50% full of keys then...\n      //  newsz = oldlen<<1;    // Double size\n\n      // Last (re)size operation was very recent?  Then double again; slows\n      // down resize operations for tables subject to a high key churn rate.\n      long tm = System.currentTimeMillis();\n      long q=0;\n      if( newsz <= oldlen && // New table would shrink or hold steady?\n          tm <= topmap._last_resize_milli+10000 && // Recent resize (less than 1 sec ago)\n          (q=_slots.estimate_get()) >= (sz<<1) ) // 1/2 of keys are dead?\n        newsz = oldlen<<1;      // Double the existing size\n\n      // Do not shrink, ever\n      if( newsz < oldlen ) newsz = oldlen;\n\n      // Convert to power-of-2\n      int log2;\n      for( log2=MIN_SIZE_LOG; (1<<log2) < newsz; log2++ ) ; // Compute log2 of size\n\n      // Now limit the number of threads actually allocating memory to a",
      "line_number": 800,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "help_copy_impl",
      "signature": "private final void help_copy_impl( NonBlockingIdentityHashMap topmap, Object[] oldkvs, boolean copy_all ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "Math.min",
        "_copyIdxUpdater.compareAndSet",
        "min",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 43,
      "source_code": "      assert chm(oldkvs) == this;\n      Object[] newkvs = _newkvs;\n      assert newkvs != null;    // Already checked by caller\n      int oldlen = len(oldkvs); // Total amount to copy\n      final int MIN_COPY_WORK = Math.min(oldlen,1024); // Limit per-thread work\n\n      // ---\n      int panic_start = -1;\n      int copyidx=-9999;            // Fool javac to think it's initialized\n      while( _copyDone < oldlen ) { // Still needing to copy?\n        // Carve out a chunk of work.  The counter wraps around so every\n        // thread eventually tries to copy every slot repeatedly.\n\n        // We \"panic\" if we have tried TWICE to copy every slot - and it still\n        // has not happened.  i.e., twice some thread somewhere claimed they\n        // would copy 'slot X' (by bumping _copyIdx) but they never claimed to\n        // have finished (by bumping _copyDone).  Our choices become limited:\n        // we can wait for the work-claimers to finish (and become a blocking\n        // algorithm) or do the copy work ourselves.  Tiny tables with huge\n        // thread counts trying to copy the table often 'panic'.\n        if( panic_start == -1 ) { // No panic?\n          copyidx = (int)_copyIdx;\n          while( copyidx < (oldlen<<1) && // 'panic' check\n                 !_copyIdxUpdater.compareAndSet(this,copyidx,copyidx+MIN_COPY_WORK) )\n            copyidx = (int)_copyIdx;      // Re-read\n          if( !(copyidx < (oldlen<<1)) )  // Panic!\n            panic_start = copyidx;        // Record where we started to panic-copy\n        }\n\n        // We now know what to copy.  Try to copy.\n        int workdone = 0;\n        for( int i=0; i<MIN_COPY_WORK; i++ )\n          if( copy_slot(topmap,(copyidx+i)&(oldlen-1),oldkvs,newkvs) ) // Made an oldtable slot go dead?\n            workdone++;         // Yes!\n        if( workdone > 0 )      // Report work-done occasionally\n          copy_check_and_promote( topmap, oldkvs, workdone );// See if we can promote\n        //for( int i=0; i<MIN_COPY_WORK;",
      "line_number": 912,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_slot_and_check",
      "signature": "private final Object[] copy_slot_and_check( NonBlockingIdentityHashMap topmap, Object[] oldkvs, int idx, Object should_help ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "help_copy",
        "topmap.help_copy"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 9,
      "source_code": "      assert chm(oldkvs) == this;\n      Object[] newkvs = _newkvs; // VOLATILE READ\n      // We're only here because the caller saw a Prime, which implies a\n      // table-copy is in progress.\n      assert newkvs != null;\n      if( copy_slot(topmap,idx,oldkvs,_newkvs) )   // Copy the desired slot\n        copy_check_and_promote(topmap, oldkvs, 1); // Record the slot copied\n      // Generically help along any copy (except if called recursively from a helper)\n      return (should_help == null) ? newkvs : topmap.help_copy(newkvs);\n    }",
      "line_number": 976,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_check_and_promote",
      "signature": "private final void copy_check_and_promote( NonBlockingIdentityHashMap topmap, Object[] oldkvs, int workdone ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "CAS_kvs",
        "compareAndSet",
        "System.currentTimeMillis",
        "topmap.CAS_kvs",
        "_copyDoneUpdater.compareAndSet",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "      assert chm(oldkvs) == this;\n      int oldlen = len(oldkvs);\n      // We made a slot unusable and so did some of the needed copy work\n      long copyDone = _copyDone;\n      assert (copyDone+workdone) <= oldlen;\n      if( workdone > 0 ) {\n        while( !_copyDoneUpdater.compareAndSet(this,copyDone,copyDone+workdone) ) {\n          copyDone = _copyDone; // Reload, retry\n          assert (copyDone+workdone) <= oldlen;\n        }\n      }\n\n      // Check for copy being ALL done, and promote.  Note that we might have\n      // nested in-progress copies and manage to finish a nested copy before\n      // finishing the top-level copy.  We only promote top-level copies.\n      if( copyDone+workdone == oldlen && // Ready to promote this table?\n          topmap._kvs == oldkvs &&       // Looking at the top-level table?\n          // Attempt to promote\n          topmap.CAS_kvs(oldkvs,_newkvs) ) {\n        topmap._last_resize_milli = System.currentTimeMillis(); // Record resize time for next check\n      }\n    }",
      "line_number": 989,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_slot",
      "signature": "private boolean copy_slot( NonBlockingIdentityHashMap topmap, int idx, Object[] oldkvs, Object[] newkvs ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread",
        "final"
      ],
      "dependencies": [
        "Prime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 31,
      "source_code": "      // Blindly set the key slot from null to TOMBSTONE, to eagerly stop\n      // fresh put's from inserting new values in the old table when the old\n      // table is mid-resize.  We don't need to act on the results here,\n      // because our correctness stems from box'ing the Value field.  Slamming\n      // the Key field is a minor speed optimization.\n      Object key;\n      while( (key=key(oldkvs,idx)) == null )\n        CAS_key(oldkvs,idx, null, TOMBSTONE);\n\n      // ---\n      // Prevent new values from appearing in the old table.\n      // Box what we see in the old table, to prevent further updates.\n      Object oldval = val(oldkvs,idx); // Read OLD table\n      while( !(oldval instanceof Prime) ) {\n        final Prime box = (oldval == null || oldval == TOMBSTONE) ? TOMBPRIME : new Prime(oldval);\n        if( CAS_val(oldkvs,idx,oldval,box) ) { // CAS down a box'd version of oldval\n          // If we made the Value slot hold a TOMBPRIME, then we both\n          // prevented further updates here but also the (absent)\n          // oldval is vacuously available in the new table.  We\n          // return with true here: any thread looking for a value for\n          // this key can correctly go straight to the new table and\n          // skip looking in the old table.\n          if( box == TOMBPRIME )\n            return true;\n          // Otherwise we boxed something, but it still needs to be\n          // copied into the new table.\n          oldval = box;         // Record updated oldval\n          break;                // Break loop; oldval is now boxed by us\n        }\n        oldval = val(oldkvs,idx); // Else try, try again\n      }\n      if( oldval == TOMBPRIME ) return false; // Copy already complete here!\n\n      // ---\n      // Copy the value into the new table, but only if we overwrite a null.\n      // If another value is already in the new table, then somebody else\n      // wrote something there and that write is happens-after any value that\n      // appears in the old",
      "line_number": 1023,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "SnapshotV",
      "signature": "public SnapshotV() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "help_copy_impl",
        "topchm.help_copy_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "      while( true ) {           // Verify no table-copy-in-progress\n        Object[] topkvs = _kvs;\n        CHM topchm = chm(topkvs);\n        if( topchm._newkvs == null ) { // No table-copy-in-progress\n          // The \"linearization point\" for the iteration.  Every key in this\n          // table will be visited, but keys added later might be skipped or\n          // even be added to a following table (also not iterated over).\n          _sskvs = topkvs;\n          break;\n        }\n        // Table copy in-progress - so we cannot get a clean iteration.  We\n        // must help finish the table copy before we can start iterating.\n        topchm.help_copy_impl(NonBlockingIdentityHashMap.this,topkvs,true);\n      }\n      // Warm-up the iterator\n      next();\n    }",
      "line_number": 1084,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "key",
      "signature": "Object key(int idx) { return NonBlockingIdentityHashMap.key(_sskvs,idx); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "key",
        "NonBlockingIdentityHashMap.key"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public TypeV next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "NoSuchElementException",
        "_nextK"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "      // 'next' actually knows what the next value will be - it had to\n      // figure that out last go-around lest 'hasNext' report true and\n      // some other thread deleted the last value.  Instead, 'next'\n      // spends all its effort finding the key that comes after the\n      // 'next' key.\n      if( _idx != 0 && _nextV == null ) throw new NoSuchElementException();\n      _prevK = _nextK;          // This will become the previous key\n      _prevV = _nextV;          // This will become the previous value\n      _nextV = null;            // We have no more next-key\n      // Attempt to set <_nextK,_nextV> to the next K,V pair.\n      // _nextV is the trigger: stop searching when it is != null\n      while( _idx<length() ) {  // Scan array\n        _nextK = key(_idx++); // Get a key that definitely is in the set (for the moment!)\n        if( _nextK != null && // Found something?\n            _nextK != TOMBSTONE &&\n            (_nextV=get(_nextK)) != null )\n          break;                // Got it!  _nextK is a valid Key\n      }                         // Else keep scanning\n      return _prevV;            // Return current value.\n    }",
      "line_number": 1108,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "removeKey",
      "signature": "public void removeKey() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "IllegalStateException",
        "putIfMatch",
        "this.putIfMatch"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 6,
      "source_code": "      if( _prevV == null ) throw new IllegalStateException();\n      NonBlockingIdentityHashMap.this.putIfMatch(_prevK, TOMBSTONE, NO_MATCH_OLD);\n      _prevV = null;\n    }",
      "line_number": 1130,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "values",
      "signature": "public Collection<TypeV> values() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "TypeV",
        "size",
        "this.containsValue",
        "clear",
        "SnapshotV",
        "containsValue",
        "AbstractCollection",
        "this.clear",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 15,
      "source_code": "    return new AbstractCollection<TypeV>() {\n      @Override public void    clear   (          ) {        NonBlockingIdentityHashMap.this.clear        ( ); }\n      @Override public int     size    (          ) { return NonBlockingIdentityHashMap.this.size         ( ); }\n      @Override public boolean contains( Object v ) { return NonBlockingIdentityHashMap.this.containsValue(v); }\n      @Override public Iterator<TypeV> iterator()   { return new SnapshotV(); }\n    };\n  }",
      "line_number": 1167,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "@Override public void    clear   (          ) {        NonBlockingIdentityHashMap.this.clear        ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1169,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "@Override public int     size    (          ) { return NonBlockingIdentityHashMap.this.size         ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1170,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "@Override public boolean contains( Object v ) { return NonBlockingIdentityHashMap.this.containsValue(v); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "containsValue",
        "this.containsValue"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1171,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "keySet",
      "signature": "public Set<TypeK> keySet() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "TypeK",
        "clear",
        "containsKey",
        "this.remove",
        "AbstractSet",
        "this.containsKey",
        "SnapshotK",
        "remove",
        "this.clear",
        "this.size"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "    return new AbstractSet<TypeK> () {\n      @Override public void    clear   (          ) {        NonBlockingIdentityHashMap.this.clear   ( ); }\n      @Override public int     size    (          ) { return NonBlockingIdentityHashMap.this.size    ( ); }\n      @Override public boolean contains( Object k ) { return NonBlockingIdentityHashMap.this.containsKey(k); }\n      @Override public boolean remove  ( Object k ) { return NonBlockingIdentityHashMap.this.remove  (k) != null; }\n      @Override public Iterator<TypeK> iterator()   { return new SnapshotK(); }\n    };\n  }",
      "line_number": 1206,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "@Override public void    clear   (          ) {        NonBlockingIdentityHashMap.this.clear   ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1208,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "@Override public int     size    (          ) { return NonBlockingIdentityHashMap.this.size    ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1209,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "@Override public boolean contains( Object k ) { return NonBlockingIdentityHashMap.this.containsKey(k); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "this.containsKey",
        "containsKey"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1210,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "@Override public boolean remove  ( Object k ) { return NonBlockingIdentityHashMap.this.remove  (k) != null; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "remove",
        "this.remove"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1211,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "setValue",
      "signature": "public TypeV setValue(final TypeV val) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      if( val == null ) throw new NullPointerException();\n      _val = val;\n      return put(_key, val);\n    }",
      "line_number": 1221,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "@Override public void    clear   (          ) {        NonBlockingIdentityHashMap.this.clear( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1264,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "@Override public int     size    (          ) { return NonBlockingIdentityHashMap.this.size ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1265,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "@Override public boolean remove( final Object o ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "getKey",
        "e.getKey",
        "e.getValue",
        "this.remove",
        "getValue",
        "remove"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if( !(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        return NonBlockingIdentityHashMap.this.remove(e.getKey(), e.getValue());\n      }",
      "line_number": 1266,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "@Override public boolean contains(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getKey",
        "v.equals",
        "e.getKey",
        "e.getValue",
        "getValue",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if( !(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        TypeV v = get(e.getKey());\n        return v != null && v.equals(e.getValue());\n      }",
      "line_number": 1271,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "writeObject",
      "signature": "private void writeObject(java.io.ObjectOutputStream s) throws IOException  {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "s.defaultWriteObject",
        "TypeK",
        "writeObject",
        "s.writeObject",
        "defaultWriteObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "    s.defaultWriteObject();     // Nothing to write\n    for( Object K : keySet() ) {\n      final Object V = get(K);  // Do an official 'get'\n      s.writeObject(K);         // Write the <TypeK,TypeV> pair\n      s.writeObject(V);\n    }\n    s.writeObject(null);        // Sentinel to indicate end-of-data\n    s.writeObject(null);\n  }",
      "line_number": 1283,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "readObject",
      "signature": "private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "defaultReadObject",
        "s.readObject",
        "s.defaultReadObject",
        "readObject"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "    s.defaultReadObject();      // Read nothing\n    initialize(MIN_SIZE);\n    for(;;) {\n      final TypeK K = (TypeK) s.readObject();\n      final TypeV V = (TypeV) s.readObject();\n      if( K == null ) break;\n      put(K,V);                 // Insert with an offical put\n    }\n  }",
      "line_number": 1296,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "rawIndex",
      "signature": "private static long rawIndex(final Object[] ary, final int idx) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    assert idx >= 0 && idx < ary.length;\n    // Note the long-math requirement, to handle arrays of more than 2^31 bytes\n    // - or 2^28 - or about 268M - 8-byte pointer elements.\n    return _Obase + ((long)idx * _Oscale);\n  }",
      "line_number": 103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "rawIndex",
      "signature": "private static long rawIndex(final long[] ary, final int idx) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    assert idx >= 0 && idx < ary.length;\n    // Note the long-math requirement, to handle arrays of more than 2^31 bytes\n    // - or 2^28 - or about 268M - 8-byte pointer elements.\n    return _Lbase + ((long)idx * _Lscale);\n  }",
      "line_number": 111,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS",
      "signature": "private final boolean CAS( final long offset, final Object old, final Object nnn ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    return UNSAFE.compareAndSwapObject(this, offset, old, nnn );\n  }",
      "line_number": 122,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "unbox",
      "signature": "static Object unbox( Object V ) { return V instanceof Prime ? ((Prime)V)._V : V; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 130,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "public final void print() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "print",
        "println",
        "_chm.print"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    System.out.println(\"=========\");\n    print_impl(-99,NO_KEY,_val_1);\n    _chm.print();\n    System.out.println(\"=========\");\n  }",
      "line_number": 174,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print_impl",
      "signature": "private static void print_impl(final int i, final long K, final Object V) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "out.println",
        "println",
        "V2.toString",
        "Prime.unbox",
        "unbox",
        "toString"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    String p = (V instanceof Prime) ? \"prime_\" : \"\";\n    Object V2 = Prime.unbox(V);\n    String VS = (V2 == TOMBSTONE) ? \"tombstone\" : V2.toString();\n    System.out.println(\"[\"+i+\"]=(\"+K+\",\"+p+VS+\")\");\n  }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print2_impl",
      "signature": "private static void print2_impl(final int i, final long K, final Object V) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "unbox",
        "Prime.unbox"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 1,
      "source_code": "    if( V != null && Prime.unbox(V) != TOMBSTONE )\n      print_impl(i,K,V);\n  }",
      "line_number": 193,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "reprobes",
      "signature": "public long reprobes() { long r = _reprobes.get(); _reprobes = new ConcurrentAutoTable(); return r; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "_reprobes.get",
        "get",
        "ConcurrentAutoTable"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 205,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "reprobe_limit",
      "signature": "private static int reprobe_limit( int len ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "    return REPROBE_LIMIT + (len>>4);\n  }",
      "line_number": 213,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingHashMapLong",
      "signature": "public NonBlockingHashMapLong( ) { this(MIN_SIZE,true); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 222,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingHashMapLong",
      "signature": "public NonBlockingHashMapLong( final int initial_sz ) { this(initial_sz,true); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 229,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingHashMapLong",
      "signature": "public NonBlockingHashMapLong( final boolean opt_for_space ) { this(1,opt_for_space); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "",
      "line_number": 235,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingHashMapLong",
      "signature": "public NonBlockingHashMapLong( final int initial_sz, final boolean opt_for_space ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 7,
      "source_code": "    _opt_for_space = opt_for_space;\n    initialize(initial_sz);\n  }",
      "line_number": 241,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "initialize",
      "signature": "private void initialize( final int initial_sz ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "RangeUtil.checkPositiveOrZero",
        "System.currentTimeMillis",
        "ConcurrentAutoTable",
        "CHM",
        "checkPositiveOrZero",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "    RangeUtil.checkPositiveOrZero(initial_sz, \"initial_sz\");\n    int i;                      // Convert to next largest power-of-2\n    for( i=MIN_SIZE_LOG; (1<<i) < initial_sz; i++ ) {/*empty*/}\n    _chm = new CHM(this,new ConcurrentAutoTable(),i);\n    _val_1 = TOMBSTONE;         // Always as-if deleted\n    _last_resize_milli = System.currentTimeMillis();\n  }",
      "line_number": 245,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "containsKey",
      "signature": "public boolean containsKey( long key )            { return get(key) != null; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 261,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public TypeV   put        ( long key, TypeV val ) { return putIfMatch( key,      val,NO_MATCH_OLD);}",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 281,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfAbsent",
      "signature": "public TypeV   putIfAbsent( long key, TypeV val ) { return putIfMatch( key,      val,TOMBSTONE   );}",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 289,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public TypeV   remove     ( long key )            { return putIfMatch( key,TOMBSTONE,NO_MATCH_OLD);}",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 295,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove     ( long key,Object val ) { return putIfMatch( key,TOMBSTONE,val ) == val ;}",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 300,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "replace",
      "signature": "public TypeV   replace    ( long key, TypeV val ) { return putIfMatch( key,      val,MATCH_ANY   );}",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 305,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "replace",
      "signature": "public boolean replace    ( long key, TypeV  oldValue, TypeV newValue ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "    return putIfMatch( key, newValue, oldValue ) == oldValue;\n  }",
      "line_number": 310,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfMatch",
      "signature": "private TypeV putIfMatch( long key, Object newVal, Object oldVal ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "putIfMatch",
        "_chm.putIfMatch",
        "oldVal.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "    if (oldVal == null || newVal == null)  throw new NullPointerException();\n    if( key == NO_KEY ) {\n      Object curVal = _val_1;\n      if( oldVal == NO_MATCH_OLD || // Do we care about expected-Value at all?\n          curVal == oldVal ||       // No instant match already?\n          (oldVal == MATCH_ANY && curVal != TOMBSTONE) ||\n          oldVal.equals(curVal) ) { // Expensive equals check\n        if( !CAS(_val_1_offset,curVal,newVal) ) // One shot CAS update attempt\n          curVal = _val_1;                      // Failed; get failing witness\n      }\n      return curVal == TOMBSTONE ? null : (TypeV)curVal; // Return the last value present\n    }\n    final Object res = _chm.putIfMatch( key, newVal, oldVal );\n    assert !(res instanceof Prime);\n    assert res != null;\n    return res == TOMBSTONE ? null : (TypeV)res;\n  }",
      "line_number": 315,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void clear() {         // Smack a new empty table down",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CHM",
        "ConcurrentAutoTable"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "    CHM newchm = new CHM(this,new ConcurrentAutoTable(),MIN_SIZE_LOG);\n    while( !CAS(_chm_offset,_chm,newchm) ) { /*Spin until the clear works*/}\n    CAS(_val_1_offset,_val_1,TOMBSTONE);\n  }",
      "line_number": 335,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void clear(boolean large) {         // Smack a new empty table down",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "_chm.clear",
        "clear"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "    _chm.clear();\n    CAS(_val_1_offset,_val_1,TOMBSTONE);\n  }",
      "line_number": 341,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "containsValue",
      "signature": "public boolean containsValue( Object val ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "V.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 4,
      "source_code": "    if( val == null ) return false;\n    if( val == _val_1 ) return true; // Key 0\n    for( TypeV V : values() )\n      if( V == val || V.equals(val) )\n        return true;\n    return false;\n  }",
      "line_number": 352,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public final TypeV get( long key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_chm.get_impl",
        "get_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "    if( key == NO_KEY ) {\n      final Object V = _val_1;\n      return V == TOMBSTONE ? null : (TypeV)V;\n    }\n    final Object V = _chm.get_impl(key);\n    assert !(V instanceof Prime); // Never return a Prime\n    assert V != TOMBSTONE;\n    return (TypeV)V;\n  }",
      "line_number": 371,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public TypeV   get    ( Object key              ) { return (key instanceof Long) ? get    (((Long)key).longValue()) : null;  }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longValue"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 383,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public TypeV   remove ( Object key              ) { return (key instanceof Long) ? remove (((Long)key).longValue()) : null;  }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longValue"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 385,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove ( Object key, Object Val  ) { return (key instanceof Long) && remove(((Long) key).longValue(), Val);  }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longValue"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 387,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "containsKey",
      "signature": "public boolean containsKey( Object key          ) { return (key instanceof Long) && containsKey(((Long) key).longValue()); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longValue"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 389,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfAbsent",
      "signature": "public TypeV   putIfAbsent( Long key, TypeV val ) { return putIfAbsent( key.longValue(), val ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longValue",
        "key.longValue"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 2,
      "source_code": "",
      "line_number": 391,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public TypeV   put    ( Long key, TypeV val     ) { return put(key.longValue(),val); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longValue",
        "key.longValue"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 395,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "help_copy",
      "signature": "private void help_copy( ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "help_copy_impl",
        "topchm.help_copy_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "    // Read the top-level CHM only once.  We'll try to help this copy along,\n    // even if it gets promoted out from under us (i.e., the copy completes\n    // and another KVS becomes the top-level copy).\n    CHM topchm = _chm;\n    if( topchm._newchm == null ) return; // No copy in-progress\n    topchm.help_copy_impl(false);\n  }",
      "line_number": 406,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "hash",
      "signature": "private static final int hash(long h) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "    h ^= (h>>>20) ^ (h>>>12);\n    h ^= (h>>> 7) ^ (h>>> 4);\n    h += h<<7; // smear low bits up high, for hashcodes that only differ by 1\n    return (int)h;\n  }",
      "line_number": 419,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size () { return (int)_size.get(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "_size.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 435,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "slots",
      "signature": "public int slots() { return (int)_slots.get(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "_slots.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 448,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "CAS_newchm",
      "signature": "boolean CAS_newchm( CHM newchm ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "_newchmUpdater.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "      return _newchmUpdater.compareAndSet(this,null,newchm);\n    }",
      "line_number": 461,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "private void print() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "print",
        "println",
        "newchm.print"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 5,
      "source_code": "      for( int i=0; i<_keys.length; i++ ) {\n        long K = _keys[i];\n        if( K != NO_KEY )\n          print_impl(i,K,_vals[i]);\n      }\n      CHM newchm = _newchm;     // New table, if any\n      if( newchm != null ) {\n        System.out.println(\"----\");\n        newchm.print();\n      }\n    }",
      "line_number": 509,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "print2",
      "signature": "private void print2( ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "newchm.print2",
        "print2"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 5,
      "source_code": "      for( int i=0; i<_keys.length; i++ ) {\n        long K = _keys[i];\n        if( K != NO_KEY )       // key is sane\n          print2_impl(i,K,_vals[i]);\n      }\n      CHM newchm = _newchm;     // New table, if any\n      if( newchm != null ) {\n        System.out.println(\"----\");\n        newchm.print2();\n      }\n    }",
      "line_number": 523,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "get_impl",
      "signature": "private Object get_impl ( final long key ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "get_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "      final int hash = hash(key);\n      final int len     = _keys.length;\n      int idx = (hash & (len-1)); // First key hash\n\n      // Main spin/reprobe loop, looking for a Key hit\n      int reprobe_cnt=0;\n      while( true ) {\n        final long   K = _keys[idx]; // Get key   before volatile read, could be NO_KEY\n        final Object V = _vals[idx]; // Get value before volatile read, could be null or Tombstone or Prime\n        if( K == NO_KEY ) return null; // A clear miss\n\n        // Key-compare\n        if( key == K ) {\n          // Key hit!  Check for no table-copy-in-progress\n          if( !(V instanceof Prime) ) { // No copy?\n            if( V == TOMBSTONE) return null;\n            // We need a volatile-read between reading a newly inserted Value\n            // and returning the Value (so the user might end up reading the\n            // stale Value contents).\n            @SuppressWarnings(\"unused\") final CHM newchm = _newchm; // VOLATILE READ before returning V\n            return V;\n          }\n          // Key hit - but slot is (possibly partially) copied to the new table.\n          // Finish the copy & retry in the new table.\n          return copy_slot_and_check(idx,key).get_impl(key); // Retry in the new table\n        }\n        // get and put must have the same key lookup logic!  But only 'put'\n        // needs to force a table-resize for a too-long key-reprobe sequence.\n        // Check for too-many-reprobes on get.\n        if( ++reprobe_cnt >= reprobe_limit(len) ) // too many probes\n          return _newchm == null // Table copy in progress?\n            ? null               // Nope!  A clear miss\n            : copy_slot_and_check(idx,key).get_impl(key); // Retry in the new table\n\n        idx = (idx+1)&(len-1);    // Reprobe by 1!  (could now prefetch)\n      }\n    }",
      "line_number": 538,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "putIfMatch",
      "signature": "private Object putIfMatch( final long key, final Object putval, final Object expVal ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Condition",
        "Thread",
        "final"
      ],
      "dependencies": [
        "_reprobes.add",
        "expVal.equals",
        "add",
        "_nbhml.help_copy",
        "_slots.add",
        "table",
        "putIfMatch",
        "newchm.putIfMatch",
        "_size.add",
        "help_copy",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 62,
      "source_code": "      final int hash = hash(key);\n      assert putval != null;\n      assert !(putval instanceof Prime);\n      assert !(expVal instanceof Prime);\n      final int len      = _keys.length;\n      int idx = (hash & (len-1)); // The first key\n\n      // ---\n      // Key-Claim stanza: spin till we can claim a Key (or force a resizing).\n      int reprobe_cnt=0;\n      long   K;\n      Object V;\n      while( true ) {           // Spin till we get a Key slot\n        V = _vals[idx];         // Get old value\n        K = _keys[idx];         // Get current key\n        if( K == NO_KEY ) {     // Slot is free?\n          // Found an empty Key slot - which means this Key has never been in\n          // this table.  No need to put a Tombstone - the Key is not here!\n          if( putval == TOMBSTONE ) return TOMBSTONE; // Not-now & never-been in this table\n          if( expVal == MATCH_ANY ) return TOMBSTONE; // Will not match, even after K inserts\n          // Claim the zero key-slot\n          if( CAS_key(idx, NO_KEY, key) ) { // Claim slot for Key\n            _slots.add(1);      // Raise key-slots-used count\n            break;              // Got it!\n          }\n          // CAS to claim the key-slot failed.\n          //\n          // This re-read of the Key points out an annoying short-coming of Java\n          // CAS.  Most hardware CAS's report back the existing value - so that\n          // if you fail you have a *witness* - the value which caused the CAS\n          // to fail.  The Java API turns this into a boolean destroying the\n          // witness.  Re-reading does not recover the witness because another\n          // thread can write over the memory after the CAS.  Hence we can be in\n          // the unfortunate situation of having a CAS fail *for cause* but\n          // having that cause removed by a later store.  This turns a\n          // non-spurious-failure CAS (such as Azul has) into one that can\n          // apparently spuriously fail - and we avoid apparent spurious failure\n ",
      "line_number": 583,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "tableFull",
      "signature": "private boolean tableFull( int reprobe_cnt, int len ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "_slots.estimate_get",
        "estimate_get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      return\n        // Do the cheap check first: we allow some number of reprobes always\n        reprobe_cnt >= REPROBE_LIMIT &&\n        (reprobe_cnt >= reprobe_limit(len) ||\n         // More expensive check: see if the table is > 1/2 full.\n         _slots.estimate_get() >= (len>>1));\n    }",
      "line_number": 728,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private CHM resize() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "volatile",
        "synchronized",
        "Thread",
        "notifyAll",
        "notify"
      ],
      "dependencies": [
        "out.print",
        "RuntimeException",
        "nanoTime",
        "sleep",
        "println",
        "compareAndSet",
        "print",
        "System.currentTimeMillis",
        "_resizerUpdater.compareAndSet",
        "out.println",
        "Thread.sleep",
        "CHM",
        "System.nanoTime",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "observer_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 75,
      "source_code": "      // Check for resize already in progress, probably triggered by another thread\n      CHM newchm = _newchm;     // VOLATILE READ\n      if( newchm != null )      // See if resize is already in progress\n        return newchm;          // Use the new table already\n\n      // No copy in-progress, so start one.  First up: compute new table size.\n      int oldlen = _keys.length; // Old count of K,V pairs allowed\n      int sz = size();          // Get current table count of active K,V pairs\n      int newsz = sz;           // First size estimate\n\n      // Heuristic to determine new size.  We expect plenty of dead-slots-with-keys\n      // and we need some decent padding to avoid endless reprobing.\n      if( _nbhml._opt_for_space ) {\n        // This heuristic leads to a much denser table with a higher reprobe rate\n        if( sz >= (oldlen>>1) ) // If we are >50% full of keys then...\n          newsz = oldlen<<1;    // Double size\n      } else {\n        if( sz >= (oldlen>>2) ) { // If we are >25% full of keys then...\n          newsz = oldlen<<1;      // Double size\n          if( sz >= (oldlen>>1) ) // If we are >50% full of keys then...\n            newsz = oldlen<<2;    // Double double size\n        }\n      }\n\n      // Last (re)size operation was very recent?  Then double again\n      // despite having few live keys; slows down resize operations\n      // for tables subject to a high key churn rate - but do not\n      // forever grow the table.  If there is a high key churn rate\n      // the table needs a steady state of rare same-size resize\n      // operations to clean out the dead keys.\n      long tm = System.currentTimeMillis();\n      if( newsz <= oldlen &&    // New table would shrink or hold steady?\n          tm <= _nbhml._last_resize_milli+10000)  // Recent resize (less than 10 sec ago)\n        newsz = oldlen<<1;      // Double the existing size\n\n      // Do not shrink, ever.  If we hit this size once, assume we\n      // will again.\n      if( newsz < oldlen ) newsz = ol",
      "line_number": 743,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "help_copy_impl",
      "signature": "private void help_copy_impl( final boolean copy_all ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "Math.min",
        "_copyIdxUpdater.compareAndSet",
        "min",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 39,
      "source_code": "      final CHM newchm = _newchm;\n      assert newchm != null;    // Already checked by caller\n      int oldlen = _keys.length; // Total amount to copy\n      final int MIN_COPY_WORK = Math.min(oldlen,1024); // Limit per-thread work\n\n      // ---\n      int panic_start = -1;\n      int copyidx=-9999;            // Fool javac to think it's initialized\n      while( _copyDone < oldlen ) { // Still needing to copy?\n        // Carve out a chunk of work.  The counter wraps around so every\n        // thread eventually tries to copy every slot repeatedly.\n\n        // We \"panic\" if we have tried TWICE to copy every slot - and it still\n        // has not happened.  i.e., twice some thread somewhere claimed they\n        // would copy 'slot X' (by bumping _copyIdx) but they never claimed to\n        // have finished (by bumping _copyDone).  Our choices become limited:\n        // we can wait for the work-claimers to finish (and become a blocking\n        // algorithm) or do the copy work ourselves.  Tiny tables with huge\n        // thread counts trying to copy the table often 'panic'.\n        if( panic_start == -1 ) { // No panic?\n          copyidx = (int)_copyIdx;\n          while( copyidx < (oldlen<<1) && // 'panic' check\n                 !_copyIdxUpdater.compareAndSet(this,copyidx,copyidx+MIN_COPY_WORK) )\n            copyidx = (int)_copyIdx;     // Re-read\n          if( !(copyidx < (oldlen<<1)) ) // Panic!\n            panic_start = copyidx;       // Record where we started to panic-copy\n        }\n\n        // We now know what to copy.  Try to copy.\n        int workdone = 0;\n        for( int i=0; i<MIN_COPY_WORK; i++ )\n          if( copy_slot((copyidx+i)&(oldlen-1)) ) // Made an oldtable slot go dead?\n            workdone++;         // Yes!\n        if( workdone > 0 )      // Report work-done occasionally\n          copy_check_and_promote( workdone );// See if we can promote\n        //for( int i=0; i<MIN_COPY_WORK; i++ )\n        //  if( copy_slot((copyidx+i)&(oldlen-1)) ) // Made an ol",
      "line_number": 863,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_slot_and_check",
      "signature": "private CHM copy_slot_and_check( int idx, Object should_help ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "help_copy",
        "_nbhml.help_copy"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "      // We're only here because the caller saw a Prime, which implies a\n      // table-copy is in progress.\n      assert _newchm != null;\n      if( copy_slot(idx) )      // Copy the desired slot\n        copy_check_and_promote(1); // Record the slot copied\n      // Generically help along any copy (except if called recursively from a helper)\n      if( should_help != null ) _nbhml.help_copy();\n      return _newchm;\n    }",
      "line_number": 926,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "utilities",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_check_and_promote",
      "signature": "private void copy_check_and_promote( int workdone ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "CAS",
        "compareAndSet",
        "System.currentTimeMillis",
        "_copyDoneUpdater.compareAndSet",
        "_nbhml.CAS",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "      int oldlen = _keys.length;\n      // We made a slot unusable and so did some of the needed copy work\n      long copyDone = _copyDone;\n      long nowDone = copyDone+workdone;\n      assert nowDone <= oldlen;\n      if( workdone > 0 ) {\n        while( !_copyDoneUpdater.compareAndSet(this,copyDone,nowDone) ) {\n          copyDone = _copyDone;   // Reload, retry\n          nowDone = copyDone+workdone;\n          assert nowDone <= oldlen;\n        }\n      }\n\n      // Check for copy being ALL done, and promote.  Note that we might have\n      // nested in-progress copies and manage to finish a nested copy before\n      // finishing the top-level copy.  We only promote top-level copies.\n      if( nowDone == oldlen &&   // Ready to promote this table?\n          _nbhml._chm == this && // Looking at the top-level table?\n          // Attempt to promote\n          _nbhml.CAS(_chm_offset,this,_newchm) ) {\n        _nbhml._last_resize_milli = System.currentTimeMillis();  // Record resize time for next check\n      }\n    }",
      "line_number": 938,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "copy_slot",
      "signature": "private boolean copy_slot( int idx ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "_newchm.putIfMatch",
        "putIfMatch",
        "Prime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 26,
      "source_code": "      // Blindly set the key slot from NO_KEY to some key which hashes here,\n      // to eagerly stop fresh put's from inserting new values in the old\n      // table when the old table is mid-resize.  We don't need to act on the\n      // results here, because our correctness stems from box'ing the Value\n      // field.  Slamming the Key field is a minor speed optimization.\n      long key;\n      while( (key=_keys[idx]) == NO_KEY )\n        CAS_key(idx, NO_KEY, (idx+_keys.length)/*a non-zero key which hashes here*/);\n\n      // ---\n      // Prevent new values from appearing in the old table.\n      // Box what we see in the old table, to prevent further updates.\n      Object oldval = _vals[idx]; // Read OLD table\n      while( !(oldval instanceof Prime) ) {\n        final Prime box = (oldval == null || oldval == TOMBSTONE) ? TOMBPRIME : new Prime(oldval);\n        if( CAS_val(idx,oldval,box) ) { // CAS down a box'd version of oldval\n          // If we made the Value slot hold a TOMBPRIME, then we both\n          // prevented further updates here but also the (absent) oldval is\n          // vaccuously available in the new table.  We return with true here:\n          // any thread looking for a value for this key can correctly go\n          // straight to the new table and skip looking in the old table.\n          if( box == TOMBPRIME )\n            return true;\n          // Otherwise we boxed something, but it still needs to be\n          // copied into the new table.\n          oldval = box;         // Record updated oldval\n          break;                // Break loop; oldval is now boxed by us\n        }\n        oldval = _vals[idx];    // Else try, try again\n      }\n      if( oldval == TOMBPRIME ) return false; // Copy already complete here!\n\n      // ---\n      // Copy the value into the new table, but only if we overwrite a null.\n      // If another value is already in the new table, then somebody else\n      // wrote something there and that write is happens-after any value that",
      "line_number": 973,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "SnapshotV",
      "signature": "public SnapshotV() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "help_copy_impl",
        "topchm.help_copy_impl"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "      CHM topchm;\n      while( true ) {           // Verify no table-copy-in-progress\n        topchm = _chm;\n        if( topchm._newchm == null ) // No table-copy-in-progress\n          break;\n        // Table copy in-progress - so we cannot get a clean iteration.  We\n        // must help finish the table copy before we can start iterating.\n        topchm.help_copy_impl(true);\n      }\n      // The \"linearization point\" for the iteration.  Every key in this table\n      // will be visited, but keys added later might be skipped or even be\n      // added to a following table (also not iterated over).\n      _sschm = topchm;\n      // Warm-up the iterator\n      _idx = -1;\n      next();\n    }",
      "line_number": 1033,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "key",
      "signature": "long key(final int idx) { return _sschm._keys[idx]; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 1052,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public TypeV next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "NoSuchElementException",
        "_nextK"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "      // 'next' actually knows what the next value will be - it had to\n      // figure that out last go 'round lest 'hasNext' report true and\n      // some other thread deleted the last value.  Instead, 'next'\n      // spends all its effort finding the key that comes after the\n      // 'next' key.\n      if( _idx != -1 && _nextV == null ) throw new NoSuchElementException();\n      _prevK = _nextK;          // This will become the previous key\n      _prevV = _nextV;          // This will become the previous value\n      _nextV = null;            // We have no more next-key\n      // Attempt to set <_nextK,_nextV> to the next K,V pair.\n      // _nextV is the trigger: stop searching when it is != null\n      if( _idx == -1 ) {        // Check for NO_KEY\n        _idx = 0;               // Setup for next phase of search\n        _nextK = NO_KEY;\n        if( (_nextV=get(_nextK)) != null ) return _prevV;\n      }\n      while( _idx<length() ) {  // Scan array\n        _nextK = key(_idx++); // Get a key that definitely is in the set (for the moment!)\n        if( _nextK != NO_KEY && // Found something?\n            (_nextV=get(_nextK)) != null )\n          break;                // Got it!  _nextK is a valid Key\n      }                         // Else keep scanning\n      return _prevV;            // Return current value.\n    }",
      "line_number": 1057,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "removeKey",
      "signature": "public void removeKey() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "IllegalStateException",
        "putIfMatch",
        "this.putIfMatch"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 6,
      "source_code": "      if( _prevV == null ) throw new IllegalStateException();\n      NonBlockingHashMapLong.this.putIfMatch( _prevK, TOMBSTONE, NO_MATCH_OLD);\n      _prevV = null;\n    }",
      "line_number": 1083,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "values",
      "signature": "public Collection<TypeV> values() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "TypeV",
        "size",
        "this.containsValue",
        "clear",
        "SnapshotV",
        "containsValue",
        "AbstractCollection",
        "this.clear",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 15,
      "source_code": "    return new AbstractCollection<TypeV>() {\n      public void    clear   (          ) {        NonBlockingHashMapLong.this.clear   ( ); }\n      public int     size    (          ) { return NonBlockingHashMapLong.this.size    ( ); }\n      public boolean contains( Object v ) { return NonBlockingHashMapLong.this.containsValue(v); }\n      public Iterator<TypeV> iterator()   { return new SnapshotV(); }\n    };\n  }",
      "line_number": 1120,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void    clear   (          ) {        NonBlockingHashMapLong.this.clear   ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1122,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int     size    (          ) { return NonBlockingHashMapLong.this.size    ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains( Object v ) { return NonBlockingHashMapLong.this.containsValue(v); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "containsValue",
        "this.containsValue"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1124,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "keySet",
      "signature": "public Set<Long> keySet() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "IteratorLong",
        "Long",
        "clear",
        "containsKey",
        "this.remove",
        "AbstractSet",
        "this.containsKey",
        "remove",
        "this.clear",
        "this.size"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "    return new AbstractSet<Long> () {\n      public void    clear   (          ) {        NonBlockingHashMapLong.this.clear   ( ); }\n      public int     size    (          ) { return NonBlockingHashMapLong.this.size    ( ); }\n      public boolean contains( Object k ) { return NonBlockingHashMapLong.this.containsKey(k); }\n      public boolean remove  ( Object k ) { return NonBlockingHashMapLong.this.remove  (k) != null; }\n      public IteratorLong iterator()    { return new IteratorLong(); }\n    };\n  }",
      "line_number": 1170,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void    clear   (          ) {        NonBlockingHashMapLong.this.clear   ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1172,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int     size    (          ) { return NonBlockingHashMapLong.this.size    ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1173,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains( Object k ) { return NonBlockingHashMapLong.this.containsKey(k); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "this.containsKey",
        "containsKey"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1174,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove  ( Object k ) { return NonBlockingHashMapLong.this.remove  (k) != null; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "remove",
        "this.remove"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1175,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "keySetLong",
      "signature": "public long[] keySetLong() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "i.hasNext",
        "hasNext",
        "nextLong",
        "i.nextLong",
        "iterator"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "    long[] dom = new long[size()];\n    IteratorLong i=(IteratorLong)keySet().iterator();\n    int j=0;\n    while( j < dom.length && i.hasNext() )\n      dom[j++] = i.nextLong();\n    return dom;\n  }",
      "line_number": 1182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "setValue",
      "signature": "public TypeV setValue(final TypeV val) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      if (val == null) throw new NullPointerException();\n      _val = val;\n      return put(_key, val);\n    }",
      "line_number": 1196,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void    clear   (          ) {        NonBlockingHashMapLong.this.clear( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "clear",
        "this.clear"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1239,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int     size    (          ) { return NonBlockingHashMapLong.this.size ( ); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "size",
        "this.size"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "",
      "line_number": 1240,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove( final Object o ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "getKey",
        "e.getKey",
        "e.getValue",
        "this.remove",
        "getValue",
        "remove"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (!(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        return NonBlockingHashMapLong.this.remove(e.getKey(), e.getValue());\n      }",
      "line_number": 1241,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getKey",
        "v.equals",
        "e.getKey",
        "e.getValue",
        "getValue",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if (!(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        TypeV v = get(e.getKey());\n        return v != null && v.equals(e.getValue());\n      }",
      "line_number": 1246,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "writeObject",
      "signature": "private void writeObject(java.io.ObjectOutputStream s) throws IOException  {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "s.writeLong",
        "s.defaultWriteObject",
        "writeObject",
        "writeLong",
        "s.writeObject",
        "long",
        "defaultWriteObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "    s.defaultWriteObject();     // Write nothing\n    for( long K : keySet() ) {\n      final Object V = get(K);  // Do an official 'get'\n      s.writeLong  (K);         // Write the <long,TypeV> pair\n      s.writeObject(V);\n    }\n    s.writeLong(NO_KEY);        // Sentinel to indicate end-of-data\n    s.writeObject(null);\n  }",
      "line_number": 1258,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "readObject",
      "signature": "private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException  {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "s.readLong",
        "s.defaultReadObject",
        "readObject",
        "defaultReadObject",
        "s.readObject",
        "readLong"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "    s.defaultReadObject();      // Read nothing\n    initialize(MIN_SIZE);\n    for (;;) {\n      final long K = s.readLong();\n      final TypeV V = (TypeV) s.readObject();\n      if( K == NO_KEY && V == null ) break;\n      put(K,V);               // Insert with an offical put\n    }\n  }",
      "line_number": 1272,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "clone",
      "signature": "public NonBlockingHashMapLong<TypeV> clone() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "t.put",
        "put",
        "InternalError",
        "super.clone",
        "clear",
        "t.clear",
        "clone",
        "TypeV"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "    try {\n      // Must clone, to get the class right; NBHML might have been\n      // extended so it would be wrong to just make a new NBHML.\n      NonBlockingHashMapLong<TypeV> t = (NonBlockingHashMapLong<TypeV>) super.clone();\n      // But I don't have an atomic clone operation - the underlying _kvs\n      // structure is undergoing rapid change.  If I just clone the _kvs\n      // field, the CHM in _kvs[0] won't be in sync.\n      //\n      // Wipe out the cloned array (it was shallow anyways).\n      t.clear();\n      // Now copy sanely\n      for( long K : keySetLong() )\n        t.put(K,get(K));\n      return t;\n    } catch (CloneNotSupportedException e) {\n      // this shouldn't happen, since we are Cloneable\n      throw new InternalError();\n    }\n  }",
      "line_number": 1292,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "obeys",
      "method_type": "method"
    },
    {
      "name": "NonBlockingHashSet",
      "signature": "public NonBlockingHashSet() { super(); _map = new NonBlockingHashMap<E,Object>(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "NonBlockingHashMap",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 33,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingHashSet",
      "method_type": "constructor"
    },
    {
      "name": "add",
      "signature": "public boolean add( final E o ) { return _map.putIfAbsent(o,V) == null; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_map.putIfAbsent",
        "putIfAbsent"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 1,
      "source_code": "",
      "line_number": 38,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingHashSet",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains   ( final Object     o ) { return _map.containsKey(o); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_map.containsKey",
        "containsKey"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 41,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingHashSet",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public E get( final E o ) { return _map.getk(o); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_map.getk",
        "getk"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingHashSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove( final Object o ) { return _map.remove(o) == V; }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_map.remove",
        "remove"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 50,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NonBlockingHashSet",
      "method_type": "method"
    },
    {
      "name": "set",
      "signature": "public void set( long x ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CAT"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "    CAT newcat = new CAT(null,4,x);\n    // Spin until CAS works\n    while( !CAS_cat(_cat,newcat) ) {/*empty*/}\n  }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get()       { return      _cat.sum(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "_cat.sum",
        "sum"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "estimate_get",
      "signature": "public long estimate_get( ) { return _cat.estimate_sum(); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "_cat.estimate_sum",
        "estimate_sum"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 73,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "CAS_cat",
      "signature": "private boolean CAS_cat( CAT oldcat, CAT newcat ) { return _catUpdater.compareAndSet(this,oldcat,newcat); }",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "_catUpdater.compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "hash",
      "signature": "private static int hash() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "static"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread",
        "identityHashCode",
        "System.identityHashCode"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "    //int h = (int)Thread.currentThread().getId();\n    int h = System.identityHashCode(Thread.currentThread());\n    return h<<3;                // Pad out cache lines.  The goal is to avoid cache-line contention\n  }",
      "line_number": 104,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "rawIndex",
      "signature": "private static long rawIndex(long[] ary, int i) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "      assert i >= 0 && i < ary.length;\n      return _Lbase + (i * (long)_Lscale);\n    }",
      "line_number": 116,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "CAS",
      "signature": "private static boolean CAS( long[] A, int idx, long old, long nnn ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "      return UNSAFE.compareAndSwapLong( A, rawIndex(A,idx), old, nnn );\n    }",
      "line_number": 120,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "add_if",
      "signature": "public long add_if( long x, int hash, ConcurrentAutoTable master ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "sleep",
        "compareAndSet",
        "_resizerUpdater.compareAndSet",
        "CAT",
        "CAS_cat",
        "master.CAS_cat",
        "Thread.sleep"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "singleton_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 44,
      "source_code": "      final long[] t = _t;\n      final int idx = hash & (t.length-1);\n      // Peel loop; try once fast\n      long old = t[idx];\n      final boolean ok = CAS( t, idx, old, old+x );\n      if( ok ) return old;      // Got it\n      // Try harder\n      int cnt=0;\n      while( true ) {\n        old = t[idx];\n        if( CAS( t, idx, old, old+x ) ) break; // Got it!\n        cnt++;\n      }\n      if( cnt < MAX_SPIN ) return old; // Allowable spin loop count\n      if( t.length >= 1024*1024 ) return old; // too big already\n\n      // Too much contention; double array size in an effort to reduce contention\n      //long r = _resizers;\n      //final int newbytes = (t.length<<1)<<3/*word to bytes*/;\n      //while( !_resizerUpdater.compareAndSet(this,r,r+newbytes) )\n      //  r = _resizers;\n      //r += newbytes;\n      if( master._cat != this ) return old; // Already doubled, don't bother\n      //if( (r>>17) != 0 ) {      // Already too much allocation attempts?\n      //  // We could use a wait with timeout, so we'll wakeup as soon as the new\n      //  // table is ready, or after the timeout in any case.  Annoyingly, this\n      //  // breaks the non-blocking property - so for now we just briefly sleep.\n      //  //synchronized( this ) { wait(8*megs); }         // Timeout - we always wakeup\n      //  try { Thread.sleep(r>>17); } catch( InterruptedException e ) { }\n      //  if( master._cat != this ) return old;\n      //}\n\n      CAT newcat = new CAT(this,t.length*2,0);\n      // Take 1 stab at updating the CAT with the new larger size.  If this\n      // fails, we assume some other thread already expanded the CAT - so we\n      // do not need to retry until it succeeds.\n      while( master._cat == this && !master.CAS_cat(this,newcat) ) {/*empty*/}\n      return old;\n    }",
      "line_number": 143,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum( ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "_next.sum",
        "sum"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "      long sum = _next == null ? 0 : _next.sum(); // Recursively get cached sum\n      final long[] t = _t;\n      for( long cnt : t ) sum += cnt;\n      return sum;\n    }",
      "line_number": 187,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "estimate_sum",
      "signature": "public long estimate_sum( ) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "System.currentTimeMillis",
        "currentTimeMillis"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "      // For short tables, just do the work\n      if( _t.length <= 64 ) return sum();\n      // For bigger tables, periodically freshen a cached value\n      long millis = System.currentTimeMillis();\n      if( _fuzzy_time != millis ) { // Time marches on?\n        _fuzzy_sum_cache = sum(); // Get sum the hard way\n        _fuzzy_time = millis;   // Indicate freshness of cached value\n      }\n      return _fuzzy_sum_cache;  // Return cached sum\n    }",
      "line_number": 196,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "print",
      "signature": "public void print() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/maps/ConcurrentAutoTable.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.print",
        "_next.print",
        "print"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 2,
      "source_code": "      long[] t = _t;\n      System.out.print(\"[\"+t[0]);\n      for( int i=1; i<t.length; i++ )\n        System.out.print(\",\"+t[i]);\n      System.out.print(\"]\");\n      if( _next != null ) _next.print();\n    }",
      "line_number": 210,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ConcurrentAutoTable",
      "method_type": "method"
    },
    {
      "name": "roundToPowerOfTwo",
      "signature": "public static int roundToPowerOfTwo(final int value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/Pow2.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "Integer.numberOfLeadingZeros",
        "numberOfLeadingZeros"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        if (value > MAX_POW2) {\n            throw new IllegalArgumentException(\"There is no larger power of 2 int for value:\"+value+\" since it exceeds 2^31.\");\n        }\n        if (value < 0) {\n            throw new IllegalArgumentException(\"Given value:\"+value+\". Expecting value >= 0.\");\n        }\n        final int nextPow2 = 1 << (32 - Integer.numberOfLeadingZeros(value - 1));\n        return nextPow2;\n    }",
      "line_number": 28,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "Pow2",
      "method_type": "method"
    },
    {
      "name": "isPowerOfTwo",
      "signature": "public static boolean isPowerOfTwo(final int value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/Pow2.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return (value & (value - 1)) == 0;\n    }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "Pow2",
      "method_type": "method"
    },
    {
      "name": "align",
      "signature": "public static long align(final long value, final int alignment) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/Pow2.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        if (!isPowerOfTwo(alignment)) {\n            throw new IllegalArgumentException(\"alignment must be a power of 2:\" + alignment);\n        }\n        return (value + (alignment - 1)) & ~(alignment - 1);\n    }",
      "line_number": 55,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "Pow2",
      "method_type": "method"
    },
    {
      "name": "spVal",
      "signature": "public void spVal(long v) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putLong",
        "UNSAFE.putLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putLong(this, VALUE_OFFSET, v);\n    }",
      "line_number": 47,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "soVal",
      "signature": "public void soVal(long v) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, VALUE_OFFSET, v);\n    }",
      "line_number": 50,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "lpVal",
      "signature": "public long lpVal() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, VALUE_OFFSET);\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "casVal",
      "signature": "public boolean casVal(long expectedV, long newV) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expectedV, newV);\n    }",
      "line_number": 65,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndSetVal",
      "signature": "public long getAndSetVal(long v) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "getAndSet"
      ],
      "dependencies": [
        "UNSAFE.getAndSetLong",
        "getAndSetLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (UnsafeAccess.SUPPORTS_GET_AND_ADD_LONG) {\n            return UNSAFE.getAndSetLong(this, VALUE_OFFSET, v);\n        }\n        else {\n            long currV;\n            do {\n                currV = lvVal();\n            } while (!casVal(currV, v));\n            return currV;\n        }\n    }",
      "line_number": 69,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndAddVal",
      "signature": "public long getAndAddVal(long delta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [
        "getAndAddLong",
        "UNSAFE.getAndAddLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (UnsafeAccess.SUPPORTS_GET_AND_ADD_LONG) {\n            return UNSAFE.getAndAddLong(this, VALUE_OFFSET, delta);\n        }\n        else {\n            long currV;\n            do {\n                currV = lvVal();\n            } while (!casVal(currV, currV + delta));\n            return currV;\n        }\n    }",
      "line_number": 82,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "PaddedAtomicLong",
      "signature": "public PaddedAtomicLong() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "    }",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "PaddedAtomicLong",
      "signature": "public PaddedAtomicLong(long initialValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        svVal(initialValue);\n    }",
      "line_number": 131,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return lvVal();\n    }",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "set",
      "signature": "public void set(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        svVal(newValue);\n    }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "lazySet",
      "signature": "public void lazySet(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        soVal(newValue);\n    }",
      "line_number": 161,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndSet",
      "signature": "public long getAndSet(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "getAndSet"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndSetVal(newValue);\n    }",
      "line_number": 172,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "compareAndSet",
      "signature": "public boolean compareAndSet(long expect, long update) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return casVal(expect, update);\n    }",
      "line_number": 186,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "weakCompareAndSet",
      "signature": "public boolean weakCompareAndSet(long expect, long update) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "weakCompareAndSet"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return casVal(expect, update);\n    }",
      "line_number": 203,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndIncrement",
      "signature": "public long getAndIncrement() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement",
        "getAndAdd"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAddVal(1L);\n    }",
      "line_number": 213,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndDecrement",
      "signature": "public long getAndDecrement() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd",
        "getAndDecrement"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAddVal(-1L);\n    }",
      "line_number": 223,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndAdd",
      "signature": "public long getAndAdd(long delta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAddVal(delta);\n    }",
      "line_number": 234,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "incrementAndGet",
      "signature": "public long incrementAndGet() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd",
        "incrementAndGet"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAddVal(1L) + 1L;\n    }",
      "line_number": 244,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "decrementAndGet",
      "signature": "public long decrementAndGet() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "decrementAndGet",
        "getAndAdd"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAddVal(-1L) - 1L;\n    }",
      "line_number": 254,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "addAndGet",
      "signature": "public long addAndGet(long delta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [
        "addAndGet",
        "getAndAdd"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAddVal( delta) + delta;\n    }",
      "line_number": 265,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndUpdate",
      "signature": "public long getAndUpdate(LongUnaryOperator updateFunction) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "updateFunction.applyAsLong",
        "applyAsLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long prev, next;\n        do {\n            prev = lvVal();\n            next = updateFunction.applyAsLong(prev);\n        } while (!casVal(prev, next));\n        return prev;\n    }",
      "line_number": 279,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "updateAndGet",
      "signature": "public long updateAndGet(LongUnaryOperator updateFunction) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "updateFunction.applyAsLong",
        "applyAsLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long prev, next;\n        do {\n            prev = lvVal();\n            next = updateFunction.applyAsLong(prev);\n        } while (!casVal(prev, next));\n        return next;\n    }",
      "line_number": 298,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "getAndAccumulate",
      "signature": "public long getAndAccumulate(long v, LongBinaryOperator f) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "f.applyAsLong",
        "applyAsLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long prev, next;\n        do {\n            prev = lvVal();\n            next = f.applyAsLong(prev, v);\n        } while (!casVal(prev, next));\n        return prev;\n    }",
      "line_number": 321,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "accumulateAndGet",
      "signature": "public long accumulateAndGet(long x, LongBinaryOperator f) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/util/PaddedAtomicLong.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "f.applyAsLong",
        "applyAsLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long prev, next;\n        do {\n            prev = lvVal();\n            next = f.applyAsLong(prev, x);\n        } while (!casVal(prev, next));\n        return next;\n    }",
      "line_number": 334,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "PaddedAtomicLongL1Pad",
      "method_type": "method"
    },
    {
      "name": "parkUntilNext",
      "signature": "private E parkUntilNext(E[] buffer, long cIndex, long offset, long timeoutNs) throws InterruptedException {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/MpscBlockingConsumerArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "InterruptedException",
        "currentThread",
        "nanoTime",
        "LockSupport.parkNanos",
        "Thread.interrupted",
        "Thread.currentThread",
        "System.nanoTime",
        "parkNanos",
        "interrupted"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 45,
      "source_code": "        E e;\n        final long pIndex = lvProducerIndex();\n        if (cIndex == pIndex && // queue is empty\n            casProducerIndex(pIndex, pIndex + 1)) // we announce ourselves as parked by setting parity\n        {\n            // producers only try a wakeup when both the index and the blocked thread are visible, otherwise they spin\n            soBlocked(Thread.currentThread());\n            // ignore deadline when it's forever\n            final long deadlineNs = timeoutNs == Long.MAX_VALUE ? 0 : System.nanoTime() + timeoutNs;\n\n            try\n            {\n                while (true)\n                {\n                    LockSupport.parkNanos(this, timeoutNs);\n                    if (Thread.interrupted())\n                    {\n                        casProducerIndex(pIndex + 1, pIndex);\n                        throw new InterruptedException();\n                    }\n                    if ((lvProducerIndex() & 1) == 0) {\n                        break;\n                    }\n                    // ignore deadline when it's forever\n                    timeoutNs = timeoutNs == Long.MAX_VALUE ? Long.MAX_VALUE : deadlineNs - System.nanoTime();\n                    if (timeoutNs <= 0)\n                    {\n                        if (casProducerIndex(pIndex + 1, pIndex))\n                        {\n                            // ran out of time and the producer has not moved the index\n                            return null;\n                        }\n\n                        break; // just in the nick of time\n                    }\n                }\n            }\n            finally\n            {\n                soBlocked(null);\n            }\n        }\n        // producer index is visible before element, so if we wake up between the index moving and the element\n        // store we could see a null.\n        e = spinWaitForElement(buffer, offset);\n\n        soRefElement(buffer, offset, null); // release element null\n        soConsumerIndex(cIndex + 2); // release cIndex\n\n",
      "line_number": 491,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscBlockingConsumerArrayQueuePad1",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, final int limit, long timeout, TimeUnit unit) throws InterruptedException {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/MpscBlockingConsumerArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        if (limit == 0) {\n            return 0;\n        }\n        final int drained = drain(c, limit);\n        if (drained != 0) {\n            return drained;\n        }\n        final E e = poll(timeout, unit);\n        if (e == null)\n            return 0;\n        c.accept(e);\n        return 1 + drain(c, limit - 1);\n    }",
      "line_number": 784,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscBlockingConsumerArrayQueuePad1",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/ConcurrentCircularArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "WeakIterator",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final long cIndex = lvConsumerIndex();\n        final long pIndex = lvProducerIndex();\n\n        return new WeakIterator(cIndex, pIndex, mask, buffer);\n    }",
      "line_number": 118,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "ConcurrentCircularArrayQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/ConcurrentCircularArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "            final E e = nextElement;\n            if (e == null)\n                throw new NoSuchElementException();\n            nextElement = getNext();\n            return e;\n        }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ConcurrentCircularArrayQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "getNext",
      "signature": "private E getNext() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/ConcurrentCircularArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            while (nextIndex < pIndex) {\n                long offset = calcCircularRefElementOffset(nextIndex++, mask);\n                E e = lvRefElement(buffer, offset);\n                if (e != null) {\n                    return e;\n                }\n            }\n            return null;\n        }",
      "line_number": 159,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public static int size(IndexedQueue iq, int divisor) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/IndexedQueueSizeUtil.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "lvProducerIndex",
        "capacity",
        "iq.lvConsumerIndex",
        "lvConsumerIndex",
        "iq.lvProducerIndex",
        "iq.capacity"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 10,
      "source_code": "        /*\n         * It is possible for a thread to be interrupted or reschedule between the reads of the producer and\n         * consumer indices. It is also for the indices to be updated in a `weakly` visible way. It follows that\n         * the size value needs to be sanitized to match a valid range.\n         */\n        long after = iq.lvConsumerIndex();\n        long size;\n        while (true)\n        {\n            final long before = after;\n            // pIndex read is \"sandwiched\" between 2 cIndex reads\n            final long currentProducerIndex = iq.lvProducerIndex();\n            after = iq.lvConsumerIndex();\n            if (before == after)\n            {\n                size = (currentProducerIndex - after) / divisor;\n                break;\n            }\n        }\n        return sanitizedSize(iq.capacity(), size);\n    }",
      "line_number": 41,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "IndexedQueueSizeUtil",
      "method_type": "method"
    },
    {
      "name": "sanitizedSize",
      "signature": "public static int sanitizedSize(int capacity, long size) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/IndexedQueueSizeUtil.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 8,
      "source_code": "        // Concurrent updates to cIndex and pIndex may lag behind other progress enablers (e.g. FastFlow), so we need\n        // to check bounds [0,capacity]\n        if (size < 0)\n        {\n            return 0;\n        }\n        if (capacity != MessagePassingQueue.UNBOUNDED_CAPACITY && size > capacity)\n        {\n            return capacity;\n        }\n        // Integer overflow is possible for the unbounded indexed queues.\n        if (size > Integer.MAX_VALUE)\n        {\n            return Integer.MAX_VALUE;\n        }\n        return (int) size;\n    }",
      "line_number": 64,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IndexedQueueSizeUtil",
      "method_type": "method"
    },
    {
      "name": "inc",
      "signature": "protected void inc(long[] cells, long offset, long delta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounterV6.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "UNSAFE.getLongVolatile",
        "compareAndSwapLong",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        long v;\n        do {\n            v = UNSAFE.getLongVolatile(cells, offset);\n        } while (!UNSAFE.compareAndSwapLong(cells, offset, v, v + delta));\n    }",
      "line_number": 18,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "FixedSizeStripedLongCounterV6",
      "method_type": "method"
    },
    {
      "name": "getAndReset",
      "signature": "protected long getAndReset(long[] cells, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounterV6.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "UNSAFE.getLongVolatile",
        "compareAndSwapLong",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        long v;\n        do {\n            v = UNSAFE.getLongVolatile(cells, offset);\n        } while (!UNSAFE.compareAndSwapLong(cells, offset, v, 0L));\n\n        return v;\n    }",
      "line_number": 26,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FixedSizeStripedLongCounterV6",
      "method_type": "method"
    },
    {
      "name": "createFixedSizeStripedCounter",
      "signature": "public static FixedSizeStripedLongCounter createFixedSizeStripedCounter(int stripesCount) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "FixedSizeStripedLongCounterV6",
        "FixedSizeStripedLongCounterV8"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (UnsafeAccess.SUPPORTS_GET_AND_ADD_LONG) {\n            return new FixedSizeStripedLongCounterV8(stripesCount);\n        } else {\n            return new FixedSizeStripedLongCounterV6(stripesCount);\n        }\n    }",
      "line_number": 13,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "createFixedSizeStripedCounterV6",
      "signature": "public static FixedSizeStripedLongCounter createFixedSizeStripedCounterV6(int stripesCount) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "FixedSizeStripedLongCounterV6"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return new FixedSizeStripedLongCounterV6(stripesCount);\n    }",
      "line_number": 21,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "createFixedSizeStripedCounterV8",
      "signature": "public static FixedSizeStripedLongCounter createFixedSizeStripedCounterV8(int stripesCount) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/CountersFactory.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "FixedSizeStripedLongCounterV8"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return new FixedSizeStripedLongCounterV8(stripesCount);\n    }",
      "line_number": 25,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CountersFactory",
      "method_type": "method"
    },
    {
      "name": "inc",
      "signature": "protected void inc(long[] cells, long offset, long delta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounterV8.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [
        "getAndAddLong",
        "UNSAFE.getAndAddLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.getAndAddLong(cells, offset, delta);\n    }",
      "line_number": 18,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FixedSizeStripedLongCounterV8",
      "method_type": "method"
    },
    {
      "name": "getAndReset",
      "signature": "protected long getAndReset(long[] cells, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounterV8.java",
      "language": "java",
      "sync_primitives": [
        "getAndSet"
      ],
      "dependencies": [
        "UNSAFE.getAndSetLong",
        "getAndSetLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getAndSetLong(cells, offset, 0L);\n    }",
      "line_number": 23,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FixedSizeStripedLongCounterV8",
      "method_type": "method"
    },
    {
      "name": "getProbeOffset",
      "signature": "private static long getProbeOffset() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "ThreadLocal"
      ],
      "dependencies": [
        "getDeclaredField",
        "objectFieldOffset",
        "UNSAFE.objectFieldOffset",
        "class.getDeclaredField"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        try {\n            return UNSAFE.objectFieldOffset(Thread.class.getDeclaredField(\"threadLocalRandomProbe\"));\n\n        } catch (NoSuchFieldException e) {\n            return -1L;\n        }\n    }",
      "line_number": 74,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "representing",
      "method_type": "method"
    },
    {
      "name": "inc",
      "signature": "public void inc(long delta) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        inc(cells, counterOffset(index()), delta);\n    }",
      "line_number": 93,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "representing",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        long result = 0L;\n        long[] cells = this.cells;\n        int length = mask + 1;\n        for (int i = 0; i < length; i++) {\n            result += UNSAFE.getLongVolatile(cells, counterOffset(i));\n        }\n        return result;\n    }",
      "line_number": 98,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "representing",
      "method_type": "method"
    },
    {
      "name": "counterOffset",
      "signature": "private long counterOffset(long i) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return COUNTER_ARRAY_BASE + (i << ELEMENT_SHIFT);\n    }",
      "line_number": 108,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "representing",
      "method_type": "method"
    },
    {
      "name": "getAndReset",
      "signature": "public long getAndReset() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        long result = 0L;\n        long[] cells = this.cells;\n        int length = mask + 1;\n        for (int i = 0; i < length; i++) {\n            result += getAndReset(cells, counterOffset(i));\n        }\n        return result;\n    }",
      "line_number": 113,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "representing",
      "method_type": "method"
    },
    {
      "name": "probe",
      "signature": "private int probe() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "Thread",
        "ThreadLocal",
        "static"
      ],
      "dependencies": [
        "UNSAFE.getInt",
        "currentThread",
        "getId",
        "Thread.currentThread",
        "current",
        "ThreadLocalRandom.current",
        "getInt"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "        // Fast path for reliable well-distributed probe, available from JDK 7+.\n        // As long as PROBE is final static this branch will be constant folded\n        // (i.e removed).\n        if (PROBE != -1) {\n            int probe;\n            if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {\n                ThreadLocalRandom.current(); // force initialization\n                probe = UNSAFE.getInt(Thread.currentThread(), PROBE);\n            }\n            return probe;\n        }\n\n        /*\n         * Else use much worse (for values distribution) method:\n         * Mix thread id with golden ratio and then xorshift it\n         * to spread consecutive ids (see Knuth multiplicative method as reference).\n         */\n        int probe = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n        // xorshift\n        probe ^= probe << 13;\n        probe ^= probe >>> 17;\n        probe ^= probe << 5;\n        return probe;\n    }",
      "line_number": 137,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "representing",
      "method_type": "method"
    },
    {
      "name": "spProducerNode",
      "signature": "final void spProducerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_NODE_UPDATER.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        P_NODE_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerNode",
      "signature": "final void soProducerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_NODE_UPDATER.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        P_NODE_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 91,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerNode",
      "signature": "final LinkedQueueAtomicNode<E> lvProducerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return producerNode;\n    }",
      "line_number": 95,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerNode",
      "signature": "final boolean casProducerNode(LinkedQueueAtomicNode<E> expect, LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_NODE_UPDATER.compareAndSet",
        "compareAndSet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        return P_NODE_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 99,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerNode",
      "signature": "final LinkedQueueAtomicNode<E> lpProducerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return producerNode;\n    }",
      "line_number": 103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "xchgProducerNode",
      "signature": "protected final LinkedQueueAtomicNode<E> xchgProducerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "getAndSet"
      ],
      "dependencies": [
        "P_NODE_UPDATER.getAndSet",
        "getAndSet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        return P_NODE_UPDATER.getAndSet(this, newValue);\n    }",
      "line_number": 107,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spConsumerNode",
      "signature": "final void spConsumerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_NODE_UPDATER.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        C_NODE_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 177,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerNode",
      "signature": "final LinkedQueueAtomicNode<E> lvConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return consumerNode;\n    }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerNode",
      "signature": "final LinkedQueueAtomicNode<E> lpConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return consumerNode;\n    }",
      "line_number": 186,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public final Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 256,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 261,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newNode",
      "signature": "protected final LinkedQueueAtomicNode<E> newNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "LinkedQueueAtomicNode",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        return new LinkedQueueAtomicNode<E>();\n    }",
      "line_number": 265,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newNode",
      "signature": "protected final LinkedQueueAtomicNode<E> newNode(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "LinkedQueueAtomicNode",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        return new LinkedQueueAtomicNode<E>(e);\n    }",
      "line_number": 269,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public final int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lvNext",
        "chaserNode.lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 19,
      "source_code": "        // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n        // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n        LinkedQueueAtomicNode<E> chaserNode = lvConsumerNode();\n        LinkedQueueAtomicNode<E> producerNode = lvProducerNode();\n        int size = 0;\n        // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n        while (// don't go passed producer node\n        chaserNode != producerNode && // stop at last node\n        chaserNode != null && // stop at max int\n        size < Integer.MAX_VALUE) {\n            LinkedQueueAtomicNode<E> next;\n            next = chaserNode.lvNext();\n            // check if this node has been consumed, if so return what we have\n            if (next == chaserNode) {\n                return size;\n            }\n            chaserNode = next;\n            size++;\n        }\n        return size;\n    }",
      "line_number": 284,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        LinkedQueueAtomicNode<E> consumerNode = lvConsumerNode();\n        LinkedQueueAtomicNode<E> producerNode = lvProducerNode();\n        return consumerNode == producerNode;\n    }",
      "line_number": 318,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getSingleConsumerNodeValue",
      "signature": "protected E getSingleConsumerNodeValue(LinkedQueueAtomicNode<E> currConsumerNode, LinkedQueueAtomicNode<E> nextNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getAndNullValue",
        "currConsumerNode.soNext",
        "soNext",
        "nextNode.getAndNullValue",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // we have to null out the value because we are going to hang on to the node\n        final E nextValue = nextNode.getAndNullValue();\n        // Fix up the next ref of currConsumerNode to prevent promoted nodes from keeping new ones alive.\n        // We use a reference to self instead of null because null is already a meaningful value (the next of\n        // producer node is null).\n        currConsumerNode.soNext(currConsumerNode);\n        spConsumerNode(nextNode);\n        // currConsumerNode is now no longer referenced and can be collected\n        return nextValue;\n    }",
      "line_number": 324,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final LinkedQueueAtomicNode<E> currConsumerNode = lpConsumerNode();\n        LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        } else if (currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n            // got the next node...\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        }\n        return null;\n    }",
      "line_number": 358,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "lpValue",
        "currConsumerNode.lvNext",
        "lvNext",
        "nextNode.lpValue",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        final LinkedQueueAtomicNode<E> currConsumerNode = lpConsumerNode();\n        LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        } else if (currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n            // got the next node...\n            return nextNode.lpValue();\n        }\n        return null;\n    }",
      "line_number": 390,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spinWaitForNextNode",
      "signature": "LinkedQueueAtomicNode<E> spinWaitForNextNode(LinkedQueueAtomicNode<E> currNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait"
      ],
      "dependencies": [
        "lvNext",
        "currNode.lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 16,
      "source_code": "        LinkedQueueAtomicNode<E> nextNode;\n        while ((nextNode = currNode.lvNext()) == null) {\n            // spin, we are no longer wait free\n        }\n        return nextNode;\n    }",
      "line_number": 403,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        final LinkedQueueAtomicNode<E> currConsumerNode = lpConsumerNode();\n        final LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        }\n        return null;\n    }",
      "line_number": 412,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lpValue",
        "lvNext",
        "nextNode.lpValue",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "        final LinkedQueueAtomicNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        }\n        return null;\n    }",
      "line_number": 422,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "this.lpConsumerNode",
        "accept",
        "E",
        "lvNext",
        "c.accept",
        "IllegalArgumentException",
        "chaserNode.lvNext",
        "lpConsumerNode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueAtomicNode<E> chaserNode = this.lpConsumerNode();\n        for (int i = 0; i < limit; i++) {\n            final LinkedQueueAtomicNode<E> nextNode = chaserNode.lvNext();\n            if (nextNode == null) {\n                return i;\n            }\n            // we have to null out the value because we are going to hang on to the node\n            final E nextValue = getSingleConsumerNodeValue(chaserNode, nextNode);\n            chaserNode = nextNode;\n            c.accept(nextValue);\n        }\n        return limit;\n    }",
      "line_number": 436,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 463,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public final Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/AtomicReferenceArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "WeakIterator",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final long cIndex = lvConsumerIndex();\n        final long pIndex = lvProducerIndex();\n\n        return new WeakIterator(cIndex, pIndex, mask, buffer);\n    }",
      "line_number": 104,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "AtomicReferenceArrayQueue",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/AtomicReferenceArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "            final E e = nextElement;\n            if (e == null)\n                throw new NoSuchElementException();\n            nextElement = getNext();\n            return e;\n        }",
      "line_number": 138,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "AtomicReferenceArrayQueue",
      "method_type": "method"
    },
    {
      "name": "getNext",
      "signature": "private E getNext() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/AtomicReferenceArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "            final int mask = this.mask;\n            final AtomicReferenceArray<E> buffer = this.buffer;\n            while (nextIndex < pIndex) {\n                int offset = calcCircularRefElementOffset(nextIndex++, mask);\n                E e = lvRefElement(buffer, offset);\n                if (e != null) {\n                    return e;\n                }\n            }\n            return null;\n        }",
      "line_number": 146,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicReferenceArrayQueue",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 94,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 98,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 102,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 181,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casConsumerIndex",
      "signature": "final boolean casConsumerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "C_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return C_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 185,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndexCache",
      "signature": "protected final long lvProducerIndexCache() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndexCache;\n    }",
      "line_number": 263,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "svProducerIndexCache",
      "signature": "protected final void svProducerIndexCache(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        producerIndexCache = newValue;\n    }",
      "line_number": 267,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpmcAtomicArrayQueue",
      "signature": "public SpmcAtomicArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(capacity);\n    }",
      "line_number": 337,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "wait",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long currProducerIndex = lvProducerIndex();\n        final int offset = calcCircularRefElementOffset(currProducerIndex, mask);\n        if (null != lvRefElement(buffer, offset)) {\n            long size = currProducerIndex - lvConsumerIndex();\n            if (size > mask) {\n                return false;\n            } else {\n                // Bubble: This can happen because `poll` moves index before placing element.\n                // spin wait for slot to clear, buggers wait freedom\n                while (null != lvRefElement(buffer, offset)) {\n                    // BURN\n                }\n            }\n        }\n        soRefElement(buffer, offset, e);\n        // single producer, so store ordered is valid. It is also required to correctly publish the element\n        // and for the consumers to pick up the tail value.\n        soProducerIndex(currProducerIndex + 1);\n        return true;\n    }",
      "line_number": 342,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 6,
      "source_code": "        long currentConsumerIndex;\n        long currProducerIndexCache = lvProducerIndexCache();\n        do {\n            currentConsumerIndex = lvConsumerIndex();\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return null;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n        } while (!casConsumerIndex(currentConsumerIndex, currentConsumerIndex + 1));\n        // consumers are gated on latest visible tail, and so can't see a null value in the queue or overtake\n        // and wrap to hit same location.\n        return removeElement(buffer, currentConsumerIndex, mask);\n    }",
      "line_number": 370,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "removeElement",
      "signature": "private E removeElement(final AtomicReferenceArray<E> buffer, long index, final int mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "wait",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final int offset = calcCircularRefElementOffset(index, mask);\n        // load plain, element happens before it's index becomes visible\n        final E e = lpRefElement(buffer, offset);\n        // store ordered, make sure nulling out is visible. Producer is waiting for this value.\n        soRefElement(buffer, offset, null);\n        return e;\n    }",
      "line_number": 390,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long currProducerIndexCache = lvProducerIndexCache();\n        long currentConsumerIndex;\n        long nextConsumerIndex = lvConsumerIndex();\n        E e;\n        do {\n            currentConsumerIndex = nextConsumerIndex;\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return null;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n            e = lvRefElement(buffer, calcCircularRefElementOffset(currentConsumerIndex, mask));\n            // sandwich the element load between 2 consumer index loads\n            nextConsumerIndex = lvConsumerIndex();\n        } while (null == e || nextConsumerIndex != currentConsumerIndex);\n        return e;\n    }",
      "line_number": 400,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long producerIndex = lpProducerIndex();\n        final int offset = calcCircularRefElementOffset(producerIndex, mask);\n        if (null != lvRefElement(buffer, offset)) {\n            return false;\n        }\n        soRefElement(buffer, offset, e);\n        // single producer, so store ordered is valid. It is also required to correctly publish the element\n        // and for the consumers to pick up the tail value.\n        soProducerIndex(producerIndex + 1);\n        return true;\n    }",
      "line_number": 426,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long currentConsumerIndex;\n        long nextConsumerIndex = lvConsumerIndex();\n        E e;\n        do {\n            currentConsumerIndex = nextConsumerIndex;\n            e = lvRefElement(buffer, calcCircularRefElementOffset(currentConsumerIndex, mask));\n            // sandwich the element load between 2 consumer index loads\n            nextConsumerIndex = lvConsumerIndex();\n        } while (nextConsumerIndex != currentConsumerIndex);\n        return e;\n    }",
      "line_number": 450,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "accept",
        "min",
        "c.accept",
        "Math.min",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object"
      ],
      "complexity_score": 17,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long currProducerIndexCache = lvProducerIndexCache();\n        int adjustedLimit = 0;\n        long currentConsumerIndex;\n        do {\n            currentConsumerIndex = lvConsumerIndex();\n            // is there any space in the queue?\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return 0;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n            // try and claim up to 'limit' elements in one go\n            int remaining = (int) (currProducerIndexCache - currentConsumerIndex);\n            adjustedLimit = Math.min(remaining, limit);\n        } while (!casConsumerIndex(currentConsumerIndex, currentConsumerIndex + adjustedLimit));\n        for (int i = 0; i < adjustedLimit; i++) {\n            c.accept(removeElement(buffer, currentConsumerIndex + i, mask));\n        }\n        return adjustedLimit;\n    }",
      "line_number": 466,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "get",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long producerIndex = this.lpProducerIndex();\n        for (int i = 0; i < limit; i++) {\n            final int offset = calcCircularRefElementOffset(producerIndex, mask);\n            if (null != lvRefElement(buffer, offset)) {\n                return i;\n            }\n            producerIndex++;\n            soRefElement(buffer, offset, s.get());\n            // ordered store -> atomic and ordered for size()\n            soProducerIndex(producerIndex);\n        }\n        return limit;\n    }",
      "line_number": 501,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return MessagePassingQueueUtil.drain(this, c);\n    }",
      "line_number": 525,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return fill(s, capacity());\n    }",
      "line_number": 530,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(final Consumer<E> c, final WaitStrategy w, final ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 535,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(final Supplier<E> s, final WaitStrategy w, final ExitCondition e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, w, e);\n    }",
      "line_number": 540,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscLinkedAtomicQueue",
      "signature": "public SpscLinkedAtomicQueue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "node.soNext",
        "soNext",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        LinkedQueueAtomicNode<E> node = newNode();\n        spProducerNode(node);\n        spConsumerNode(node);\n        // this ensures correct construction: StoreStore\n        node.soNext(null);\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "soNext",
        "oldNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final LinkedQueueAtomicNode<E> nextNode = newNode(e);\n        LinkedQueueAtomicNode<E> oldNode = lpProducerNode();\n        soProducerNode(nextNode);\n        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed\n        // and completes the store in prev.next. This is a \"bubble\".\n        // Inverting the order here will break the `isEmpty` invariant, and will require matching adjustments elsewhere.\n        oldNode.soNext(nextNode);\n        return true;\n    }",
      "line_number": 64,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "spNext",
        "get",
        "tail.spNext",
        "s.get",
        "IllegalArgumentException",
        "soNext",
        "oldPNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueAtomicNode<E> tail = newNode(s.get());\n        final LinkedQueueAtomicNode<E> head = tail;\n        for (int i = 1; i < limit; i++) {\n            final LinkedQueueAtomicNode<E> temp = newNode(s.get());\n            // spNext : soProducerNode ensures correct construction\n            tail.spNext(temp);\n            tail = temp;\n        }\n        final LinkedQueueAtomicNode<E> oldPNode = lpProducerNode();\n        soProducerNode(tail);\n        // same bubble as offer, and for the same reasons.\n        oldPNode.soNext(head);\n        return limit;\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 107,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 93,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 97,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 176,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casConsumerIndex",
      "signature": "final boolean casConsumerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "C_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return C_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpmcAtomicArrayQueue",
      "signature": "public MpmcAtomicArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "Math.max",
        "RangeUtil.checkGreaterThanOrEqual",
        "min",
        "max",
        "Math.min"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(RangeUtil.checkGreaterThanOrEqual(capacity, 2, \"capacity\"));\n        lookAheadStep = Math.max(2, Math.min(capacity() / 4, MAX_LOOK_AHEAD_STEP));\n    }",
      "line_number": 275,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        long pIndex;\n        int seqOffset;\n        long seq;\n        // start with bogus value, hope we don't need it\n        long cIndex = Long.MIN_VALUE;\n        do {\n            pIndex = lvProducerIndex();\n            seqOffset = calcCircularLongElementOffset(pIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            // consumer has not moved this seq forward, it's as last producer left\n            if (seq < pIndex) {\n                // Extra check required to ensure [Queue.offer == false iff queue is full]\n                if (// test against cached cIndex\n                pIndex - capacity >= cIndex && // test against latest cIndex\n                pIndex - capacity >= (cIndex = lvConsumerIndex())) {\n                    return false;\n                } else {\n                    // (+) hack to make it go around again without CAS\n                    seq = pIndex + 1;\n                }\n            }\n        } while (// another producer has moved the sequence(or +)\n        seq > pIndex || // failed to increment\n        !casProducerIndex(pIndex, pIndex + 1));\n        // casProducerIndex ensures correct construction\n        spRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), e);\n        // seq++;\n        soLongElement(sBuffer, seqOffset, pIndex + 1);\n        return true;\n    }",
      "line_number": 281,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicLong",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "poll",
        "Queue.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        long seq;\n        int seqOffset;\n        long expectedSeq;\n        // start with bogus value, hope we don't need it\n        long pIndex = -1;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                // slot has not been moved by producer\n                if (// test against cached pIndex\n                cIndex >= pIndex && // update pIndex if we must\n                cIndex == (pIndex = lvProducerIndex())) {\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                } else {\n                    // trip another go around\n                    seq = expectedSeq + 1;\n                }\n            }\n        } while (// another consumer beat us to it\n        seq > expectedSeq || // failed the CAS\n        !casConsumerIndex(cIndex, cIndex + 1));\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        final E e = lpRefElement(buffer, offset);\n        spRefElement(buffer, offset, null);\n        // i.e. seq += capacity\n        soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n        return e;\n    }",
      "line_number": 326,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicLong",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "poll",
        "Queue.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        long seq;\n        int seqOffset;\n        long expectedSeq;\n        // start with bogus value, hope we don't need it\n        long pIndex = -1;\n        E e;\n        while (true) {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                // slot has not been moved by producer\n                if (// test against cached pIndex\n                cIndex >= pIndex && // update pIndex if we must\n                cIndex == (pIndex = lvProducerIndex())) {\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                }\n            } else if (seq == expectedSeq) {\n                final int offset = calcCircularRefElementOffset(cIndex, mask);\n                e = lvRefElement(buffer, offset);\n                if (lvConsumerIndex() == cIndex)\n                    return e;\n            }\n        }\n    }",
      "line_number": 365,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        long pIndex;\n        int seqOffset;\n        long seq;\n        do {\n            pIndex = lvProducerIndex();\n            seqOffset = calcCircularLongElementOffset(pIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            if (seq < pIndex) {\n                // slot not cleared by consumer yet\n                return false;\n            }\n        } while (// another producer has moved the sequence\n        seq > pIndex || // failed to increment\n        !casProducerIndex(pIndex, pIndex + 1));\n        // casProducerIndex ensures correct construction\n        spRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), e);\n        soLongElement(sBuffer, seqOffset, pIndex + 1);\n        return true;\n    }",
      "line_number": 399,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        int seqOffset;\n        long seq;\n        long expectedSeq;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                return null;\n            }\n        } while (// another consumer beat us to it\n        seq > expectedSeq || // failed the CAS\n        !casConsumerIndex(cIndex, cIndex + 1));\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        final E e = lpRefElement(buffer, offset);\n        spRefElement(buffer, offset, null);\n        soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n        return e;\n    }",
      "line_number": 426,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicLong",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        long seq;\n        int seqOffset;\n        long expectedSeq;\n        E e;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                return null;\n            } else if (seq == expectedSeq) {\n                final int offset = calcCircularRefElementOffset(cIndex, mask);\n                e = lvRefElement(buffer, offset);\n                if (lvConsumerIndex() == cIndex)\n                    return e;\n            }\n        } while (true);\n    }",
      "line_number": 452,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "accept",
        "min",
        "c.accept",
        "Math.min",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int maxLookAheadStep = Math.min(this.lookAheadStep, limit);\n        int consumed = 0;\n        while (consumed < limit) {\n            final int remaining = limit - consumed;\n            final int lookAheadStep = Math.min(remaining, maxLookAheadStep);\n            final long cIndex = lvConsumerIndex();\n            final long lookAheadIndex = cIndex + lookAheadStep - 1;\n            final int lookAheadSeqOffset = calcCircularLongElementOffset(lookAheadIndex, mask);\n            final long lookAheadSeq = lvLongElement(sBuffer, lookAheadSeqOffset);\n            final long expectedLookAheadSeq = lookAheadIndex + 1;\n            if (lookAheadSeq == expectedLookAheadSeq && casConsumerIndex(cIndex, expectedLookAheadSeq)) {\n                for (int i = 0; i < lookAheadStep; i++) {\n                    final long index = cIndex + i;\n                    final int seqOffset = calcCircularLongElementOffset(index, mask);\n                    final int offset = calcCircularRefElementOffset(index, mask);\n                    final long expectedSeq = index + 1;\n                    while (lvLongElement(sBuffer, seqOffset) != expectedSeq) {\n                    }\n                    final E e = lpRefElement(buffer, offset);\n                    spRefElement(buffer, offset, null);\n                    soLongElement(sBuffer, seqOffset, index + mask + 1);\n                    c.accept(e);\n                }\n                consumed += lookAheadStep;\n            } else {\n                if (lookAheadSeq < expectedLookAheadSeq) {\n                    if (notAvailable(cIndex, mask, sBuffer, cIndex + 1)) {\n         ",
      "line_number": 478,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drainOneByOne",
      "signature": "private int drainOneByOne(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        long cIndex;\n        int seqOffset;\n        long seq;\n        long expectedSeq;\n        for (int i = 0; i < limit; i++) {\n            do {\n                cIndex = lvConsumerIndex();\n                seqOffset = calcCircularLongElementOffset(cIndex, mask);\n                seq = lvLongElement(sBuffer, seqOffset);\n                expectedSeq = cIndex + 1;\n                if (seq < expectedSeq) {\n                    return i;\n                }\n            } while (// another consumer beat us to it\n            seq > expectedSeq || // failed the CAS\n            !casConsumerIndex(cIndex, cIndex + 1));\n            final int offset = calcCircularRefElementOffset(cIndex, mask);\n            final E e = lpRefElement(buffer, offset);\n            spRefElement(buffer, offset, null);\n            soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 524,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int maxLookAheadStep = Math.min(this.lookAheadStep, limit);\n        int produced = 0;\n        while (produced < limit) {\n            final int remaining = limit - produced;\n            final int lookAheadStep = Math.min(remaining, maxLookAheadStep);\n            final long pIndex = lvProducerIndex();\n            final long lookAheadIndex = pIndex + lookAheadStep - 1;\n            final int lookAheadSeqOffset = calcCircularLongElementOffset(lookAheadIndex, mask);\n            final long lookAheadSeq = lvLongElement(sBuffer, lookAheadSeqOffset);\n            final long expectedLookAheadSeq = lookAheadIndex;\n            if (lookAheadSeq == expectedLookAheadSeq && casProducerIndex(pIndex, expectedLookAheadSeq + 1)) {\n                for (int i = 0; i < lookAheadStep; i++) {\n                    final long index = pIndex + i;\n                    final int seqOffset = calcCircularLongElementOffset(index, mask);\n                    final int offset = calcCircularRefElementOffset(index, mask);\n                    while (lvLongElement(sBuffer, seqOffset) != index) {\n                    }\n                    // Ordered store ensures correct construction\n                    soRefElement(buffer, offset, s.get());\n                    soLongElement(sBuffer, seqOffset, index + 1);\n                }\n                produced += lookAheadStep;\n            } else {\n                if (lookAheadSeq < expectedLookAheadSeq) {\n                    if (notAvailable(pIndex, mask, sBuffer, pIndex)) {\n                        return produced;\n                    }\n                }\n                retur",
      "line_number": 554,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "notAvailable",
      "signature": "private boolean notAvailable(long index, int mask, AtomicLongArray sBuffer, long expectedSeq) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final int seqOffset = calcCircularLongElementOffset(index, mask);\n        final long seq = lvLongElement(sBuffer, seqOffset);\n        if (seq < expectedSeq) {\n            return true;\n        }\n        return false;\n    }",
      "line_number": 598,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fillOneByOne",
      "signature": "private int fillOneByOne(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        long pIndex;\n        int seqOffset;\n        long seq;\n        for (int i = 0; i < limit; i++) {\n            do {\n                pIndex = lvProducerIndex();\n                seqOffset = calcCircularLongElementOffset(pIndex, mask);\n                seq = lvLongElement(sBuffer, seqOffset);\n                if (seq < pIndex) {\n                    // slot not cleared by consumer yet\n                    return i;\n                }\n            } while (// another producer has moved the sequence\n            seq > pIndex || // failed to increment\n            !casProducerIndex(pIndex, pIndex + 1));\n            // Ordered store ensures correct construction\n            soRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), s.get());\n            soLongElement(sBuffer, seqOffset, pIndex + 1);\n        }\n        return limit;\n    }",
      "line_number": 607,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 644,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 649,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscChunkedAtomicArrayQueue",
      "signature": "public SpscChunkedAtomicArrayQueue(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscChunkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Math.max",
        "max",
        "Pow2.roundToPowerOfTwo",
        "roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        this(Math.max(8, Pow2.roundToPowerOfTwo(capacity / 8)), capacity);\n    }",
      "line_number": 38,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscChunkedAtomicArrayQueue",
      "signature": "public SpscChunkedAtomicArrayQueue(int chunkSize, int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscChunkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkLessThan",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "checkLessThan",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(capacity, 16, \"capacity\");\n        // minimal chunk size of eight makes sure minimal lookahead step is 2\n        RangeUtil.checkGreaterThanOrEqual(chunkSize, 8, \"chunkSize\");\n        maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);\n        int chunkCapacity = Pow2.roundToPowerOfTwo(chunkSize);\n        RangeUtil.checkLessThan(chunkCapacity, maxQueueCapacity, \"chunkCapacity\");\n        long mask = chunkCapacity - 1;\n        // need extra element to point at next array\n        AtomicReferenceArray<E> buffer = allocateRefArray(chunkCapacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        producerBufferLimit = mask - 1;\n        producerQueueLimit = maxQueueCapacity;\n    }",
      "line_number": 42,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(AtomicReferenceArray<E> buffer, long mask, long pIndex, int offset, E v, Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscChunkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        // use a fixed lookahead step based on buffer capacity\n        final long lookAheadStep = (mask + 1) / 4;\n        long pBufferLimit = pIndex + lookAheadStep;\n        long pQueueLimit = producerQueueLimit;\n        if (pIndex >= pQueueLimit) {\n            // we tested against a potentially out of date queue limit, refresh it\n            final long cIndex = lvConsumerIndex();\n            producerQueueLimit = pQueueLimit = cIndex + maxQueueCapacity;\n            // if we're full we're full\n            if (pIndex >= pQueueLimit) {\n                return false;\n            }\n        }\n        // if buffer limit is after queue limit we use queue limit. We need to handle overflow so\n        // cannot use Math.min\n        if (pBufferLimit - pQueueLimit > 0) {\n            pBufferLimit = pQueueLimit;\n        }\n        // go around the buffer or add a new buffer\n        if (// there's sufficient room in buffer/queue to use pBufferLimit\n        pBufferLimit > pIndex + 1 && null == lvRefElement(buffer, calcCircularRefElementOffset(pBufferLimit, mask))) {\n            // joy, there's plenty of room\n            producerBufferLimit = pBufferLimit - 1;\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else if (null == lvRefElement(buffer, calcCircularRefElementOffset(pIndex + 1, mask))) {\n            // buffer is not full\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else {\n            // we got one slot left to write into, and we are not full. Need to link new buffer.\n            // allocate new buffer of same length\n            final AtomicReferenceArray<E> newBuffer = allocateRefArray((int) (mask + 2));\n            producerBuffer = newBuffer;\n            linkOldToNew(pIndex, buffer, offset, newBuffer, offset, v == null ? s.get() : v);\n        }\n        return true;\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscUnboundedAtomicArrayQueue",
      "signature": "public SpscUnboundedAtomicArrayQueue(int chunkSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscUnboundedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "Math.max",
        "max",
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        int chunkCapacity = Math.max(Pow2.roundToPowerOfTwo(chunkSize), 16);\n        long mask = chunkCapacity - 1;\n        AtomicReferenceArray<E> buffer = allocateRefArray(chunkCapacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        producerBufferLimit = mask - 1;\n    }",
      "line_number": 33,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(AtomicReferenceArray<E> buffer, long mask, long pIndex, int offset, E v, Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscUnboundedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        // use a fixed lookahead step based on buffer capacity\n        final long lookAheadStep = (mask + 1) / 4;\n        long pBufferLimit = pIndex + lookAheadStep;\n        // go around the buffer or add a new buffer\n        if (null == lvRefElement(buffer, calcCircularRefElementOffset(pBufferLimit, mask))) {\n            // joy, there's plenty of room\n            producerBufferLimit = pBufferLimit - 1;\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else if (null == lvRefElement(buffer, calcCircularRefElementOffset(pIndex + 1, mask))) {\n            // buffer is not full\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else {\n            // we got one slot left to write into, and we are not full. Need to link new buffer.\n            // allocate new buffer of same length\n            final AtomicReferenceArray<E> newBuffer = allocateRefArray((int) (mask + 2));\n            producerBuffer = newBuffer;\n            producerBufferLimit = pIndex + mask - 1;\n            linkOldToNew(pIndex, buffer, offset, newBuffer, offset, v == null ? s.get() : v);\n        }\n        return true;\n    }",
      "line_number": 46,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 93,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 97,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 176,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 184,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerLimit",
      "signature": "final long lvProducerLimit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerLimit;\n    }",
      "line_number": 258,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerLimit",
      "signature": "final boolean casProducerLimit(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "P_LIMIT_UPDATER.compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_LIMIT_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 262,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerLimit",
      "signature": "final void soProducerLimit(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_LIMIT_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_LIMIT_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 266,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "BaseMpscLinkedAtomicArrayQueue",
      "signature": "public BaseMpscLinkedAtomicArrayQueue(final int initialCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(initialCapacity, 2, \"initialCapacity\");\n        int p2capacity = Pow2.roundToPowerOfTwo(initialCapacity);\n        // leave lower bit of mask clear\n        long mask = (p2capacity - 1) << 1;\n        // need extra element to point at next array\n        AtomicReferenceArray<E> buffer = allocateRefArray(p2capacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        soProducerLimit(mask);\n    }",
      "line_number": 298,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 328,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        long mask;\n        AtomicReferenceArray<E> buffer;\n        long pIndex;\n        while (true) {\n            long producerLimit = lvProducerLimit();\n            pIndex = lvProducerIndex();\n            // lower bit is indicative of resize, if we see it we spin until it's cleared\n            if ((pIndex & 1) == 1) {\n                continue;\n            }\n            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1)\n            // mask/buffer may get changed by resizing -> only use for array access after successful CAS.\n            mask = this.producerMask;\n            buffer = this.producerBuffer;\n            // a successful CAS ties the ordering, lv(pIndex) - [mask/buffer] -> cas(pIndex)\n            // assumption behind this optimization is that queue is almost always empty or near empty\n            if (producerLimit <= pIndex) {\n                int result = offerSlowPath(mask, pIndex, producerLimit);\n                switch(result) {\n                    case CONTINUE_TO_P_INDEX_CAS:\n                        break;\n                    case RETRY:\n                        continue;\n                    case QUEUE_FULL:\n                        return false;\n                    case QUEUE_RESIZE:\n                        resize(mask, buffer, pIndex, e, null);\n                        return true;\n                }\n            }\n            if (casProducerIndex(pIndex, pIndex + 2)) {\n                break;\n            }\n        }\n        // INDEX visible before ELEMENT\n        final int offset = modifiedCalcCircularRefElementOffset(pIndex, mask);\n        // release element e\n        soRefElement(buffer, offset, e);\n        return true;\n    }",
      "line_number": 333,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            long pIndex = lvProducerIndex();\n            // isEmpty?\n            if ((cIndex - pIndex) / 2 == 0) {\n                return null;\n            }\n            // poll() == null iff queue is empty, null element is not strong enough indicator, so we must\n            // spin until element is visible.\n            do {\n                e = lvRefElement(buffer, offset);\n            } while (e == null);\n        }\n        if (e == JUMP) {\n            final AtomicReferenceArray<E> nextBuffer = nextBuffer(buffer, mask);\n            return newBufferPoll(nextBuffer, cIndex);\n        }\n        // release element null\n        soRefElement(buffer, offset, null);\n        // release cIndex\n        soConsumerIndex(cIndex + 2);\n        return (E) e;\n    }",
      "line_number": 385,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            long pIndex = lvProducerIndex();\n            // isEmpty?\n            if ((cIndex - pIndex) / 2 == 0) {\n                return null;\n            }\n            // peek() == null iff queue is empty, null element is not strong enough indicator, so we must\n            // spin until element is visible.\n            do {\n                e = lvRefElement(buffer, offset);\n            } while (e == null);\n        }\n        if (e == JUMP) {\n            return newBufferPeek(nextBuffer(buffer, mask), cIndex);\n        }\n        return (E) e;\n    }",
      "line_number": 421,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerSlowPath",
      "signature": "private int offerSlowPath(long mask, long pIndex, long producerLimit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final long cIndex = lvConsumerIndex();\n        long bufferCapacity = getCurrentBufferCapacity(mask);\n        if (cIndex + bufferCapacity > pIndex) {\n            if (!casProducerLimit(producerLimit, cIndex + bufferCapacity)) {\n                // retry from top\n                return RETRY;\n            } else {\n                // continue to pIndex CAS\n                return CONTINUE_TO_P_INDEX_CAS;\n            }\n        } else // full and cannot grow\n        if (availableInQueue(pIndex, cIndex) <= 0) {\n            // offer should return false;\n            return QUEUE_FULL;\n        } else // grab index for resize -> set lower bit\n        if (casProducerIndex(pIndex, pIndex + 1)) {\n            // trigger a resize\n            return QUEUE_RESIZE;\n        } else {\n            // failed resize attempt, retry from top\n            return RETRY;\n        }\n    }",
      "line_number": 448,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "nextBuffer",
      "signature": "private AtomicReferenceArray<E> nextBuffer(final AtomicReferenceArray<E> buffer, final long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final int offset = nextArrayOffset(mask);\n        final AtomicReferenceArray<E> nextBuffer = (AtomicReferenceArray<E>) lvRefElement(buffer, offset);\n        consumerBuffer = nextBuffer;\n        consumerMask = (length(nextBuffer) - 2) << 1;\n        soRefElement(buffer, offset, BUFFER_CONSUMED);\n        return nextBuffer;\n    }",
      "line_number": 479,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "nextArrayOffset",
      "signature": "private static int nextArrayOffset(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return modifiedCalcCircularRefElementOffset(mask + 2, Long.MAX_VALUE);\n    }",
      "line_number": 488,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPoll",
      "signature": "private E newBufferPoll(AtomicReferenceArray<E> nextBuffer, long cIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalStateException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final int offset = modifiedCalcCircularRefElementOffset(cIndex, consumerMask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (n == null) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        }\n        soRefElement(nextBuffer, offset, null);\n        soConsumerIndex(cIndex + 2);\n        return n;\n    }",
      "line_number": 492,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPeek",
      "signature": "private E newBufferPeek(AtomicReferenceArray<E> nextBuffer, long cIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalStateException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final int offset = modifiedCalcCircularRefElementOffset(cIndex, consumerMask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (null == n) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        }\n        return n;\n    }",
      "line_number": 503,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            return null;\n        }\n        if (e == JUMP) {\n            final AtomicReferenceArray<E> nextBuffer = nextBuffer(buffer, mask);\n            return newBufferPoll(nextBuffer, cIndex);\n        }\n        soRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 2);\n        return (E) e;\n    }",
      "line_number": 532,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == JUMP) {\n            return newBufferPeek(nextBuffer(buffer, mask), cIndex);\n        }\n        return (E) e;\n    }",
      "line_number": 552,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        // result is a long because we want to have a safepoint check at regular intervals\n        long result = 0;\n        final int capacity = capacity();\n        do {\n            final int filled = fill(s, PortableJvmInfo.RECOMENDED_OFFER_BATCH);\n            if (filled == 0) {\n                return (int) result;\n            }\n            result += filled;\n        } while (result <= capacity);\n        return (int) result;\n    }",
      "line_number": 565,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        long mask;\n        AtomicReferenceArray<E> buffer;\n        long pIndex;\n        int claimedSlots;\n        while (true) {\n            long producerLimit = lvProducerLimit();\n            pIndex = lvProducerIndex();\n            // lower bit is indicative of resize, if we see it we spin until it's cleared\n            if ((pIndex & 1) == 1) {\n                continue;\n            }\n            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1)\n            // NOTE: mask/buffer may get changed by resizing -> only use for array access after successful CAS.\n            // Only by virtue offloading them between the lvProducerIndex and a successful casProducerIndex are they\n            // safe to use.\n            mask = this.producerMask;\n            buffer = this.producerBuffer;\n            // a successful CAS ties the ordering, lv(pIndex) -> [mask/buffer] -> cas(pIndex)\n            // we want 'limit' slots, but will settle for whatever is visible to 'producerLimit'\n            // -> producerLimit >= batchIndex\n            long batchIndex = Math.min(producerLimit, pIndex + 2l * limit);\n            if (pIndex >= producerLimit) {\n                int result = offerSlowPath(mask, pIndex, producerLimit);\n                switch(result) {\n                    case CONTINUE_TO_P_INDEX_CAS:\n                    // offer slow path verifies only one slot ahead, we cannot rely on indication here\n                    case RETRY:\n                        continue;\n                    case QUEUE_FULL:\n                        return 0;\n                    case QUEUE_RESIZE:\n                        resize(mask, buffer, pIndex, null, s);\n                        return 1;\n                }\n            }\n            // claim limit slots at o",
      "line_number": 580,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 636,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 651,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            final E e = nextElement;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n            nextElement = getNext();\n            return e;\n        }",
      "line_number": 704,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "setBuffer",
      "signature": "private void setBuffer(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            this.currentBuffer = buffer;\n            this.mask = length(buffer) - 2;\n        }",
      "line_number": 713,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNext",
      "signature": "private E getNext() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "            while (nextIndex < pIndex) {\n                long index = nextIndex++;\n                E e = lvRefElement(currentBuffer, calcCircularRefElementOffset(index, mask));\n                // skip removed/not yet visible elements\n                if (e == null) {\n                    continue;\n                }\n                // not null && not JUMP -> found next element\n                if (e != JUMP) {\n                    return e;\n                }\n                // need to jump to the next buffer\n                int nextBufferIndex = mask + 1;\n                Object nextBuffer = lvRefElement(currentBuffer, calcRefElementOffset(nextBufferIndex));\n                if (nextBuffer == BUFFER_CONSUMED || nextBuffer == null) {\n                    // Consumer may have passed us, or the next buffer is not visible yet: drop out early\n                    return null;\n                }\n                setBuffer((AtomicReferenceArray<E>) nextBuffer);\n                // now with the new array retry the load, it can't be a JUMP, but we need to repeat same index\n                e = lvRefElement(currentBuffer, calcCircularRefElementOffset(index, mask));\n                // skip removed/not yet visible elements\n                if (e == null) {\n                    continue;\n                } else {\n                    return e;\n                }\n            }\n            return null;\n        }",
      "line_number": 718,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private void resize(long oldMask, AtomicReferenceArray<E> oldBuffer, long pIndex, E e, Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseMpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "RangeUtil.checkPositive",
        "checkPositive",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        assert (e != null && s == null) || (e == null || s != null);\n        int newBufferLength = getNextBufferSize(oldBuffer);\n        final AtomicReferenceArray<E> newBuffer;\n        try {\n            newBuffer = allocateRefArray(newBufferLength);\n        } catch (OutOfMemoryError oom) {\n            assert lvProducerIndex() == pIndex + 1;\n            soProducerIndex(pIndex);\n            throw oom;\n        }\n        producerBuffer = newBuffer;\n        final int newMask = (newBufferLength - 2) << 1;\n        producerMask = newMask;\n        final int offsetInOld = modifiedCalcCircularRefElementOffset(pIndex, oldMask);\n        final int offsetInNew = modifiedCalcCircularRefElementOffset(pIndex, newMask);\n        // element in new array\n        soRefElement(newBuffer, offsetInNew, e == null ? s.get() : e);\n        // buffer linked\n        soRefElement(oldBuffer, nextArrayOffset(oldMask), newBuffer);\n        // ASSERT code\n        final long cIndex = lvConsumerIndex();\n        final long availableInQueue = availableInQueue(pIndex, cIndex);\n        RangeUtil.checkPositive(availableInQueue, \"availableInQueue\");\n        // Invalidate racing CASs\n        // We never set the limit beyond the bounds of a buffer\n        soProducerLimit(pIndex + Math.min(newMask, availableInQueue));\n        // make resize visible to the other producers\n        soProducerIndex(pIndex + 2);\n        // INDEX visible before ELEMENT, consistent with consumer expectation\n        // make resize visible to consumer\n        soRefElement(oldBuffer, offsetInOld, JUMP);\n    }",
      "line_number": 751,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscGrowableAtomicArrayQueue",
      "signature": "public SpscGrowableAtomicArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max",
        "Pow2.roundToPowerOfTwo",
        "roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        this(Math.max(8, Pow2.roundToPowerOfTwo(capacity / 8)), capacity);\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscGrowableAtomicArrayQueue",
      "signature": "public SpscGrowableAtomicArrayQueue(final int chunkSize, final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkLessThan",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "checkLessThan",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(capacity, 16, \"capacity\");\n        // minimal chunk size of eight makes sure minimal lookahead step is 2\n        RangeUtil.checkGreaterThanOrEqual(chunkSize, 8, \"chunkSize\");\n        maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);\n        int chunkCapacity = Pow2.roundToPowerOfTwo(chunkSize);\n        RangeUtil.checkLessThan(chunkCapacity, maxQueueCapacity, \"chunkCapacity\");\n        long mask = chunkCapacity - 1;\n        // need extra element to point at next array\n        AtomicReferenceArray<E> buffer = allocateRefArray(chunkCapacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        producerBufferLimit = mask - 1;\n        adjustLookAheadStep(chunkCapacity);\n    }",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(final AtomicReferenceArray<E> buffer, final long mask, final long index, final int offset, final E v, final Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        final long lookAheadStep = this.lookAheadStep;\n        // normal case, go around the buffer or resize if full (unless we hit max capacity)\n        if (lookAheadStep > 0) {\n            int lookAheadElementOffset = calcCircularRefElementOffset(index + lookAheadStep, mask);\n            // Try and look ahead a number of elements so we don't have to do this all the time\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                // joy, there's plenty of room\n                producerBufferLimit = index + lookAheadStep - 1;\n                writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n                return true;\n            }\n            // we're at max capacity, can use up last element\n            final int maxCapacity = maxQueueCapacity;\n            if (mask + 1 == maxCapacity) {\n                if (null == lvRefElement(buffer, offset)) {\n                    writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n                    return true;\n                }\n                // we're full and can't grow\n                return false;\n            }\n            // not at max capacity, so must allow extra slot for next buffer pointer\n            if (null == lvRefElement(buffer, calcCircularRefElementOffset(index + 1, mask))) {\n                // buffer is not full\n                writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n            } else {\n                // allocate new buffer of same length\n                final AtomicReferenceArray<E> newBuffer = allocateRefArray((int) (2 * (mask + 1) + 1));\n                producerBuffer = newBuffer;\n                producerMask = length(newBuffer) - 2;\n                final int offsetInNew = calcCircularRefElementOffset(index, producerMask);\n                linkOldToNew(index, buffer, offset, newBuffer, offsetInNew, v == null ? s.get() : v);\n                int newCapacity = (int) (producerMask + 1);\n                if (newCapacity == maxCapacity) {\n  ",
      "line_number": 64,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "adjustLookAheadStep",
      "signature": "private void adjustLookAheadStep(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "SpscLookAheadUtil.computeLookAheadStep",
        "computeLookAheadStep"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": "        lookAheadStep = SpscLookAheadUtil.computeLookAheadStep(capacity);\n    }",
      "line_number": 139,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscGrowableAtomicArrayQueue",
      "signature": "public MpscGrowableAtomicArrayQueue(int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Math.max",
        "max",
        "Pow2.roundToPowerOfTwo",
        "roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(Math.max(2, Pow2.roundToPowerOfTwo(maxCapacity / 8)), maxCapacity);\n    }",
      "line_number": 33,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscGrowableAtomicArrayQueue",
      "signature": "public MpscGrowableAtomicArrayQueue(int initialCapacity, int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(initialCapacity, maxCapacity);\n    }",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "RangeUtil.checkLessThanOrEqual",
        "checkLessThanOrEqual",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final long maxSize = maxQueueCapacity / 2;\n        RangeUtil.checkLessThanOrEqual(length(buffer), maxSize, \"buffer.length\");\n        final int newSize = 2 * (length(buffer) - 1);\n        return newSize + 1;\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscGrowableAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (mask + 2 == maxQueueCapacity) ? maxQueueCapacity : mask;\n    }",
      "line_number": 57,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 92,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 96,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerLimit",
      "signature": "final long lvProducerLimit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerLimit;\n    }",
      "line_number": 176,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerLimit",
      "signature": "final void soProducerLimit(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_LIMIT_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_LIMIT_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 257,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 261,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 265,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscAtomicArrayQueue",
      "signature": "public MpscAtomicArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(capacity);\n    }",
      "line_number": 343,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerIfBelowThreshold",
      "signature": "public boolean offerIfBelowThreshold(final E e, int threshold) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        do {\n            pIndex = lvProducerIndex();\n            long available = producerLimit - pIndex;\n            long size = capacity - available;\n            if (size >= threshold) {\n                final long cIndex = lvConsumerIndex();\n                size = pIndex - cIndex;\n                if (size >= threshold) {\n                    // the size exceeds threshold\n                    return false;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    producerLimit = cIndex + capacity;\n                    // this is racy, but the race is benign\n                    soProducerLimit(producerLimit);\n                }\n            }\n        } while (!casProducerIndex(pIndex, pIndex + 1));\n        /*\n         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on\n         * the index visibility to poll() we would need to handle the case where the element is not visible.\n         */\n        // Won CAS, move on to storing\n        final int offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return true;\n    }",
      "line_number": 355,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        // use a cached view on consumer index (potentially updated in loop)\n        final int mask = this.mask;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        do {\n            pIndex = lvProducerIndex();\n            if (pIndex >= producerLimit) {\n                final long cIndex = lvConsumerIndex();\n                producerLimit = cIndex + mask + 1;\n                if (pIndex >= producerLimit) {\n                    // FULL :(\n                    return false;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    // this is racy, but the race is benign\n                    soProducerLimit(producerLimit);\n                }\n            }\n        } while (!casProducerIndex(pIndex, pIndex + 1));\n        /*\n         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on\n         * the index visibility to poll() we would need to handle the case where the element is not visible.\n         */\n        // Won CAS, move on to storing\n        final int offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return true;\n    }",
      "line_number": 403,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "failFastOffer",
      "signature": "public final int failFastOffer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        final long pIndex = lvProducerIndex();\n        long producerLimit = lvProducerLimit();\n        if (pIndex >= producerLimit) {\n            final long cIndex = lvConsumerIndex();\n            producerLimit = cIndex + capacity;\n            if (pIndex >= producerLimit) {\n                // FULL :(\n                return 1;\n            } else {\n                // update producer limit to the next index that we must recheck the consumer index\n                soProducerLimit(producerLimit);\n            }\n        }\n        // look Ma, no loop!\n        if (!casProducerIndex(pIndex, pIndex + 1)) {\n            // CAS FAIL :(\n            return -1;\n        }\n        // Won CAS, move on to storing\n        final int offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return 0;\n    }",
      "line_number": 443,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        final long cIndex = lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        // Copy field to avoid re-reading after volatile load\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        // If we can't see the next available element we can't poll\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            /*\n             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after\n             * winning the CAS on offer but before storing the element in the queue. Other producers may go on\n             * to fill up the queue after this element.\n             */\n            if (cIndex != lvProducerIndex()) {\n                do {\n                    e = lvRefElement(buffer, offset);\n                } while (e == null);\n            } else {\n                return null;\n            }\n        }\n        spRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 1);\n        return e;\n    }",
      "line_number": 484,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        // Copy field to avoid re-reading after volatile load\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final long cIndex = lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            /*\n             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after\n             * winning the CAS on offer but before storing the element in the queue. Other producers may go on\n             * to fill up the queue after this element.\n             */\n            if (cIndex != lvProducerIndex()) {\n                do {\n                    e = lvRefElement(buffer, offset);\n                } while (e == null);\n            } else {\n                return null;\n            }\n        }\n        return e;\n    }",
      "line_number": 520,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final long cIndex = lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        // If we can't see the next available element we can't poll\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            return null;\n        }\n        spRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 1);\n        return e;\n    }",
      "line_number": 549,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long cIndex = lpConsumerIndex();\n        return lvRefElement(buffer, calcCircularRefElementOffset(cIndex, mask));\n    }",
      "line_number": 564,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long cIndex = lpConsumerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = cIndex + i;\n            final int offset = calcCircularRefElementOffset(index, mask);\n            final E e = lvRefElement(buffer, offset);\n            if (null == e) {\n                return i;\n            }\n            spRefElement(buffer, offset, null);\n            // ordered store -> atomic and ordered for size()\n            soConsumerIndex(index + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 572,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        int actualLimit;\n        do {\n            pIndex = lvProducerIndex();\n            long available = producerLimit - pIndex;\n            if (available <= 0) {\n                final long cIndex = lvConsumerIndex();\n                producerLimit = cIndex + capacity;\n                available = producerLimit - pIndex;\n                if (available <= 0) {\n                    // FULL :(\n                    return 0;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    soProducerLimit(producerLimit);\n                }\n            }\n            actualLimit = Math.min((int) available, limit);\n        } while (!casProducerIndex(pIndex, pIndex + actualLimit));\n        // right, now we claimed a few slots and can fill them with goodness\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        for (int i = 0; i < actualLimit; i++) {\n            // Won CAS, move on to storing\n            final int offset = calcCircularRefElementOffset(pIndex + i, mask);\n            soRefElement(buffer, offset, s.get());\n        }\n        return actualLimit;\n    }",
      "line_number": 598,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 648,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 653,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscChunkedAtomicArrayQueue",
      "signature": "public MpscChunkedAtomicArrayQueue(int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscChunkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(max(2, min(1024, roundToPowerOfTwo(maxCapacity / 8))), maxCapacity);\n    }",
      "line_number": 99,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscChunkedAtomicArrayQueue",
      "signature": "public MpscChunkedAtomicArrayQueue(int initialCapacity, int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscChunkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(initialCapacity, maxCapacity);\n    }",
      "line_number": 110,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscChunkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        return length(buffer);\n    }",
      "line_number": 125,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscChunkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return mask;\n    }",
      "line_number": 130,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscLinkedAtomicQueue",
      "signature": "public MpscLinkedAtomicQueue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        LinkedQueueAtomicNode<E> node = newNode();\n        spConsumerNode(node);\n        xchgProducerNode(node);\n    }",
      "line_number": 39,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "prevProducerNode.soNext",
        "NullPointerException",
        "soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final LinkedQueueAtomicNode<E> nextNode = newNode(e);\n        final LinkedQueueAtomicNode<E> prevProducerNode = xchgProducerNode(nextNode);\n        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed\n        // and completes the store in prev.next. This is a \"bubble\".\n        prevProducerNode.soNext(nextNode);\n        return true;\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "lpValue",
        "E",
        "currConsumerNode.soNext",
        "currConsumerNode.lpValue",
        "soNext",
        "equals",
        "o.equals",
        "prevConsumerNode.soNext",
        "currConsumerNode.spValue",
        "spValue"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 33,
      "source_code": "        if (null == o) {\n            // Null elements are not permitted, so null will never be removed.\n            return false;\n        }\n        final LinkedQueueAtomicNode<E> originalConsumerNode = lpConsumerNode();\n        LinkedQueueAtomicNode<E> prevConsumerNode = originalConsumerNode;\n        LinkedQueueAtomicNode<E> currConsumerNode = getNextConsumerNode(originalConsumerNode);\n        while (currConsumerNode != null) {\n            if (o.equals(currConsumerNode.lpValue())) {\n                LinkedQueueAtomicNode<E> nextNode = getNextConsumerNode(currConsumerNode);\n                // e.g.: consumerNode -> node0 -> node1(o==v) -> node2 ... => consumerNode -> node0 -> node2\n                if (nextNode != null) {\n                    // We are removing an interior node.\n                    prevConsumerNode.soNext(nextNode);\n                } else // This case reflects: prevConsumerNode != originalConsumerNode && nextNode == null\n                // At rest, this would be the producerNode, but we must contend with racing. Changes to subclassed\n                // queues need to consider remove() when implementing offer().\n                {\n                    // producerNode is currConsumerNode, try to atomically update the reference to move it to the\n                    // previous node.\n                    prevConsumerNode.soNext(null);\n                    if (!casProducerNode(currConsumerNode, prevConsumerNode)) {\n                        // If the producer(s) have offered more items we need to remove the currConsumerNode link.\n                        nextNode = spinWaitForNextNode(currConsumerNode);\n                        prevConsumerNode.soNext(nextNode);\n                    }\n                }\n                // Avoid GC nepotism because we are discarding the current node.\n                currConsumerNode.soNext(null);\n                currConsumerNode.spValue(null);\n                return true;\n            }\n            prevConsumerNode = currConsumerNode;\n  ",
      "line_number": 81,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "spNext",
        "get",
        "tail.spNext",
        "s.get",
        "IllegalArgumentException",
        "soNext",
        "oldPNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 21,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueAtomicNode<E> tail = newNode(s.get());\n        final LinkedQueueAtomicNode<E> head = tail;\n        for (int i = 1; i < limit; i++) {\n            final LinkedQueueAtomicNode<E> temp = newNode(s.get());\n            // spNext: xchgProducerNode ensures correct construction\n            tail.spNext(temp);\n            tail = temp;\n        }\n        final LinkedQueueAtomicNode<E> oldPNode = xchgProducerNode(tail);\n        oldPNode.soNext(head);\n        return limit;\n    }",
      "line_number": 126,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 147,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextConsumerNode",
      "signature": "private LinkedQueueAtomicNode<E> getNextConsumerNode(LinkedQueueAtomicNode<E> currConsumerNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode == null && currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n        }\n        return nextNode;\n    }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 112,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 116,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(final long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 120,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 198,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 202,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(final long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 206,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscAtomicArrayQueue",
      "signature": "public SpscAtomicArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(Math.max(capacity, 4));\n    }",
      "line_number": 289,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "this.lpProducerIndex",
        "lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long producerIndex = this.lpProducerIndex();\n        if (producerIndex >= producerLimit && !offerSlowPath(buffer, mask, producerIndex)) {\n            return false;\n        }\n        final int offset = calcCircularRefElementOffset(producerIndex, mask);\n        soRefElement(buffer, offset, e);\n        // ordered store -> atomic and ordered for size()\n        soProducerIndex(producerIndex + 1);\n        return true;\n    }",
      "line_number": 299,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerSlowPath",
      "signature": "private boolean offerSlowPath(final AtomicReferenceArray<E> buffer, final int mask, final long producerIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final int lookAheadStep = this.lookAheadStep;\n        if (null == lvRefElement(buffer, calcCircularRefElementOffset(producerIndex + lookAheadStep, mask))) {\n            producerLimit = producerIndex + lookAheadStep;\n        } else {\n            final int offset = calcCircularRefElementOffset(producerIndex, mask);\n            if (null != lvRefElement(buffer, offset)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "line_number": 317,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "lpConsumerIndex",
        "this.lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        final long consumerIndex = this.lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(consumerIndex, mask);\n        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            return null;\n        }\n        soRefElement(buffer, offset, null);\n        // ordered store -> atomic and ordered for size()\n        soConsumerIndex(consumerIndex + 1);\n        return e;\n    }",
      "line_number": 336,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return lvRefElement(buffer, calcCircularRefElementOffset(lpConsumerIndex(), mask));\n    }",
      "line_number": 357,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(final E message) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return offer(message);\n    }",
      "line_number": 362,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return drain(c, capacity());\n    }",
      "line_number": 377,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return fill(s, capacity());\n    }",
      "line_number": 382,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "accept",
        "c.accept",
        "IllegalArgumentException",
        "this.lpConsumerIndex",
        "lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long consumerIndex = this.lpConsumerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = consumerIndex + i;\n            final int offset = calcCircularRefElementOffset(index, mask);\n            final E e = lvRefElement(buffer, offset);\n            if (null == e) {\n                return i;\n            }\n            soRefElement(buffer, offset, null);\n            // ordered store -> atomic and ordered for size()\n            soConsumerIndex(index + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 387,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final int lookAheadStep = this.lookAheadStep;\n        final long producerIndex = this.lpProducerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = producerIndex + i;\n            final int lookAheadElementOffset = calcCircularRefElementOffset(index + lookAheadStep, mask);\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                int lookAheadLimit = Math.min(lookAheadStep, limit - i);\n                for (int j = 0; j < lookAheadLimit; j++) {\n                    final int offset = calcCircularRefElementOffset(index + j, mask);\n                    soRefElement(buffer, offset, s.get());\n                    // ordered store -> atomic and ordered for size()\n                    soProducerIndex(index + j + 1);\n                }\n                i += lookAheadLimit - 1;\n            } else {\n                final int offset = calcCircularRefElementOffset(index, mask);\n                if (null != lvRefElement(buffer, offset)) {\n                    return i;\n                }\n                soRefElement(buffer, offset, s.get());\n                // ordered store -> atomic and ordered for size()\n                soProducerIndex(index + 1);\n            }\n        }\n        return limit;\n    }",
      "line_number": 413,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(final Consumer<E> c, final WaitStrategy w, final ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "AtomicReference",
        "AtomicReferenceArray",
        "final"
      ],
      "dependencies": [
        "exit.keepRunning",
        "accept",
        "w.idle",
        "c.accept",
        "IllegalArgumentException",
        "this.lpConsumerIndex",
        "keepRunning",
        "idle",
        "lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 26,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (null == w)\n            throw new IllegalArgumentException(\"wait is null\");\n        if (null == exit)\n            throw new IllegalArgumentException(\"exit condition is null\");\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long consumerIndex = this.lpConsumerIndex();\n        int counter = 0;\n        while (exit.keepRunning()) {\n            for (int i = 0; i < 4096; i++) {\n                final int offset = calcCircularRefElementOffset(consumerIndex, mask);\n                final E e = lvRefElement(buffer, offset);\n                if (null == e) {\n                    counter = w.idle(counter);\n                    continue;\n                }\n                consumerIndex++;\n                counter = 0;\n                soRefElement(buffer, offset, null);\n                // ordered store -> atomic and ordered for size()\n                soConsumerIndex(consumerIndex);\n                c.accept(e);\n            }\n        }\n    }",
      "line_number": 450,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(final Supplier<E> s, final WaitStrategy w, final ExitCondition e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "AtomicReference",
        "AtomicReferenceArray",
        "final"
      ],
      "dependencies": [
        "e.keepRunning",
        "w.idle",
        "get",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "keepRunning",
        "idle",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 33,
      "source_code": "        if (null == w)\n            throw new IllegalArgumentException(\"waiter is null\");\n        if (null == e)\n            throw new IllegalArgumentException(\"exit condition is null\");\n        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final int lookAheadStep = this.lookAheadStep;\n        long producerIndex = this.lpProducerIndex();\n        int counter = 0;\n        while (e.keepRunning()) {\n            final int lookAheadElementOffset = calcCircularRefElementOffset(producerIndex + lookAheadStep, mask);\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                for (int j = 0; j < lookAheadStep; j++) {\n                    final int offset = calcCircularRefElementOffset(producerIndex, mask);\n                    producerIndex++;\n                    soRefElement(buffer, offset, s.get());\n                    // ordered store -> atomic and ordered for size()\n                    soProducerIndex(producerIndex);\n                }\n            } else {\n                final int offset = calcCircularRefElementOffset(producerIndex, mask);\n                if (null != lvRefElement(buffer, offset)) {\n                    counter = w.idle(counter);\n                    continue;\n                }\n                producerIndex++;\n                counter = 0;\n                soRefElement(buffer, offset, s.get());\n                // ordered store -> atomic and ordered for size()\n                soProducerIndex(producerIndex);\n            }\n        }\n    }",
      "line_number": 480,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 98,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 102,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 106,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 177,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 181,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 185,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public final Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 213,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public final int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "size",
        "IndexedQueueSizeUtil.size"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return IndexedQueueSizeUtil.size(this, IndexedQueueSizeUtil.PLAIN_DIVISOR);\n    }",
      "line_number": 218,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public final boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IndexedQueueSizeUtil.isEmpty",
        "isEmpty"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return IndexedQueueSizeUtil.isEmpty(this);\n    }",
      "line_number": 223,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 228,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soNext",
      "signature": "protected final void soNext(AtomicReferenceArray<E> curr, AtomicReferenceArray<E> next) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        int offset = nextArrayOffset(curr);\n        soRefElement(curr, offset, next);\n    }",
      "line_number": 242,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvNextArrayAndUnlink",
      "signature": "protected final AtomicReferenceArray<E> lvNextArrayAndUnlink(AtomicReferenceArray<E> curr) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final int offset = nextArrayOffset(curr);\n        final AtomicReferenceArray<E> nextBuffer = (AtomicReferenceArray<E>) lvRefElement(curr, offset);\n        // prevent GC nepotism\n        soRefElement(curr, offset, null);\n        return nextBuffer;\n    }",
      "line_number": 248,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        // result is a long because we want to have a safepoint check at regular intervals\n        long result = 0;\n        final int capacity = capacity();\n        do {\n            final int filled = fill(s, PortableJvmInfo.RECOMENDED_OFFER_BATCH);\n            if (filled == 0) {\n                return (int) result;\n            }\n            result += filled;\n        } while (result <= capacity);\n        return (int) result;\n    }",
      "line_number": 277,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        for (int i = 0; i < limit; i++) {\n            // local load of field to avoid repeated loads after volatile reads\n            final AtomicReferenceArray<E> buffer = producerBuffer;\n            final long index = lpProducerIndex();\n            final long mask = producerMask;\n            final int offset = calcCircularRefElementOffset(index, mask);\n            // expected hot path\n            if (index < producerBufferLimit) {\n                writeToQueue(buffer, s.get(), index, offset);\n            } else {\n                if (!offerColdPath(buffer, mask, index, offset, null, s)) {\n                    return i;\n                }\n            }\n        }\n        return limit;\n    }",
      "line_number": 297,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 323,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 328,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "Objects.requireNonNull",
        "requireNonNull",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        // Objects.requireNonNull(e);\n        if (null == e) {\n            throw new NullPointerException();\n        }\n        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = producerBuffer;\n        final long index = lpProducerIndex();\n        final long mask = producerMask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        // expected hot path\n        if (index < producerBufferLimit) {\n            writeToQueue(buffer, e, index, offset);\n            return true;\n        }\n        return offerColdPath(buffer, mask, index, offset, e, null);\n    }",
      "line_number": 338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long index = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        final Object e = lvRefElement(buffer, offset);\n        boolean isNextBuffer = e == JUMP;\n        if (null != e && !isNextBuffer) {\n            // this ensures correctness on 32bit platforms\n            soConsumerIndex(index + 1);\n            soRefElement(buffer, offset, null);\n            return (E) e;\n        } else if (isNextBuffer) {\n            return newBufferPoll(buffer, index);\n        }\n        return null;\n    }",
      "line_number": 365,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long index = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        final Object e = lvRefElement(buffer, offset);\n        if (e == JUMP) {\n            return newBufferPeek(buffer, index);\n        }\n        return (E) e;\n    }",
      "line_number": 391,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "linkOldToNew",
      "signature": "final void linkOldToNew(final long currIndex, final AtomicReferenceArray<E> oldBuffer, final int offset, final AtomicReferenceArray<E> newBuffer, final int offsetInNew, final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        soRefElement(newBuffer, offsetInNew, e);\n        // link to next buffer and add next indicator as element of old buffer\n        soNext(oldBuffer, newBuffer);\n        soRefElement(oldBuffer, offset, JUMP);\n        // index is visible after elements (isEmpty/poll ordering)\n        // this ensures atomic write of long on 32bit platforms\n        soProducerIndex(currIndex + 1);\n    }",
      "line_number": 403,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "writeToQueue",
      "signature": "final void writeToQueue(final AtomicReferenceArray<E> buffer, final E e, final long index, final int offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        soRefElement(buffer, offset, e);\n        // this ensures atomic write of long on 32bit platforms\n        soProducerIndex(index + 1);\n    }",
      "line_number": 413,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPeek",
      "signature": "private E newBufferPeek(final AtomicReferenceArray<E> buffer, final long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        AtomicReferenceArray<E> nextBuffer = lvNextArrayAndUnlink(buffer);\n        consumerBuffer = nextBuffer;\n        final long mask = length(nextBuffer) - 2;\n        consumerMask = mask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        return lvRefElement(nextBuffer, offset);\n    }",
      "line_number": 419,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPoll",
      "signature": "private E newBufferPoll(final AtomicReferenceArray<E> buffer, final long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/BaseSpscLinkedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalStateException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        AtomicReferenceArray<E> nextBuffer = lvNextArrayAndUnlink(buffer);\n        consumerBuffer = nextBuffer;\n        final long mask = length(nextBuffer) - 2;\n        consumerMask = mask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (null == n) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        } else {\n            // this ensures correctness on 32bit platforms\n            soConsumerIndex(index + 1);\n            soRefElement(nextBuffer, offset, null);\n            return n;\n        }\n    }",
      "line_number": 428,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscUnboundedAtomicArrayQueue",
      "signature": "public MpscUnboundedAtomicArrayQueue(int chunkSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscUnboundedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(chunkSize);\n    }",
      "line_number": 78,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscUnboundedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        return length(buffer);\n    }",
      "line_number": 103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/MpscUnboundedAtomicArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return mask;\n    }",
      "line_number": 108,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, C_INDEX_OFFSET);\n    }",
      "line_number": 60,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, C_INDEX_OFFSET, newValue);\n    }",
      "line_number": 64,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, P_INDEX_OFFSET, newValue);\n    }",
      "line_number": 91,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, P_INDEX_OFFSET);\n    }",
      "line_number": 95,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public final Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public final int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "size",
        "IndexedQueueSizeUtil.size"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return IndexedQueueSizeUtil.size(this, IndexedQueueSizeUtil.PLAIN_DIVISOR);\n    }",
      "line_number": 128,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public final boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IndexedQueueSizeUtil.isEmpty",
        "isEmpty"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return IndexedQueueSizeUtil.isEmpty(this);\n    }",
      "line_number": 133,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 138,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soNext",
      "signature": "protected final void soNext(E[] curr, E[] next) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        long offset = nextArrayOffset(curr);\n        soRefElement(curr, offset, next);\n    }",
      "line_number": 152,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvNextArrayAndUnlink",
      "signature": "protected final E[] lvNextArrayAndUnlink(E[] curr) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final long offset = nextArrayOffset(curr);\n        final E[] nextBuffer = (E[]) lvRefElement(curr, offset);\n        // prevent GC nepotism\n        soRefElement(curr, offset, null);\n        return nextBuffer;\n    }",
      "line_number": 158,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        // result is a long because we want to have a safepoint check at regular intervals\n        long result = 0;\n        final int capacity = capacity();\n        do {\n            final int filled = fill(s, PortableJvmInfo.RECOMENDED_OFFER_BATCH);\n            if (filled == 0) {\n                return (int) result;\n            }\n            result += filled;\n        } while (result <= capacity);\n        return (int) result;\n    }",
      "line_number": 187,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        for (int i = 0; i < limit; i++) {\n            // local load of field to avoid repeated loads after volatile reads\n            final E[] buffer = producerBuffer;\n            final long index = lpProducerIndex();\n            final long mask = producerMask;\n            final long offset = calcCircularRefElementOffset(index, mask);\n            // expected hot path\n            if (index < producerBufferLimit) {\n                writeToQueue(buffer, s.get(), index, offset);\n            } else {\n                if (!offerColdPath(buffer, mask, index, offset, null, s)) {\n                    return i;\n                }\n            }\n        }\n        return limit;\n    }",
      "line_number": 207,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 233,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 238,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "Objects.requireNonNull",
        "requireNonNull"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        // Objects.requireNonNull(e);\n        if (null == e) {\n            throw new NullPointerException();\n        }\n        // local load of field to avoid repeated loads after volatile reads\n        final E[] buffer = producerBuffer;\n        final long index = lpProducerIndex();\n        final long mask = producerMask;\n        final long offset = calcCircularRefElementOffset(index, mask);\n        // expected hot path\n        if (index < producerBufferLimit) {\n            writeToQueue(buffer, e, index, offset);\n            return true;\n        }\n        return offerColdPath(buffer, mask, index, offset, e, null);\n    }",
      "line_number": 248,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final E[] buffer = consumerBuffer;\n        final long index = lpConsumerIndex();\n        final long mask = consumerMask;\n        final long offset = calcCircularRefElementOffset(index, mask);\n        final Object e = lvRefElement(buffer, offset);\n        boolean isNextBuffer = e == JUMP;\n        if (null != e && !isNextBuffer) {\n            // this ensures correctness on 32bit platforms\n            soConsumerIndex(index + 1);\n            soRefElement(buffer, offset, null);\n            return (E) e;\n        } else if (isNextBuffer) {\n            return newBufferPoll(buffer, index);\n        }\n        return null;\n    }",
      "line_number": 275,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final E[] buffer = consumerBuffer;\n        final long index = lpConsumerIndex();\n        final long mask = consumerMask;\n        final long offset = calcCircularRefElementOffset(index, mask);\n        final Object e = lvRefElement(buffer, offset);\n        if (e == JUMP) {\n            return newBufferPeek(buffer, index);\n        }\n        return (E) e;\n    }",
      "line_number": 301,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "linkOldToNew",
      "signature": "final void linkOldToNew(final long currIndex, final E[] oldBuffer, final long offset, final E[] newBuffer, final long offsetInNew, final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        soRefElement(newBuffer, offsetInNew, e);\n        // link to next buffer and add next indicator as element of old buffer\n        soNext(oldBuffer, newBuffer);\n        soRefElement(oldBuffer, offset, JUMP);\n        // index is visible after elements (isEmpty/poll ordering)\n        // this ensures atomic write of long on 32bit platforms\n        soProducerIndex(currIndex + 1);\n    }",
      "line_number": 313,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "writeToQueue",
      "signature": "final void writeToQueue(final E[] buffer, final E e, final long index, final long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        soRefElement(buffer, offset, e);\n        // this ensures atomic write of long on 32bit platforms\n        soProducerIndex(index + 1);\n    }",
      "line_number": 323,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPeek",
      "signature": "private E newBufferPeek(final E[] buffer, final long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        E[] nextBuffer = lvNextArrayAndUnlink(buffer);\n        consumerBuffer = nextBuffer;\n        final long mask = length(nextBuffer) - 2;\n        consumerMask = mask;\n        final long offset = calcCircularRefElementOffset(index, mask);\n        return lvRefElement(nextBuffer, offset);\n    }",
      "line_number": 329,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPoll",
      "signature": "private E newBufferPoll(final E[] buffer, final long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseSpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        E[] nextBuffer = lvNextArrayAndUnlink(buffer);\n        consumerBuffer = nextBuffer;\n        final long mask = length(nextBuffer) - 2;\n        consumerMask = mask;\n        final long offset = calcCircularRefElementOffset(index, mask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (null == n) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        } else {\n            // this ensures correctness on 32bit platforms\n            soConsumerIndex(index + 1);\n            soRefElement(nextBuffer, offset, null);\n            return n;\n        }\n    }",
      "line_number": 338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, P_INDEX_OFFSET, newValue);\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, P_INDEX_OFFSET, expect, newValue);\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 83,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, C_INDEX_OFFSET);\n    }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, C_INDEX_OFFSET, newValue);\n    }",
      "line_number": 91,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerLimit",
      "signature": "final long lvProducerLimit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerLimit;\n    }",
      "line_number": 117,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerLimit",
      "signature": "final boolean casProducerLimit(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, P_LIMIT_OFFSET, expect, newValue);\n    }",
      "line_number": 121,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerLimit",
      "signature": "final void soProducerLimit(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, P_LIMIT_OFFSET, newValue);\n    }",
      "line_number": 125,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "BaseMpscLinkedUnpaddedArrayQueue",
      "signature": "public BaseMpscLinkedUnpaddedArrayQueue(final int initialCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(initialCapacity, 2, \"initialCapacity\");\n        int p2capacity = Pow2.roundToPowerOfTwo(initialCapacity);\n        // leave lower bit of mask clear\n        long mask = (p2capacity - 1) << 1;\n        // need extra element to point at next array\n        E[] buffer = allocateRefArray(p2capacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        soProducerLimit(mask);\n    }",
      "line_number": 157,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 187,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        long mask;\n        E[] buffer;\n        long pIndex;\n        while (true) {\n            long producerLimit = lvProducerLimit();\n            pIndex = lvProducerIndex();\n            // lower bit is indicative of resize, if we see it we spin until it's cleared\n            if ((pIndex & 1) == 1) {\n                continue;\n            }\n            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1)\n            // mask/buffer may get changed by resizing -> only use for array access after successful CAS.\n            mask = this.producerMask;\n            buffer = this.producerBuffer;\n            // a successful CAS ties the ordering, lv(pIndex) - [mask/buffer] -> cas(pIndex)\n            // assumption behind this optimization is that queue is almost always empty or near empty\n            if (producerLimit <= pIndex) {\n                int result = offerSlowPath(mask, pIndex, producerLimit);\n                switch(result) {\n                    case CONTINUE_TO_P_INDEX_CAS:\n                        break;\n                    case RETRY:\n                        continue;\n                    case QUEUE_FULL:\n                        return false;\n                    case QUEUE_RESIZE:\n                        resize(mask, buffer, pIndex, e, null);\n                        return true;\n                }\n            }\n            if (casProducerIndex(pIndex, pIndex + 2)) {\n                break;\n            }\n        }\n        // INDEX visible before ELEMENT\n        final long offset = modifiedCalcCircularRefElementOffset(pIndex, mask);\n        // release element e\n        soRefElement(buffer, offset, e);\n        return true;\n    }",
      "line_number": 192,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        final E[] buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final long offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            long pIndex = lvProducerIndex();\n            // isEmpty?\n            if ((cIndex - pIndex) / 2 == 0) {\n                return null;\n            }\n            // poll() == null iff queue is empty, null element is not strong enough indicator, so we must\n            // spin until element is visible.\n            do {\n                e = lvRefElement(buffer, offset);\n            } while (e == null);\n        }\n        if (e == JUMP) {\n            final E[] nextBuffer = nextBuffer(buffer, mask);\n            return newBufferPoll(nextBuffer, cIndex);\n        }\n        // release element null\n        soRefElement(buffer, offset, null);\n        // release cIndex\n        soConsumerIndex(cIndex + 2);\n        return (E) e;\n    }",
      "line_number": 244,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        final E[] buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final long offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            long pIndex = lvProducerIndex();\n            // isEmpty?\n            if ((cIndex - pIndex) / 2 == 0) {\n                return null;\n            }\n            // peek() == null iff queue is empty, null element is not strong enough indicator, so we must\n            // spin until element is visible.\n            do {\n                e = lvRefElement(buffer, offset);\n            } while (e == null);\n        }\n        if (e == JUMP) {\n            return newBufferPeek(nextBuffer(buffer, mask), cIndex);\n        }\n        return (E) e;\n    }",
      "line_number": 280,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerSlowPath",
      "signature": "private int offerSlowPath(long mask, long pIndex, long producerLimit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final long cIndex = lvConsumerIndex();\n        long bufferCapacity = getCurrentBufferCapacity(mask);\n        if (cIndex + bufferCapacity > pIndex) {\n            if (!casProducerLimit(producerLimit, cIndex + bufferCapacity)) {\n                // retry from top\n                return RETRY;\n            } else {\n                // continue to pIndex CAS\n                return CONTINUE_TO_P_INDEX_CAS;\n            }\n        } else // full and cannot grow\n        if (availableInQueue(pIndex, cIndex) <= 0) {\n            // offer should return false;\n            return QUEUE_FULL;\n        } else // grab index for resize -> set lower bit\n        if (casProducerIndex(pIndex, pIndex + 1)) {\n            // trigger a resize\n            return QUEUE_RESIZE;\n        } else {\n            // failed resize attempt, retry from top\n            return RETRY;\n        }\n    }",
      "line_number": 307,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "nextBuffer",
      "signature": "private E[] nextBuffer(final E[] buffer, final long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final long offset = nextArrayOffset(mask);\n        final E[] nextBuffer = (E[]) lvRefElement(buffer, offset);\n        consumerBuffer = nextBuffer;\n        consumerMask = (length(nextBuffer) - 2) << 1;\n        soRefElement(buffer, offset, BUFFER_CONSUMED);\n        return nextBuffer;\n    }",
      "line_number": 338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "nextArrayOffset",
      "signature": "private static long nextArrayOffset(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return modifiedCalcCircularRefElementOffset(mask + 2, Long.MAX_VALUE);\n    }",
      "line_number": 347,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPoll",
      "signature": "private E newBufferPoll(E[] nextBuffer, long cIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long offset = modifiedCalcCircularRefElementOffset(cIndex, consumerMask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (n == null) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        }\n        soRefElement(nextBuffer, offset, null);\n        soConsumerIndex(cIndex + 2);\n        return n;\n    }",
      "line_number": 351,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPeek",
      "signature": "private E newBufferPeek(E[] nextBuffer, long cIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long offset = modifiedCalcCircularRefElementOffset(cIndex, consumerMask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (null == n) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        }\n        return n;\n    }",
      "line_number": 362,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final E[] buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final long offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            return null;\n        }\n        if (e == JUMP) {\n            final E[] nextBuffer = nextBuffer(buffer, mask);\n            return newBufferPoll(nextBuffer, cIndex);\n        }\n        soRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 2);\n        return (E) e;\n    }",
      "line_number": 391,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final E[] buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final long offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == JUMP) {\n            return newBufferPeek(nextBuffer(buffer, mask), cIndex);\n        }\n        return (E) e;\n    }",
      "line_number": 411,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        // result is a long because we want to have a safepoint check at regular intervals\n        long result = 0;\n        final int capacity = capacity();\n        do {\n            final int filled = fill(s, PortableJvmInfo.RECOMENDED_OFFER_BATCH);\n            if (filled == 0) {\n                return (int) result;\n            }\n            result += filled;\n        } while (result <= capacity);\n        return (int) result;\n    }",
      "line_number": 424,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        long mask;\n        E[] buffer;\n        long pIndex;\n        int claimedSlots;\n        while (true) {\n            long producerLimit = lvProducerLimit();\n            pIndex = lvProducerIndex();\n            // lower bit is indicative of resize, if we see it we spin until it's cleared\n            if ((pIndex & 1) == 1) {\n                continue;\n            }\n            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1)\n            // NOTE: mask/buffer may get changed by resizing -> only use for array access after successful CAS.\n            // Only by virtue offloading them between the lvProducerIndex and a successful casProducerIndex are they\n            // safe to use.\n            mask = this.producerMask;\n            buffer = this.producerBuffer;\n            // a successful CAS ties the ordering, lv(pIndex) -> [mask/buffer] -> cas(pIndex)\n            // we want 'limit' slots, but will settle for whatever is visible to 'producerLimit'\n            // -> producerLimit >= batchIndex\n            long batchIndex = Math.min(producerLimit, pIndex + 2l * limit);\n            if (pIndex >= producerLimit) {\n                int result = offerSlowPath(mask, pIndex, producerLimit);\n                switch(result) {\n                    case CONTINUE_TO_P_INDEX_CAS:\n                    // offer slow path verifies only one slot ahead, we cannot rely on indication here\n                    case RETRY:\n                        continue;\n                    case QUEUE_FULL:\n                        return 0;\n                    case QUEUE_RESIZE:\n                        resize(mask, buffer, pIndex, null, s);\n                        return 1;\n                }\n            }\n            // claim limit slots at once\n            if (",
      "line_number": 439,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 495,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 510,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            final E e = nextElement;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n            nextElement = getNext();\n            return e;\n        }",
      "line_number": 559,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "setBuffer",
      "signature": "private void setBuffer(E[] buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            this.currentBuffer = buffer;\n            this.mask = length(buffer) - 2;\n        }",
      "line_number": 568,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNext",
      "signature": "private E getNext() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "            while (nextIndex < pIndex) {\n                long index = nextIndex++;\n                E e = lvRefElement(currentBuffer, calcCircularRefElementOffset(index, mask));\n                // skip removed/not yet visible elements\n                if (e == null) {\n                    continue;\n                }\n                // not null && not JUMP -> found next element\n                if (e != JUMP) {\n                    return e;\n                }\n                // need to jump to the next buffer\n                int nextBufferIndex = mask + 1;\n                Object nextBuffer = lvRefElement(currentBuffer, calcRefElementOffset(nextBufferIndex));\n                if (nextBuffer == BUFFER_CONSUMED || nextBuffer == null) {\n                    // Consumer may have passed us, or the next buffer is not visible yet: drop out early\n                    return null;\n                }\n                setBuffer((E[]) nextBuffer);\n                // now with the new array retry the load, it can't be a JUMP, but we need to repeat same index\n                e = lvRefElement(currentBuffer, calcCircularRefElementOffset(index, mask));\n                // skip removed/not yet visible elements\n                if (e == null) {\n                    continue;\n                } else {\n                    return e;\n                }\n            }\n            return null;\n        }",
      "line_number": 573,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private void resize(long oldMask, E[] oldBuffer, long pIndex, E e, Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseMpscLinkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "RangeUtil.checkPositive",
        "checkPositive",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        assert (e != null && s == null) || (e == null || s != null);\n        int newBufferLength = getNextBufferSize(oldBuffer);\n        final E[] newBuffer;\n        try {\n            newBuffer = allocateRefArray(newBufferLength);\n        } catch (OutOfMemoryError oom) {\n            assert lvProducerIndex() == pIndex + 1;\n            soProducerIndex(pIndex);\n            throw oom;\n        }\n        producerBuffer = newBuffer;\n        final int newMask = (newBufferLength - 2) << 1;\n        producerMask = newMask;\n        final long offsetInOld = modifiedCalcCircularRefElementOffset(pIndex, oldMask);\n        final long offsetInNew = modifiedCalcCircularRefElementOffset(pIndex, newMask);\n        // element in new array\n        soRefElement(newBuffer, offsetInNew, e == null ? s.get() : e);\n        // buffer linked\n        soRefElement(oldBuffer, nextArrayOffset(oldMask), newBuffer);\n        // ASSERT code\n        final long cIndex = lvConsumerIndex();\n        final long availableInQueue = availableInQueue(pIndex, cIndex);\n        RangeUtil.checkPositive(availableInQueue, \"availableInQueue\");\n        // Invalidate racing CASs\n        // We never set the limit beyond the bounds of a buffer\n        soProducerLimit(pIndex + Math.min(newMask, availableInQueue));\n        // make resize visible to the other producers\n        soProducerIndex(pIndex + 2);\n        // INDEX visible before ELEMENT, consistent with consumer expectation\n        // make resize visible to consumer\n        soRefElement(oldBuffer, offsetInOld, JUMP);\n    }",
      "line_number": 606,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(E[] buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscChunkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return length(buffer);\n    }",
      "line_number": 76,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscChunkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return mask;\n    }",
      "line_number": 81,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(E[] buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnboundedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return length(buffer);\n    }",
      "line_number": 54,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnboundedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return mask;\n    }",
      "line_number": 59,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spProducerNode",
      "signature": "final void spProducerNode(LinkedQueueNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putObject",
        "UNSAFE.putObject",
        "E"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putObject(this, P_NODE_OFFSET, newValue);\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerNode",
      "signature": "final void soProducerNode(LinkedQueueNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedObject",
        "UNSAFE.putOrderedObject",
        "E"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedObject(this, P_NODE_OFFSET, newValue);\n    }",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerNode",
      "signature": "final LinkedQueueNode<E> lvProducerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerNode;\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerNode",
      "signature": "final boolean casProducerNode(LinkedQueueNode<E> expect, LinkedQueueNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, P_NODE_OFFSET, expect, newValue);\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerNode",
      "signature": "final LinkedQueueNode<E> lpProducerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerNode;\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spConsumerNode",
      "signature": "final void spConsumerNode(LinkedQueueNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        consumerNode = newValue;\n    }",
      "line_number": 78,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerNode",
      "signature": "final LinkedQueueNode<E> lvConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return (LinkedQueueNode<E>) UNSAFE.getObjectVolatile(this, C_NODE_OFFSET);\n    }",
      "line_number": 83,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerNode",
      "signature": "final LinkedQueueNode<E> lpConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerNode;\n    }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public final Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 109,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 114,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newNode",
      "signature": "protected final LinkedQueueNode<E> newNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "LinkedQueueNode",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return new LinkedQueueNode<E>();\n    }",
      "line_number": 118,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newNode",
      "signature": "protected final LinkedQueueNode<E> newNode(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "LinkedQueueNode",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return new LinkedQueueNode<E>(e);\n    }",
      "line_number": 122,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public final int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lvNext",
        "chaserNode.lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 7,
      "source_code": "        // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n        // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n        LinkedQueueNode<E> chaserNode = lvConsumerNode();\n        LinkedQueueNode<E> producerNode = lvProducerNode();\n        int size = 0;\n        // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n        while (// don't go passed producer node\n        chaserNode != producerNode && // stop at last node\n        chaserNode != null && // stop at max int\n        size < Integer.MAX_VALUE) {\n            LinkedQueueNode<E> next;\n            next = chaserNode.lvNext();\n            // check if this node has been consumed, if so return what we have\n            if (next == chaserNode) {\n                return size;\n            }\n            chaserNode = next;\n            size++;\n        }\n        return size;\n    }",
      "line_number": 137,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getSingleConsumerNodeValue",
      "signature": "protected E getSingleConsumerNodeValue(LinkedQueueNode<E> currConsumerNode, LinkedQueueNode<E> nextNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getAndNullValue",
        "currConsumerNode.soNext",
        "soNext",
        "nextNode.getAndNullValue",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        // we have to null out the value because we are going to hang on to the node\n        final E nextValue = nextNode.getAndNullValue();\n        // Fix up the next ref of currConsumerNode to prevent promoted nodes from keeping new ones alive.\n        // We use a reference to self instead of null because null is already a meaningful value (the next of\n        // producer node is null).\n        currConsumerNode.soNext(currConsumerNode);\n        spConsumerNode(nextNode);\n        // currConsumerNode is now no longer referenced and can be collected\n        return nextValue;\n    }",
      "line_number": 177,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final LinkedQueueNode<E> currConsumerNode = lpConsumerNode();\n        LinkedQueueNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        } else if (currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n            // got the next node...\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        }\n        return null;\n    }",
      "line_number": 211,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "lpValue",
        "currConsumerNode.lvNext",
        "lvNext",
        "nextNode.lpValue",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        final LinkedQueueNode<E> currConsumerNode = lpConsumerNode();\n        LinkedQueueNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        } else if (currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n            // got the next node...\n            return nextNode.lpValue();\n        }\n        return null;\n    }",
      "line_number": 243,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spinWaitForNextNode",
      "signature": "LinkedQueueNode<E> spinWaitForNextNode(LinkedQueueNode<E> currNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait"
      ],
      "dependencies": [
        "lvNext",
        "currNode.lvNext",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        LinkedQueueNode<E> nextNode;\n        while ((nextNode = currNode.lvNext()) == null) {\n            // spin, we are no longer wait free\n        }\n        return nextNode;\n    }",
      "line_number": 256,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final LinkedQueueNode<E> currConsumerNode = lpConsumerNode();\n        final LinkedQueueNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        }\n        return null;\n    }",
      "line_number": 265,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lpValue",
        "lvNext",
        "nextNode.lpValue",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        }\n        return null;\n    }",
      "line_number": 275,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "this.lpConsumerNode",
        "accept",
        "E",
        "lvNext",
        "c.accept",
        "IllegalArgumentException",
        "chaserNode.lvNext",
        "lpConsumerNode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueNode<E> chaserNode = this.lpConsumerNode();\n        for (int i = 0; i < limit; i++) {\n            final LinkedQueueNode<E> nextNode = chaserNode.lvNext();\n            if (nextNode == null) {\n                return i;\n            }\n            // we have to null out the value because we are going to hang on to the node\n            final E nextValue = getSingleConsumerNodeValue(chaserNode, nextNode);\n            chaserNode = nextNode;\n            c.accept(nextValue);\n        }\n        return limit;\n    }",
      "line_number": 289,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/BaseLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 316,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "prevProducerNode.soNext",
        "NullPointerException",
        "soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final LinkedQueueNode<E> nextNode = newNode(e);\n        final LinkedQueueNode<E> prevProducerNode = xchgProducerNode(nextNode);\n        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed\n        // and completes the store in prev.next. This is a \"bubble\".\n        prevProducerNode.soNext(nextNode);\n        return true;\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "lpValue",
        "E",
        "currConsumerNode.soNext",
        "currConsumerNode.lpValue",
        "soNext",
        "equals",
        "o.equals",
        "prevConsumerNode.soNext",
        "currConsumerNode.spValue",
        "spValue"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        if (null == o) {\n            // Null elements are not permitted, so null will never be removed.\n            return false;\n        }\n        final LinkedQueueNode<E> originalConsumerNode = lpConsumerNode();\n        LinkedQueueNode<E> prevConsumerNode = originalConsumerNode;\n        LinkedQueueNode<E> currConsumerNode = getNextConsumerNode(originalConsumerNode);\n        while (currConsumerNode != null) {\n            if (o.equals(currConsumerNode.lpValue())) {\n                LinkedQueueNode<E> nextNode = getNextConsumerNode(currConsumerNode);\n                // e.g.: consumerNode -> node0 -> node1(o==v) -> node2 ... => consumerNode -> node0 -> node2\n                if (nextNode != null) {\n                    // We are removing an interior node.\n                    prevConsumerNode.soNext(nextNode);\n                } else // This case reflects: prevConsumerNode != originalConsumerNode && nextNode == null\n                // At rest, this would be the producerNode, but we must contend with racing. Changes to subclassed\n                // queues need to consider remove() when implementing offer().\n                {\n                    // producerNode is currConsumerNode, try to atomically update the reference to move it to the\n                    // previous node.\n                    prevConsumerNode.soNext(null);\n                    if (!casProducerNode(currConsumerNode, prevConsumerNode)) {\n                        // If the producer(s) have offered more items we need to remove the currConsumerNode link.\n                        nextNode = spinWaitForNextNode(currConsumerNode);\n                        prevConsumerNode.soNext(nextNode);\n                    }\n                }\n                // Avoid GC nepotism because we are discarding the current node.\n                currConsumerNode.soNext(null);\n                currConsumerNode.spValue(null);\n                return true;\n            }\n            prevConsumerNode = currConsumerNode;\n            currConsumerNo",
      "line_number": 81,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "spNext",
        "get",
        "tail.spNext",
        "s.get",
        "IllegalArgumentException",
        "soNext",
        "oldPNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueNode<E> tail = newNode(s.get());\n        final LinkedQueueNode<E> head = tail;\n        for (int i = 1; i < limit; i++) {\n            final LinkedQueueNode<E> temp = newNode(s.get());\n            // spNext: xchgProducerNode ensures correct construction\n            tail.spNext(temp);\n            tail = temp;\n        }\n        final LinkedQueueNode<E> oldPNode = xchgProducerNode(tail);\n        oldPNode.soNext(head);\n        return limit;\n    }",
      "line_number": 126,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 147,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "xchgProducerNode",
      "signature": "private LinkedQueueNode<E> xchgProducerNode(LinkedQueueNode<E> newVal) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "getAndSet"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "getAndSetObject",
        "UNSAFE.compareAndSwapObject",
        "UNSAFE.getAndSetObject",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (UnsafeAccess.SUPPORTS_GET_AND_SET_REF) {\n            return (LinkedQueueNode<E>) UNSAFE.getAndSetObject(this, P_NODE_OFFSET, newVal);\n        } else {\n            LinkedQueueNode<E> oldVal;\n            do {\n                oldVal = lvProducerNode();\n            } while (!UNSAFE.compareAndSwapObject(this, P_NODE_OFFSET, oldVal, newVal));\n            return oldVal;\n        }\n    }",
      "line_number": 152,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextConsumerNode",
      "signature": "private LinkedQueueNode<E> getNextConsumerNode(LinkedQueueNode<E> currConsumerNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        LinkedQueueNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode == null && currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n        }\n        return nextNode;\n    }",
      "line_number": 164,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, P_INDEX_OFFSET, expect, newValue);\n    }",
      "line_number": 53,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casConsumerIndex",
      "signature": "final boolean casConsumerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, C_INDEX_OFFSET, expect, newValue);\n    }",
      "line_number": 88,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpmcUnpaddedArrayQueue",
      "signature": "public MpmcUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "Math.max",
        "RangeUtil.checkGreaterThanOrEqual",
        "min",
        "max",
        "Math.min"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        super(RangeUtil.checkGreaterThanOrEqual(capacity, 2, \"capacity\"));\n        lookAheadStep = Math.max(2, Math.min(capacity() / 4, MAX_LOOK_AHEAD_STEP));\n    }",
      "line_number": 135,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final long mask = this.mask;\n        final long capacity = mask + 1;\n        final long[] sBuffer = sequenceBuffer;\n        long pIndex;\n        long seqOffset;\n        long seq;\n        // start with bogus value, hope we don't need it\n        long cIndex = Long.MIN_VALUE;\n        do {\n            pIndex = lvProducerIndex();\n            seqOffset = calcCircularLongElementOffset(pIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            // consumer has not moved this seq forward, it's as last producer left\n            if (seq < pIndex) {\n                // Extra check required to ensure [Queue.offer == false iff queue is full]\n                if (// test against cached cIndex\n                pIndex - capacity >= cIndex && // test against latest cIndex\n                pIndex - capacity >= (cIndex = lvConsumerIndex())) {\n                    return false;\n                } else {\n                    // (+) hack to make it go around again without CAS\n                    seq = pIndex + 1;\n                }\n            }\n        } while (// another producer has moved the sequence(or +)\n        seq > pIndex || // failed to increment\n        !casProducerIndex(pIndex, pIndex + 1));\n        // casProducerIndex ensures correct construction\n        spRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), e);\n        // seq++;\n        soLongElement(sBuffer, seqOffset, pIndex + 1);\n        return true;\n    }",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "poll",
        "Queue.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        long cIndex;\n        long seq;\n        long seqOffset;\n        long expectedSeq;\n        // start with bogus value, hope we don't need it\n        long pIndex = -1;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                // slot has not been moved by producer\n                if (// test against cached pIndex\n                cIndex >= pIndex && // update pIndex if we must\n                cIndex == (pIndex = lvProducerIndex())) {\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                } else {\n                    // trip another go around\n                    seq = expectedSeq + 1;\n                }\n            }\n        } while (// another consumer beat us to it\n        seq > expectedSeq || // failed the CAS\n        !casConsumerIndex(cIndex, cIndex + 1));\n        final long offset = calcCircularRefElementOffset(cIndex, mask);\n        final E e = lpRefElement(buffer, offset);\n        spRefElement(buffer, offset, null);\n        // i.e. seq += capacity\n        soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n        return e;\n    }",
      "line_number": 186,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "poll",
        "Queue.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        long cIndex;\n        long seq;\n        long seqOffset;\n        long expectedSeq;\n        // start with bogus value, hope we don't need it\n        long pIndex = -1;\n        E e;\n        while (true) {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                // slot has not been moved by producer\n                if (// test against cached pIndex\n                cIndex >= pIndex && // update pIndex if we must\n                cIndex == (pIndex = lvProducerIndex())) {\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                }\n            } else if (seq == expectedSeq) {\n                final long offset = calcCircularRefElementOffset(cIndex, mask);\n                e = lvRefElement(buffer, offset);\n                if (lvConsumerIndex() == cIndex)\n                    return e;\n            }\n        }\n    }",
      "line_number": 225,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final long mask = this.mask;\n        final long[] sBuffer = sequenceBuffer;\n        long pIndex;\n        long seqOffset;\n        long seq;\n        do {\n            pIndex = lvProducerIndex();\n            seqOffset = calcCircularLongElementOffset(pIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            if (seq < pIndex) {\n                // slot not cleared by consumer yet\n                return false;\n            }\n        } while (// another producer has moved the sequence\n        seq > pIndex || // failed to increment\n        !casProducerIndex(pIndex, pIndex + 1));\n        // casProducerIndex ensures correct construction\n        spRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), e);\n        soLongElement(sBuffer, seqOffset, pIndex + 1);\n        return true;\n    }",
      "line_number": 259,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        long cIndex;\n        long seqOffset;\n        long seq;\n        long expectedSeq;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                return null;\n            }\n        } while (// another consumer beat us to it\n        seq > expectedSeq || // failed the CAS\n        !casConsumerIndex(cIndex, cIndex + 1));\n        final long offset = calcCircularRefElementOffset(cIndex, mask);\n        final E e = lpRefElement(buffer, offset);\n        spRefElement(buffer, offset, null);\n        soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n        return e;\n    }",
      "line_number": 286,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        long cIndex;\n        long seq;\n        long seqOffset;\n        long expectedSeq;\n        E e;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                return null;\n            } else if (seq == expectedSeq) {\n                final long offset = calcCircularRefElementOffset(cIndex, mask);\n                e = lvRefElement(buffer, offset);\n                if (lvConsumerIndex() == cIndex)\n                    return e;\n            }\n        } while (true);\n    }",
      "line_number": 312,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "accept",
        "min",
        "c.accept",
        "Math.min",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        final E[] buffer = this.buffer;\n        final int maxLookAheadStep = Math.min(this.lookAheadStep, limit);\n        int consumed = 0;\n        while (consumed < limit) {\n            final int remaining = limit - consumed;\n            final int lookAheadStep = Math.min(remaining, maxLookAheadStep);\n            final long cIndex = lvConsumerIndex();\n            final long lookAheadIndex = cIndex + lookAheadStep - 1;\n            final long lookAheadSeqOffset = calcCircularLongElementOffset(lookAheadIndex, mask);\n            final long lookAheadSeq = lvLongElement(sBuffer, lookAheadSeqOffset);\n            final long expectedLookAheadSeq = lookAheadIndex + 1;\n            if (lookAheadSeq == expectedLookAheadSeq && casConsumerIndex(cIndex, expectedLookAheadSeq)) {\n                for (int i = 0; i < lookAheadStep; i++) {\n                    final long index = cIndex + i;\n                    final long seqOffset = calcCircularLongElementOffset(index, mask);\n                    final long offset = calcCircularRefElementOffset(index, mask);\n                    final long expectedSeq = index + 1;\n                    while (lvLongElement(sBuffer, seqOffset) != expectedSeq) {\n                    }\n                    final E e = lpRefElement(buffer, offset);\n                    spRefElement(buffer, offset, null);\n                    soLongElement(sBuffer, seqOffset, index + mask + 1);\n                    c.accept(e);\n                }\n                consumed += lookAheadStep;\n            } else {\n                if (lookAheadSeq < expectedLookAheadSeq) {\n                    if (notAvailable(cIndex, mask, sBuffer, cIndex + 1)) {\n                        return con",
      "line_number": 338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drainOneByOne",
      "signature": "private int drainOneByOne(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        final E[] buffer = this.buffer;\n        long cIndex;\n        long seqOffset;\n        long seq;\n        long expectedSeq;\n        for (int i = 0; i < limit; i++) {\n            do {\n                cIndex = lvConsumerIndex();\n                seqOffset = calcCircularLongElementOffset(cIndex, mask);\n                seq = lvLongElement(sBuffer, seqOffset);\n                expectedSeq = cIndex + 1;\n                if (seq < expectedSeq) {\n                    return i;\n                }\n            } while (// another consumer beat us to it\n            seq > expectedSeq || // failed the CAS\n            !casConsumerIndex(cIndex, cIndex + 1));\n            final long offset = calcCircularRefElementOffset(cIndex, mask);\n            final E e = lpRefElement(buffer, offset);\n            spRefElement(buffer, offset, null);\n            soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 384,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        final E[] buffer = this.buffer;\n        final int maxLookAheadStep = Math.min(this.lookAheadStep, limit);\n        int produced = 0;\n        while (produced < limit) {\n            final int remaining = limit - produced;\n            final int lookAheadStep = Math.min(remaining, maxLookAheadStep);\n            final long pIndex = lvProducerIndex();\n            final long lookAheadIndex = pIndex + lookAheadStep - 1;\n            final long lookAheadSeqOffset = calcCircularLongElementOffset(lookAheadIndex, mask);\n            final long lookAheadSeq = lvLongElement(sBuffer, lookAheadSeqOffset);\n            final long expectedLookAheadSeq = lookAheadIndex;\n            if (lookAheadSeq == expectedLookAheadSeq && casProducerIndex(pIndex, expectedLookAheadSeq + 1)) {\n                for (int i = 0; i < lookAheadStep; i++) {\n                    final long index = pIndex + i;\n                    final long seqOffset = calcCircularLongElementOffset(index, mask);\n                    final long offset = calcCircularRefElementOffset(index, mask);\n                    while (lvLongElement(sBuffer, seqOffset) != index) {\n                    }\n                    // Ordered store ensures correct construction\n                    soRefElement(buffer, offset, s.get());\n                    soLongElement(sBuffer, seqOffset, index + 1);\n                }\n                produced += lookAheadStep;\n            } else {\n                if (lookAheadSeq < expectedLookAheadSeq) {\n                    if (notAvailable(pIndex, mask, sBuffer, pIndex)) {\n                        return produced;\n                    }\n                }\n                return produced + fillOneByOne",
      "line_number": 414,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "notAvailable",
      "signature": "private boolean notAvailable(long index, long mask, long[] sBuffer, long expectedSeq) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final long seqOffset = calcCircularLongElementOffset(index, mask);\n        final long seq = lvLongElement(sBuffer, seqOffset);\n        if (seq < expectedSeq) {\n            return true;\n        }\n        return false;\n    }",
      "line_number": 458,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fillOneByOne",
      "signature": "private int fillOneByOne(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final long[] sBuffer = sequenceBuffer;\n        final long mask = this.mask;\n        final E[] buffer = this.buffer;\n        long pIndex;\n        long seqOffset;\n        long seq;\n        for (int i = 0; i < limit; i++) {\n            do {\n                pIndex = lvProducerIndex();\n                seqOffset = calcCircularLongElementOffset(pIndex, mask);\n                seq = lvLongElement(sBuffer, seqOffset);\n                if (seq < pIndex) {\n                    // slot not cleared by consumer yet\n                    return i;\n                }\n            } while (// another producer has moved the sequence\n            seq > pIndex || // failed to increment\n            !casProducerIndex(pIndex, pIndex + 1));\n            // Ordered store ensures correct construction\n            soRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), s.get());\n            soLongElement(sBuffer, seqOffset, pIndex + 1);\n        }\n        return limit;\n    }",
      "line_number": 467,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 504,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 509,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(E[] buffer, long mask, long pIndex, long offset, E v, Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnboundedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        // use a fixed lookahead step based on buffer capacity\n        final long lookAheadStep = (mask + 1) / 4;\n        long pBufferLimit = pIndex + lookAheadStep;\n        // go around the buffer or add a new buffer\n        if (null == lvRefElement(buffer, calcCircularRefElementOffset(pBufferLimit, mask))) {\n            // joy, there's plenty of room\n            producerBufferLimit = pBufferLimit - 1;\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else if (null == lvRefElement(buffer, calcCircularRefElementOffset(pIndex + 1, mask))) {\n            // buffer is not full\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else {\n            // we got one slot left to write into, and we are not full. Need to link new buffer.\n            // allocate new buffer of same length\n            final E[] newBuffer = allocateRefArray((int) (mask + 2));\n            producerBuffer = newBuffer;\n            producerBufferLimit = pIndex + mask - 1;\n            linkOldToNew(pIndex, buffer, offset, newBuffer, offset, v == null ? s.get() : v);\n        }\n        return true;\n    }",
      "line_number": 45,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "soNext",
        "oldNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final LinkedQueueNode<E> nextNode = newNode(e);\n        LinkedQueueNode<E> oldNode = lpProducerNode();\n        soProducerNode(nextNode);\n        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed\n        // and completes the store in prev.next. This is a \"bubble\".\n        // Inverting the order here will break the `isEmpty` invariant, and will require matching adjustments elsewhere.\n        oldNode.soNext(nextNode);\n        return true;\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "spNext",
        "get",
        "tail.spNext",
        "s.get",
        "IllegalArgumentException",
        "soNext",
        "oldPNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueNode<E> tail = newNode(s.get());\n        final LinkedQueueNode<E> head = tail;\n        for (int i = 1; i < limit; i++) {\n            final LinkedQueueNode<E> temp = newNode(s.get());\n            // spNext : soProducerNode ensures correct construction\n            tail.spNext(temp);\n            tail = temp;\n        }\n        final LinkedQueueNode<E> oldPNode = lpProducerNode();\n        soProducerNode(tail);\n        // same bubble as offer, and for the same reasons.\n        oldPNode.soNext(head);\n        return limit;\n    }",
      "line_number": 82,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscLinkedUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 105,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 47,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, P_INDEX_OFFSET, expect, newValue);\n    }",
      "line_number": 51,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerLimit",
      "signature": "final long lvProducerLimit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerLimit;\n    }",
      "line_number": 83,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerLimit",
      "signature": "final void soProducerLimit(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, P_LIMIT_OFFSET, newValue);\n    }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 118,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, C_INDEX_OFFSET);\n    }",
      "line_number": 122,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, C_INDEX_OFFSET, newValue);\n    }",
      "line_number": 126,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscUnpaddedArrayQueue",
      "signature": "public MpscUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        super(capacity);\n    }",
      "line_number": 156,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerIfBelowThreshold",
      "signature": "public boolean offerIfBelowThreshold(final E e, int threshold) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final long mask = this.mask;\n        final long capacity = mask + 1;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        do {\n            pIndex = lvProducerIndex();\n            long available = producerLimit - pIndex;\n            long size = capacity - available;\n            if (size >= threshold) {\n                final long cIndex = lvConsumerIndex();\n                size = pIndex - cIndex;\n                if (size >= threshold) {\n                    // the size exceeds threshold\n                    return false;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    producerLimit = cIndex + capacity;\n                    // this is racy, but the race is benign\n                    soProducerLimit(producerLimit);\n                }\n            }\n        } while (!casProducerIndex(pIndex, pIndex + 1));\n        /*\n         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on\n         * the index visibility to poll() we would need to handle the case where the element is not visible.\n         */\n        // Won CAS, move on to storing\n        final long offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return true;\n    }",
      "line_number": 168,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        // use a cached view on consumer index (potentially updated in loop)\n        final long mask = this.mask;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        do {\n            pIndex = lvProducerIndex();\n            if (pIndex >= producerLimit) {\n                final long cIndex = lvConsumerIndex();\n                producerLimit = cIndex + mask + 1;\n                if (pIndex >= producerLimit) {\n                    // FULL :(\n                    return false;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    // this is racy, but the race is benign\n                    soProducerLimit(producerLimit);\n                }\n            }\n        } while (!casProducerIndex(pIndex, pIndex + 1));\n        /*\n         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on\n         * the index visibility to poll() we would need to handle the case where the element is not visible.\n         */\n        // Won CAS, move on to storing\n        final long offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return true;\n    }",
      "line_number": 216,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "failFastOffer",
      "signature": "public final int failFastOffer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final long mask = this.mask;\n        final long capacity = mask + 1;\n        final long pIndex = lvProducerIndex();\n        long producerLimit = lvProducerLimit();\n        if (pIndex >= producerLimit) {\n            final long cIndex = lvConsumerIndex();\n            producerLimit = cIndex + capacity;\n            if (pIndex >= producerLimit) {\n                // FULL :(\n                return 1;\n            } else {\n                // update producer limit to the next index that we must recheck the consumer index\n                soProducerLimit(producerLimit);\n            }\n        }\n        // look Ma, no loop!\n        if (!casProducerIndex(pIndex, pIndex + 1)) {\n            // CAS FAIL :(\n            return -1;\n        }\n        // Won CAS, move on to storing\n        final long offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return 0;\n    }",
      "line_number": 256,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        final long cIndex = lpConsumerIndex();\n        final long offset = calcCircularRefElementOffset(cIndex, mask);\n        // Copy field to avoid re-reading after volatile load\n        final E[] buffer = this.buffer;\n        // If we can't see the next available element we can't poll\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            /*\n             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after\n             * winning the CAS on offer but before storing the element in the queue. Other producers may go on\n             * to fill up the queue after this element.\n             */\n            if (cIndex != lvProducerIndex()) {\n                do {\n                    e = lvRefElement(buffer, offset);\n                } while (e == null);\n            } else {\n                return null;\n            }\n        }\n        spRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 1);\n        return e;\n    }",
      "line_number": 297,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        // Copy field to avoid re-reading after volatile load\n        final E[] buffer = this.buffer;\n        final long cIndex = lpConsumerIndex();\n        final long offset = calcCircularRefElementOffset(cIndex, mask);\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            /*\n             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after\n             * winning the CAS on offer but before storing the element in the queue. Other producers may go on\n             * to fill up the queue after this element.\n             */\n            if (cIndex != lvProducerIndex()) {\n                do {\n                    e = lvRefElement(buffer, offset);\n                } while (e == null);\n            } else {\n                return null;\n            }\n        }\n        return e;\n    }",
      "line_number": 333,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final E[] buffer = this.buffer;\n        final long cIndex = lpConsumerIndex();\n        final long offset = calcCircularRefElementOffset(cIndex, mask);\n        // If we can't see the next available element we can't poll\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            return null;\n        }\n        spRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 1);\n        return e;\n    }",
      "line_number": 362,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final long cIndex = lpConsumerIndex();\n        return lvRefElement(buffer, calcCircularRefElementOffset(cIndex, mask));\n    }",
      "line_number": 377,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final long cIndex = lpConsumerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = cIndex + i;\n            final long offset = calcCircularRefElementOffset(index, mask);\n            final E e = lvRefElement(buffer, offset);\n            if (null == e) {\n                return i;\n            }\n            spRefElement(buffer, offset, null);\n            // ordered store -> atomic and ordered for size()\n            soConsumerIndex(index + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 385,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final long mask = this.mask;\n        final long capacity = mask + 1;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        int actualLimit;\n        do {\n            pIndex = lvProducerIndex();\n            long available = producerLimit - pIndex;\n            if (available <= 0) {\n                final long cIndex = lvConsumerIndex();\n                producerLimit = cIndex + capacity;\n                available = producerLimit - pIndex;\n                if (available <= 0) {\n                    // FULL :(\n                    return 0;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    soProducerLimit(producerLimit);\n                }\n            }\n            actualLimit = Math.min((int) available, limit);\n        } while (!casProducerIndex(pIndex, pIndex + actualLimit));\n        // right, now we claimed a few slots and can fill them with goodness\n        final E[] buffer = this.buffer;\n        for (int i = 0; i < actualLimit; i++) {\n            // Won CAS, move on to storing\n            final long offset = calcCircularRefElementOffset(pIndex + i, mask);\n            soRefElement(buffer, offset, s.get());\n        }\n        return actualLimit;\n    }",
      "line_number": 411,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 461,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 466,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/ConcurrentCircularUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void clear() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/ConcurrentCircularUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 4,
      "source_code": "        while (poll() != null) {\n            // if you stare into the void\n        }\n    }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/ConcurrentCircularUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "WeakIterator",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final long cIndex = lvConsumerIndex();\n        final long pIndex = lvProducerIndex();\n        return new WeakIterator(cIndex, pIndex, mask, buffer);\n    }",
      "line_number": 98,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/ConcurrentCircularUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "            final E e = nextElement;\n            if (e == null)\n                throw new NoSuchElementException();\n            nextElement = getNext();\n            return e;\n        }",
      "line_number": 135,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNext",
      "signature": "private E getNext() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/ConcurrentCircularUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            while (nextIndex < pIndex) {\n                long offset = calcCircularRefElementOffset(nextIndex++, mask);\n                E e = lvRefElement(buffer, offset);\n                if (e != null) {\n                    return e;\n                }\n            }\n            return null;\n        }",
      "line_number": 143,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscGrowableUnpaddedArrayQueue",
      "signature": "public SpscGrowableUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscGrowableUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max",
        "Pow2.roundToPowerOfTwo",
        "roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        this(Math.max(8, Pow2.roundToPowerOfTwo(capacity / 8)), capacity);\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscGrowableUnpaddedArrayQueue",
      "signature": "public SpscGrowableUnpaddedArrayQueue(final int chunkSize, final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscGrowableUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkLessThan",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "checkLessThan",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(capacity, 16, \"capacity\");\n        // minimal chunk size of eight makes sure minimal lookahead step is 2\n        RangeUtil.checkGreaterThanOrEqual(chunkSize, 8, \"chunkSize\");\n        maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);\n        int chunkCapacity = Pow2.roundToPowerOfTwo(chunkSize);\n        RangeUtil.checkLessThan(chunkCapacity, maxQueueCapacity, \"chunkCapacity\");\n        long mask = chunkCapacity - 1;\n        // need extra element to point at next array\n        E[] buffer = allocateRefArray(chunkCapacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        producerBufferLimit = mask - 1;\n        adjustLookAheadStep(chunkCapacity);\n    }",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(final E[] buffer, final long mask, final long index, final long offset, final E v, final Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscGrowableUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        final long lookAheadStep = this.lookAheadStep;\n        // normal case, go around the buffer or resize if full (unless we hit max capacity)\n        if (lookAheadStep > 0) {\n            long lookAheadElementOffset = calcCircularRefElementOffset(index + lookAheadStep, mask);\n            // Try and look ahead a number of elements so we don't have to do this all the time\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                // joy, there's plenty of room\n                producerBufferLimit = index + lookAheadStep - 1;\n                writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n                return true;\n            }\n            // we're at max capacity, can use up last element\n            final int maxCapacity = maxQueueCapacity;\n            if (mask + 1 == maxCapacity) {\n                if (null == lvRefElement(buffer, offset)) {\n                    writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n                    return true;\n                }\n                // we're full and can't grow\n                return false;\n            }\n            // not at max capacity, so must allow extra slot for next buffer pointer\n            if (null == lvRefElement(buffer, calcCircularRefElementOffset(index + 1, mask))) {\n                // buffer is not full\n                writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n            } else {\n                // allocate new buffer of same length\n                final E[] newBuffer = allocateRefArray((int) (2 * (mask + 1) + 1));\n                producerBuffer = newBuffer;\n                producerMask = length(newBuffer) - 2;\n                final long offsetInNew = calcCircularRefElementOffset(index, producerMask);\n                linkOldToNew(index, buffer, offset, newBuffer, offsetInNew, v == null ? s.get() : v);\n                int newCapacity = (int) (producerMask + 1);\n                if (newCapacity == maxCapacity) {\n                    ",
      "line_number": 64,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "adjustLookAheadStep",
      "signature": "private void adjustLookAheadStep(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscGrowableUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "SpscLookAheadUtil.computeLookAheadStep",
        "computeLookAheadStep"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": "        lookAheadStep = SpscLookAheadUtil.computeLookAheadStep(capacity);\n    }",
      "line_number": 139,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "ConcurrentSequencedCircularUnpaddedArrayQueue",
      "signature": "public ConcurrentSequencedCircularUnpaddedArrayQueue(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/ConcurrentSequencedCircularUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        super(capacity);\n        int actualCapacity = (int) (this.mask + 1);\n        // pad data on either end with some empty slots. Note that actualCapacity is <= MAX_POW2_INT\n        sequenceBuffer = allocateLongArray(actualCapacity);\n        for (long i = 0; i < actualCapacity; i++) {\n            soLongElement(sequenceBuffer, calcCircularLongElementOffset(i, mask), i);\n        }\n    }",
      "line_number": 27,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(E[] buffer, long mask, long pIndex, long offset, E v, Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscChunkedUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        // use a fixed lookahead step based on buffer capacity\n        final long lookAheadStep = (mask + 1) / 4;\n        long pBufferLimit = pIndex + lookAheadStep;\n        long pQueueLimit = producerQueueLimit;\n        if (pIndex >= pQueueLimit) {\n            // we tested against a potentially out of date queue limit, refresh it\n            final long cIndex = lvConsumerIndex();\n            producerQueueLimit = pQueueLimit = cIndex + maxQueueCapacity;\n            // if we're full we're full\n            if (pIndex >= pQueueLimit) {\n                return false;\n            }\n        }\n        // if buffer limit is after queue limit we use queue limit. We need to handle overflow so\n        // cannot use Math.min\n        if (pBufferLimit - pQueueLimit > 0) {\n            pBufferLimit = pQueueLimit;\n        }\n        // go around the buffer or add a new buffer\n        if (// there's sufficient room in buffer/queue to use pBufferLimit\n        pBufferLimit > pIndex + 1 && null == lvRefElement(buffer, calcCircularRefElementOffset(pBufferLimit, mask))) {\n            // joy, there's plenty of room\n            producerBufferLimit = pBufferLimit - 1;\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else if (null == lvRefElement(buffer, calcCircularRefElementOffset(pIndex + 1, mask))) {\n            // buffer is not full\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else {\n            // we got one slot left to write into, and we are not full. Need to link new buffer.\n            // allocate new buffer of same length\n            final E[] newBuffer = allocateRefArray((int) (mask + 2));\n            producerBuffer = newBuffer;\n            linkOldToNew(pIndex, buffer, offset, newBuffer, offset, v == null ? s.get() : v);\n        }\n        return true;\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(E[] buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscGrowableUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "RangeUtil.checkLessThanOrEqual",
        "checkLessThanOrEqual"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final long maxSize = maxQueueCapacity / 2;\n        RangeUtil.checkLessThanOrEqual(length(buffer), maxSize, \"buffer.length\");\n        final int newSize = 2 * (length(buffer) - 1);\n        return newSize + 1;\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/MpscGrowableUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (mask + 2 == maxQueueCapacity) ? maxQueueCapacity : mask;\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 47,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, P_INDEX_OFFSET);\n    }",
      "line_number": 51,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, P_INDEX_OFFSET, newValue);\n    }",
      "line_number": 55,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 86,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casConsumerIndex",
      "signature": "final boolean casConsumerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, C_INDEX_OFFSET, expect, newValue);\n    }",
      "line_number": 90,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndexCache",
      "signature": "protected final long lvProducerIndexCache() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndexCache;\n    }",
      "line_number": 120,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "svProducerIndexCache",
      "signature": "protected final void svProducerIndexCache(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        producerIndexCache = newValue;\n    }",
      "line_number": 124,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpmcUnpaddedArrayQueue",
      "signature": "public SpmcUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        super(capacity);\n    }",
      "line_number": 146,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final long currProducerIndex = lvProducerIndex();\n        final long offset = calcCircularRefElementOffset(currProducerIndex, mask);\n        if (null != lvRefElement(buffer, offset)) {\n            long size = currProducerIndex - lvConsumerIndex();\n            if (size > mask) {\n                return false;\n            } else {\n                // Bubble: This can happen because `poll` moves index before placing element.\n                // spin wait for slot to clear, buggers wait freedom\n                while (null != lvRefElement(buffer, offset)) {\n                    // BURN\n                }\n            }\n        }\n        soRefElement(buffer, offset, e);\n        // single producer, so store ordered is valid. It is also required to correctly publish the element\n        // and for the consumers to pick up the tail value.\n        soProducerIndex(currProducerIndex + 1);\n        return true;\n    }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 6,
      "source_code": "        long currentConsumerIndex;\n        long currProducerIndexCache = lvProducerIndexCache();\n        do {\n            currentConsumerIndex = lvConsumerIndex();\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return null;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n        } while (!casConsumerIndex(currentConsumerIndex, currentConsumerIndex + 1));\n        // consumers are gated on latest visible tail, and so can't see a null value in the queue or overtake\n        // and wrap to hit same location.\n        return removeElement(buffer, currentConsumerIndex, mask);\n    }",
      "line_number": 179,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "removeElement",
      "signature": "private E removeElement(final E[] buffer, long index, final long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final long offset = calcCircularRefElementOffset(index, mask);\n        // load plain, element happens before it's index becomes visible\n        final E e = lpRefElement(buffer, offset);\n        // store ordered, make sure nulling out is visible. Producer is waiting for this value.\n        soRefElement(buffer, offset, null);\n        return e;\n    }",
      "line_number": 199,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        long currProducerIndexCache = lvProducerIndexCache();\n        long currentConsumerIndex;\n        long nextConsumerIndex = lvConsumerIndex();\n        E e;\n        do {\n            currentConsumerIndex = nextConsumerIndex;\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return null;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n            e = lvRefElement(buffer, calcCircularRefElementOffset(currentConsumerIndex, mask));\n            // sandwich the element load between 2 consumer index loads\n            nextConsumerIndex = lvConsumerIndex();\n        } while (null == e || nextConsumerIndex != currentConsumerIndex);\n        return e;\n    }",
      "line_number": 209,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final long producerIndex = lpProducerIndex();\n        final long offset = calcCircularRefElementOffset(producerIndex, mask);\n        if (null != lvRefElement(buffer, offset)) {\n            return false;\n        }\n        soRefElement(buffer, offset, e);\n        // single producer, so store ordered is valid. It is also required to correctly publish the element\n        // and for the consumers to pick up the tail value.\n        soProducerIndex(producerIndex + 1);\n        return true;\n    }",
      "line_number": 235,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        long currentConsumerIndex;\n        long nextConsumerIndex = lvConsumerIndex();\n        E e;\n        do {\n            currentConsumerIndex = nextConsumerIndex;\n            e = lvRefElement(buffer, calcCircularRefElementOffset(currentConsumerIndex, mask));\n            // sandwich the element load between 2 consumer index loads\n            nextConsumerIndex = lvConsumerIndex();\n        } while (nextConsumerIndex != currentConsumerIndex);\n        return e;\n    }",
      "line_number": 259,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "accept",
        "min",
        "c.accept",
        "Math.min",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 13,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        long currProducerIndexCache = lvProducerIndexCache();\n        int adjustedLimit = 0;\n        long currentConsumerIndex;\n        do {\n            currentConsumerIndex = lvConsumerIndex();\n            // is there any space in the queue?\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return 0;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n            // try and claim up to 'limit' elements in one go\n            int remaining = (int) (currProducerIndexCache - currentConsumerIndex);\n            adjustedLimit = Math.min(remaining, limit);\n        } while (!casConsumerIndex(currentConsumerIndex, currentConsumerIndex + adjustedLimit));\n        for (int i = 0; i < adjustedLimit; i++) {\n            c.accept(removeElement(buffer, currentConsumerIndex + i, mask));\n        }\n        return adjustedLimit;\n    }",
      "line_number": 275,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "get",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        long producerIndex = this.lpProducerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long offset = calcCircularRefElementOffset(producerIndex, mask);\n            if (null != lvRefElement(buffer, offset)) {\n                return i;\n            }\n            producerIndex++;\n            soRefElement(buffer, offset, s.get());\n            // ordered store -> atomic and ordered for size()\n            soProducerIndex(producerIndex);\n        }\n        return limit;\n    }",
      "line_number": 310,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return MessagePassingQueueUtil.drain(this, c);\n    }",
      "line_number": 334,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return fill(s, capacity());\n    }",
      "line_number": 339,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(final Consumer<E> c, final WaitStrategy w, final ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 344,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(final Supplier<E> s, final WaitStrategy w, final ExitCondition e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpmcUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, w, e);\n    }",
      "line_number": 349,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 65,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, P_INDEX_OFFSET);\n    }",
      "line_number": 69,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(final long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, P_INDEX_OFFSET, newValue);\n    }",
      "line_number": 73,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(this, C_INDEX_OFFSET);\n    }",
      "line_number": 103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(this, C_INDEX_OFFSET);\n    }",
      "line_number": 107,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(final long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, C_INDEX_OFFSET, newValue);\n    }",
      "line_number": 111,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscUnpaddedArrayQueue",
      "signature": "public SpscUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        super(Math.max(capacity, 4));\n    }",
      "line_number": 146,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "this.lpProducerIndex",
        "lpProducerIndex"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        // local load of field to avoid repeated loads after volatile reads\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final long producerIndex = this.lpProducerIndex();\n        if (producerIndex >= producerLimit && !offerSlowPath(buffer, mask, producerIndex)) {\n            return false;\n        }\n        final long offset = calcCircularRefElementOffset(producerIndex, mask);\n        soRefElement(buffer, offset, e);\n        // ordered store -> atomic and ordered for size()\n        soProducerIndex(producerIndex + 1);\n        return true;\n    }",
      "line_number": 156,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerSlowPath",
      "signature": "private boolean offerSlowPath(final E[] buffer, final long mask, final long producerIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final int lookAheadStep = this.lookAheadStep;\n        if (null == lvRefElement(buffer, calcCircularRefElementOffset(producerIndex + lookAheadStep, mask))) {\n            producerLimit = producerIndex + lookAheadStep;\n        } else {\n            final long offset = calcCircularRefElementOffset(producerIndex, mask);\n            if (null != lvRefElement(buffer, offset)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "line_number": 174,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "lpConsumerIndex",
        "this.lpConsumerIndex"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        final long consumerIndex = this.lpConsumerIndex();\n        final long offset = calcCircularRefElementOffset(consumerIndex, mask);\n        // local load of field to avoid repeated loads after volatile reads\n        final E[] buffer = this.buffer;\n        final E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            return null;\n        }\n        soRefElement(buffer, offset, null);\n        // ordered store -> atomic and ordered for size()\n        soConsumerIndex(consumerIndex + 1);\n        return e;\n    }",
      "line_number": 193,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return lvRefElement(buffer, calcCircularRefElementOffset(lpConsumerIndex(), mask));\n    }",
      "line_number": 214,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(final E message) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return offer(message);\n    }",
      "line_number": 219,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return drain(c, capacity());\n    }",
      "line_number": 234,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return fill(s, capacity());\n    }",
      "line_number": 239,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "accept",
        "c.accept",
        "IllegalArgumentException",
        "this.lpConsumerIndex",
        "lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final long consumerIndex = this.lpConsumerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = consumerIndex + i;\n            final long offset = calcCircularRefElementOffset(index, mask);\n            final E e = lvRefElement(buffer, offset);\n            if (null == e) {\n                return i;\n            }\n            soRefElement(buffer, offset, null);\n            // ordered store -> atomic and ordered for size()\n            soConsumerIndex(index + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 244,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final int lookAheadStep = this.lookAheadStep;\n        final long producerIndex = this.lpProducerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = producerIndex + i;\n            final long lookAheadElementOffset = calcCircularRefElementOffset(index + lookAheadStep, mask);\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                int lookAheadLimit = Math.min(lookAheadStep, limit - i);\n                for (int j = 0; j < lookAheadLimit; j++) {\n                    final long offset = calcCircularRefElementOffset(index + j, mask);\n                    soRefElement(buffer, offset, s.get());\n                    // ordered store -> atomic and ordered for size()\n                    soProducerIndex(index + j + 1);\n                }\n                i += lookAheadLimit - 1;\n            } else {\n                final long offset = calcCircularRefElementOffset(index, mask);\n                if (null != lvRefElement(buffer, offset)) {\n                    return i;\n                }\n                soRefElement(buffer, offset, s.get());\n                // ordered store -> atomic and ordered for size()\n                soProducerIndex(index + 1);\n            }\n        }\n        return limit;\n    }",
      "line_number": 270,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(final Consumer<E> c, final WaitStrategy w, final ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "exit.keepRunning",
        "accept",
        "w.idle",
        "c.accept",
        "IllegalArgumentException",
        "this.lpConsumerIndex",
        "keepRunning",
        "idle",
        "lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (null == w)\n            throw new IllegalArgumentException(\"wait is null\");\n        if (null == exit)\n            throw new IllegalArgumentException(\"exit condition is null\");\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        long consumerIndex = this.lpConsumerIndex();\n        int counter = 0;\n        while (exit.keepRunning()) {\n            for (int i = 0; i < 4096; i++) {\n                final long offset = calcCircularRefElementOffset(consumerIndex, mask);\n                final E e = lvRefElement(buffer, offset);\n                if (null == e) {\n                    counter = w.idle(counter);\n                    continue;\n                }\n                consumerIndex++;\n                counter = 0;\n                soRefElement(buffer, offset, null);\n                // ordered store -> atomic and ordered for size()\n                soConsumerIndex(consumerIndex);\n                c.accept(e);\n            }\n        }\n    }",
      "line_number": 307,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(final Supplier<E> s, final WaitStrategy w, final ExitCondition e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "e.keepRunning",
        "w.idle",
        "get",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "keepRunning",
        "idle",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 29,
      "source_code": "        if (null == w)\n            throw new IllegalArgumentException(\"waiter is null\");\n        if (null == e)\n            throw new IllegalArgumentException(\"exit condition is null\");\n        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        final E[] buffer = this.buffer;\n        final long mask = this.mask;\n        final int lookAheadStep = this.lookAheadStep;\n        long producerIndex = this.lpProducerIndex();\n        int counter = 0;\n        while (e.keepRunning()) {\n            final long lookAheadElementOffset = calcCircularRefElementOffset(producerIndex + lookAheadStep, mask);\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                for (int j = 0; j < lookAheadStep; j++) {\n                    final long offset = calcCircularRefElementOffset(producerIndex, mask);\n                    producerIndex++;\n                    soRefElement(buffer, offset, s.get());\n                    // ordered store -> atomic and ordered for size()\n                    soProducerIndex(producerIndex);\n                }\n            } else {\n                final long offset = calcCircularRefElementOffset(producerIndex, mask);\n                if (null != lvRefElement(buffer, offset)) {\n                    counter = w.idle(counter);\n                    continue;\n                }\n                producerIndex++;\n                counter = 0;\n                soRefElement(buffer, offset, s.get());\n                // ordered store -> atomic and ordered for size()\n                soProducerIndex(producerIndex);\n            }\n        }\n    }",
      "line_number": 337,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscUnboundedAtomicUnpaddedArrayQueue",
      "signature": "public MpscUnboundedAtomicUnpaddedArrayQueue(int chunkSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscUnboundedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(chunkSize);\n    }",
      "line_number": 31,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscUnboundedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        return length(buffer);\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscUnboundedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return mask;\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscUnboundedAtomicUnpaddedArrayQueue",
      "signature": "public SpscUnboundedAtomicUnpaddedArrayQueue(int chunkSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscUnboundedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "Math.max",
        "max",
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        int chunkCapacity = Math.max(Pow2.roundToPowerOfTwo(chunkSize), 16);\n        long mask = chunkCapacity - 1;\n        AtomicReferenceArray<E> buffer = allocateRefArray(chunkCapacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        producerBufferLimit = mask - 1;\n    }",
      "line_number": 34,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(AtomicReferenceArray<E> buffer, long mask, long pIndex, int offset, E v, Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscUnboundedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        // use a fixed lookahead step based on buffer capacity\n        final long lookAheadStep = (mask + 1) / 4;\n        long pBufferLimit = pIndex + lookAheadStep;\n        // go around the buffer or add a new buffer\n        if (null == lvRefElement(buffer, calcCircularRefElementOffset(pBufferLimit, mask))) {\n            // joy, there's plenty of room\n            producerBufferLimit = pBufferLimit - 1;\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else if (null == lvRefElement(buffer, calcCircularRefElementOffset(pIndex + 1, mask))) {\n            // buffer is not full\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else {\n            // we got one slot left to write into, and we are not full. Need to link new buffer.\n            // allocate new buffer of same length\n            final AtomicReferenceArray<E> newBuffer = allocateRefArray((int) (mask + 2));\n            producerBuffer = newBuffer;\n            producerBufferLimit = pIndex + mask - 1;\n            linkOldToNew(pIndex, buffer, offset, newBuffer, offset, v == null ? s.get() : v);\n        }\n        return true;\n    }",
      "line_number": 47,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscLinkedAtomicUnpaddedQueue",
      "signature": "public SpscLinkedAtomicUnpaddedQueue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "node.soNext",
        "soNext",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        LinkedQueueAtomicNode<E> node = newNode();\n        spProducerNode(node);\n        spConsumerNode(node);\n        // this ensures correct construction: StoreStore\n        node.soNext(null);\n    }",
      "line_number": 41,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "soNext",
        "oldNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final LinkedQueueAtomicNode<E> nextNode = newNode(e);\n        LinkedQueueAtomicNode<E> oldNode = lpProducerNode();\n        soProducerNode(nextNode);\n        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed\n        // and completes the store in prev.next. This is a \"bubble\".\n        // Inverting the order here will break the `isEmpty` invariant, and will require matching adjustments elsewhere.\n        oldNode.soNext(nextNode);\n        return true;\n    }",
      "line_number": 65,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "spNext",
        "get",
        "tail.spNext",
        "s.get",
        "IllegalArgumentException",
        "soNext",
        "oldPNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueAtomicNode<E> tail = newNode(s.get());\n        final LinkedQueueAtomicNode<E> head = tail;\n        for (int i = 1; i < limit; i++) {\n            final LinkedQueueAtomicNode<E> temp = newNode(s.get());\n            // spNext : soProducerNode ensures correct construction\n            tail.spNext(temp);\n            tail = temp;\n        }\n        final LinkedQueueAtomicNode<E> oldPNode = lpProducerNode();\n        soProducerNode(tail);\n        // same bubble as offer, and for the same reasons.\n        oldPNode.soNext(head);\n        return limit;\n    }",
      "line_number": 85,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 108,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 53,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casConsumerIndex",
      "signature": "final boolean casConsumerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "C_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return C_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 88,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpmcAtomicUnpaddedArrayQueue",
      "signature": "public MpmcAtomicUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "Math.max",
        "RangeUtil.checkGreaterThanOrEqual",
        "min",
        "max",
        "Math.min"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(RangeUtil.checkGreaterThanOrEqual(capacity, 2, \"capacity\"));\n        lookAheadStep = Math.max(2, Math.min(capacity() / 4, MAX_LOOK_AHEAD_STEP));\n    }",
      "line_number": 135,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        long pIndex;\n        int seqOffset;\n        long seq;\n        // start with bogus value, hope we don't need it\n        long cIndex = Long.MIN_VALUE;\n        do {\n            pIndex = lvProducerIndex();\n            seqOffset = calcCircularLongElementOffset(pIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            // consumer has not moved this seq forward, it's as last producer left\n            if (seq < pIndex) {\n                // Extra check required to ensure [Queue.offer == false iff queue is full]\n                if (// test against cached cIndex\n                pIndex - capacity >= cIndex && // test against latest cIndex\n                pIndex - capacity >= (cIndex = lvConsumerIndex())) {\n                    return false;\n                } else {\n                    // (+) hack to make it go around again without CAS\n                    seq = pIndex + 1;\n                }\n            }\n        } while (// another producer has moved the sequence(or +)\n        seq > pIndex || // failed to increment\n        !casProducerIndex(pIndex, pIndex + 1));\n        // casProducerIndex ensures correct construction\n        spRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), e);\n        // seq++;\n        soLongElement(sBuffer, seqOffset, pIndex + 1);\n        return true;\n    }",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicLong",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "poll",
        "Queue.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        long seq;\n        int seqOffset;\n        long expectedSeq;\n        // start with bogus value, hope we don't need it\n        long pIndex = -1;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                // slot has not been moved by producer\n                if (// test against cached pIndex\n                cIndex >= pIndex && // update pIndex if we must\n                cIndex == (pIndex = lvProducerIndex())) {\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                } else {\n                    // trip another go around\n                    seq = expectedSeq + 1;\n                }\n            }\n        } while (// another consumer beat us to it\n        seq > expectedSeq || // failed the CAS\n        !casConsumerIndex(cIndex, cIndex + 1));\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        final E e = lpRefElement(buffer, offset);\n        spRefElement(buffer, offset, null);\n        // i.e. seq += capacity\n        soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n        return e;\n    }",
      "line_number": 186,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicLong",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "poll",
        "Queue.poll"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        long seq;\n        int seqOffset;\n        long expectedSeq;\n        // start with bogus value, hope we don't need it\n        long pIndex = -1;\n        E e;\n        while (true) {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                // slot has not been moved by producer\n                if (// test against cached pIndex\n                cIndex >= pIndex && // update pIndex if we must\n                cIndex == (pIndex = lvProducerIndex())) {\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                }\n            } else if (seq == expectedSeq) {\n                final int offset = calcCircularRefElementOffset(cIndex, mask);\n                e = lvRefElement(buffer, offset);\n                if (lvConsumerIndex() == cIndex)\n                    return e;\n            }\n        }\n    }",
      "line_number": 225,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        long pIndex;\n        int seqOffset;\n        long seq;\n        do {\n            pIndex = lvProducerIndex();\n            seqOffset = calcCircularLongElementOffset(pIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            if (seq < pIndex) {\n                // slot not cleared by consumer yet\n                return false;\n            }\n        } while (// another producer has moved the sequence\n        seq > pIndex || // failed to increment\n        !casProducerIndex(pIndex, pIndex + 1));\n        // casProducerIndex ensures correct construction\n        spRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), e);\n        soLongElement(sBuffer, seqOffset, pIndex + 1);\n        return true;\n    }",
      "line_number": 259,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        int seqOffset;\n        long seq;\n        long expectedSeq;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                return null;\n            }\n        } while (// another consumer beat us to it\n        seq > expectedSeq || // failed the CAS\n        !casConsumerIndex(cIndex, cIndex + 1));\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        final E e = lpRefElement(buffer, offset);\n        spRefElement(buffer, offset, null);\n        soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n        return e;\n    }",
      "line_number": 286,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicLong",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        long cIndex;\n        long seq;\n        int seqOffset;\n        long expectedSeq;\n        E e;\n        do {\n            cIndex = lvConsumerIndex();\n            seqOffset = calcCircularLongElementOffset(cIndex, mask);\n            seq = lvLongElement(sBuffer, seqOffset);\n            expectedSeq = cIndex + 1;\n            if (seq < expectedSeq) {\n                return null;\n            } else if (seq == expectedSeq) {\n                final int offset = calcCircularRefElementOffset(cIndex, mask);\n                e = lvRefElement(buffer, offset);\n                if (lvConsumerIndex() == cIndex)\n                    return e;\n            }\n        } while (true);\n    }",
      "line_number": 312,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "accept",
        "min",
        "c.accept",
        "Math.min",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int maxLookAheadStep = Math.min(this.lookAheadStep, limit);\n        int consumed = 0;\n        while (consumed < limit) {\n            final int remaining = limit - consumed;\n            final int lookAheadStep = Math.min(remaining, maxLookAheadStep);\n            final long cIndex = lvConsumerIndex();\n            final long lookAheadIndex = cIndex + lookAheadStep - 1;\n            final int lookAheadSeqOffset = calcCircularLongElementOffset(lookAheadIndex, mask);\n            final long lookAheadSeq = lvLongElement(sBuffer, lookAheadSeqOffset);\n            final long expectedLookAheadSeq = lookAheadIndex + 1;\n            if (lookAheadSeq == expectedLookAheadSeq && casConsumerIndex(cIndex, expectedLookAheadSeq)) {\n                for (int i = 0; i < lookAheadStep; i++) {\n                    final long index = cIndex + i;\n                    final int seqOffset = calcCircularLongElementOffset(index, mask);\n                    final int offset = calcCircularRefElementOffset(index, mask);\n                    final long expectedSeq = index + 1;\n                    while (lvLongElement(sBuffer, seqOffset) != expectedSeq) {\n                    }\n                    final E e = lpRefElement(buffer, offset);\n                    spRefElement(buffer, offset, null);\n                    soLongElement(sBuffer, seqOffset, index + mask + 1);\n                    c.accept(e);\n                }\n                consumed += lookAheadStep;\n            } else {\n                if (lookAheadSeq < expectedLookAheadSeq) {\n                    if (notAvailable(cIndex, mask, sBuffer, cIndex + 1)) {\n         ",
      "line_number": 338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drainOneByOne",
      "signature": "private int drainOneByOne(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        long cIndex;\n        int seqOffset;\n        long seq;\n        long expectedSeq;\n        for (int i = 0; i < limit; i++) {\n            do {\n                cIndex = lvConsumerIndex();\n                seqOffset = calcCircularLongElementOffset(cIndex, mask);\n                seq = lvLongElement(sBuffer, seqOffset);\n                expectedSeq = cIndex + 1;\n                if (seq < expectedSeq) {\n                    return i;\n                }\n            } while (// another consumer beat us to it\n            seq > expectedSeq || // failed the CAS\n            !casConsumerIndex(cIndex, cIndex + 1));\n            final int offset = calcCircularRefElementOffset(cIndex, mask);\n            final E e = lpRefElement(buffer, offset);\n            spRefElement(buffer, offset, null);\n            soLongElement(sBuffer, seqOffset, cIndex + mask + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 384,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int maxLookAheadStep = Math.min(this.lookAheadStep, limit);\n        int produced = 0;\n        while (produced < limit) {\n            final int remaining = limit - produced;\n            final int lookAheadStep = Math.min(remaining, maxLookAheadStep);\n            final long pIndex = lvProducerIndex();\n            final long lookAheadIndex = pIndex + lookAheadStep - 1;\n            final int lookAheadSeqOffset = calcCircularLongElementOffset(lookAheadIndex, mask);\n            final long lookAheadSeq = lvLongElement(sBuffer, lookAheadSeqOffset);\n            final long expectedLookAheadSeq = lookAheadIndex;\n            if (lookAheadSeq == expectedLookAheadSeq && casProducerIndex(pIndex, expectedLookAheadSeq + 1)) {\n                for (int i = 0; i < lookAheadStep; i++) {\n                    final long index = pIndex + i;\n                    final int seqOffset = calcCircularLongElementOffset(index, mask);\n                    final int offset = calcCircularRefElementOffset(index, mask);\n                    while (lvLongElement(sBuffer, seqOffset) != index) {\n                    }\n                    // Ordered store ensures correct construction\n                    soRefElement(buffer, offset, s.get());\n                    soLongElement(sBuffer, seqOffset, index + 1);\n                }\n                produced += lookAheadStep;\n            } else {\n                if (lookAheadSeq < expectedLookAheadSeq) {\n                    if (notAvailable(pIndex, mask, sBuffer, pIndex)) {\n                        return produced;\n                    }\n                }\n                retur",
      "line_number": 414,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "notAvailable",
      "signature": "private boolean notAvailable(long index, int mask, AtomicLongArray sBuffer, long expectedSeq) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final int seqOffset = calcCircularLongElementOffset(index, mask);\n        final long seq = lvLongElement(sBuffer, seqOffset);\n        if (seq < expectedSeq) {\n            return true;\n        }\n        return false;\n    }",
      "line_number": 458,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fillOneByOne",
      "signature": "private int fillOneByOne(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicReferenceArray",
        "final",
        "AtomicLongArray"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        final AtomicLongArray sBuffer = sequenceBuffer;\n        final int mask = this.mask;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        long pIndex;\n        int seqOffset;\n        long seq;\n        for (int i = 0; i < limit; i++) {\n            do {\n                pIndex = lvProducerIndex();\n                seqOffset = calcCircularLongElementOffset(pIndex, mask);\n                seq = lvLongElement(sBuffer, seqOffset);\n                if (seq < pIndex) {\n                    // slot not cleared by consumer yet\n                    return i;\n                }\n            } while (// another producer has moved the sequence\n            seq > pIndex || // failed to increment\n            !casProducerIndex(pIndex, pIndex + 1));\n            // Ordered store ensures correct construction\n            soRefElement(buffer, calcCircularRefElementOffset(pIndex, mask), s.get());\n            soLongElement(sBuffer, seqOffset, pIndex + 1);\n        }\n        return limit;\n    }",
      "line_number": 467,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 504,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 509,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spProducerNode",
      "signature": "final void spProducerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_NODE_UPDATER.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        P_NODE_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 41,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerNode",
      "signature": "final void soProducerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_NODE_UPDATER.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        P_NODE_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 45,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerNode",
      "signature": "final LinkedQueueAtomicNode<E> lvProducerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return producerNode;\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerNode",
      "signature": "final boolean casProducerNode(LinkedQueueAtomicNode<E> expect, LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_NODE_UPDATER.compareAndSet",
        "compareAndSet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        return P_NODE_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 53,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerNode",
      "signature": "final LinkedQueueAtomicNode<E> lpProducerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return producerNode;\n    }",
      "line_number": 57,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "xchgProducerNode",
      "signature": "protected final LinkedQueueAtomicNode<E> xchgProducerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "getAndSet"
      ],
      "dependencies": [
        "P_NODE_UPDATER.getAndSet",
        "getAndSet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        return P_NODE_UPDATER.getAndSet(this, newValue);\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spConsumerNode",
      "signature": "final void spConsumerNode(LinkedQueueAtomicNode<E> newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_NODE_UPDATER.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        C_NODE_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 83,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerNode",
      "signature": "final LinkedQueueAtomicNode<E> lvConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return consumerNode;\n    }",
      "line_number": 88,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerNode",
      "signature": "final LinkedQueueAtomicNode<E> lpConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        return consumerNode;\n    }",
      "line_number": 92,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public final Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 114,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 119,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newNode",
      "signature": "protected final LinkedQueueAtomicNode<E> newNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "LinkedQueueAtomicNode",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        return new LinkedQueueAtomicNode<E>();\n    }",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newNode",
      "signature": "protected final LinkedQueueAtomicNode<E> newNode(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "LinkedQueueAtomicNode",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        return new LinkedQueueAtomicNode<E>(e);\n    }",
      "line_number": 127,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public final int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lvNext",
        "chaserNode.lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 19,
      "source_code": "        // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n        // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n        LinkedQueueAtomicNode<E> chaserNode = lvConsumerNode();\n        LinkedQueueAtomicNode<E> producerNode = lvProducerNode();\n        int size = 0;\n        // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n        while (// don't go passed producer node\n        chaserNode != producerNode && // stop at last node\n        chaserNode != null && // stop at max int\n        size < Integer.MAX_VALUE) {\n            LinkedQueueAtomicNode<E> next;\n            next = chaserNode.lvNext();\n            // check if this node has been consumed, if so return what we have\n            if (next == chaserNode) {\n                return size;\n            }\n            chaserNode = next;\n            size++;\n        }\n        return size;\n    }",
      "line_number": 142,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        LinkedQueueAtomicNode<E> consumerNode = lvConsumerNode();\n        LinkedQueueAtomicNode<E> producerNode = lvProducerNode();\n        return consumerNode == producerNode;\n    }",
      "line_number": 176,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getSingleConsumerNodeValue",
      "signature": "protected E getSingleConsumerNodeValue(LinkedQueueAtomicNode<E> currConsumerNode, LinkedQueueAtomicNode<E> nextNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getAndNullValue",
        "currConsumerNode.soNext",
        "soNext",
        "nextNode.getAndNullValue",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // we have to null out the value because we are going to hang on to the node\n        final E nextValue = nextNode.getAndNullValue();\n        // Fix up the next ref of currConsumerNode to prevent promoted nodes from keeping new ones alive.\n        // We use a reference to self instead of null because null is already a meaningful value (the next of\n        // producer node is null).\n        currConsumerNode.soNext(currConsumerNode);\n        spConsumerNode(nextNode);\n        // currConsumerNode is now no longer referenced and can be collected\n        return nextValue;\n    }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final LinkedQueueAtomicNode<E> currConsumerNode = lpConsumerNode();\n        LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        } else if (currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n            // got the next node...\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        }\n        return null;\n    }",
      "line_number": 216,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "lpValue",
        "currConsumerNode.lvNext",
        "lvNext",
        "nextNode.lpValue",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        final LinkedQueueAtomicNode<E> currConsumerNode = lpConsumerNode();\n        LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        } else if (currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n            // got the next node...\n            return nextNode.lpValue();\n        }\n        return null;\n    }",
      "line_number": 248,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "spinWaitForNextNode",
      "signature": "LinkedQueueAtomicNode<E> spinWaitForNextNode(LinkedQueueAtomicNode<E> currNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait"
      ],
      "dependencies": [
        "lvNext",
        "currNode.lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 16,
      "source_code": "        LinkedQueueAtomicNode<E> nextNode;\n        while ((nextNode = currNode.lvNext()) == null) {\n            // spin, we are no longer wait free\n        }\n        return nextNode;\n    }",
      "line_number": 261,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        final LinkedQueueAtomicNode<E> currConsumerNode = lpConsumerNode();\n        final LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode != null) {\n            return getSingleConsumerNodeValue(currConsumerNode, nextNode);\n        }\n        return null;\n    }",
      "line_number": 270,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lpValue",
        "lvNext",
        "nextNode.lpValue",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "        final LinkedQueueAtomicNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        }\n        return null;\n    }",
      "line_number": 280,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "this.lpConsumerNode",
        "accept",
        "E",
        "lvNext",
        "c.accept",
        "IllegalArgumentException",
        "chaserNode.lvNext",
        "lpConsumerNode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueAtomicNode<E> chaserNode = this.lpConsumerNode();\n        for (int i = 0; i < limit; i++) {\n            final LinkedQueueAtomicNode<E> nextNode = chaserNode.lvNext();\n            if (nextNode == null) {\n                return i;\n            }\n            // we have to null out the value because we are going to hang on to the node\n            final E nextValue = getSingleConsumerNodeValue(chaserNode, nextNode);\n            chaserNode = nextNode;\n            c.accept(nextValue);\n        }\n        return limit;\n    }",
      "line_number": 294,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 321,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 87,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casConsumerIndex",
      "signature": "final boolean casConsumerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "C_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return C_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 91,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndexCache",
      "signature": "protected final long lvProducerIndexCache() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndexCache;\n    }",
      "line_number": 121,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "svProducerIndexCache",
      "signature": "protected final void svProducerIndexCache(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        producerIndexCache = newValue;\n    }",
      "line_number": 125,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpmcAtomicUnpaddedArrayQueue",
      "signature": "public SpmcAtomicUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(capacity);\n    }",
      "line_number": 147,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "wait",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long currProducerIndex = lvProducerIndex();\n        final int offset = calcCircularRefElementOffset(currProducerIndex, mask);\n        if (null != lvRefElement(buffer, offset)) {\n            long size = currProducerIndex - lvConsumerIndex();\n            if (size > mask) {\n                return false;\n            } else {\n                // Bubble: This can happen because `poll` moves index before placing element.\n                // spin wait for slot to clear, buggers wait freedom\n                while (null != lvRefElement(buffer, offset)) {\n                    // BURN\n                }\n            }\n        }\n        soRefElement(buffer, offset, e);\n        // single producer, so store ordered is valid. It is also required to correctly publish the element\n        // and for the consumers to pick up the tail value.\n        soProducerIndex(currProducerIndex + 1);\n        return true;\n    }",
      "line_number": 152,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 6,
      "source_code": "        long currentConsumerIndex;\n        long currProducerIndexCache = lvProducerIndexCache();\n        do {\n            currentConsumerIndex = lvConsumerIndex();\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return null;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n        } while (!casConsumerIndex(currentConsumerIndex, currentConsumerIndex + 1));\n        // consumers are gated on latest visible tail, and so can't see a null value in the queue or overtake\n        // and wrap to hit same location.\n        return removeElement(buffer, currentConsumerIndex, mask);\n    }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "removeElement",
      "signature": "private E removeElement(final AtomicReferenceArray<E> buffer, long index, final int mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "wait",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final int offset = calcCircularRefElementOffset(index, mask);\n        // load plain, element happens before it's index becomes visible\n        final E e = lpRefElement(buffer, offset);\n        // store ordered, make sure nulling out is visible. Producer is waiting for this value.\n        soRefElement(buffer, offset, null);\n        return e;\n    }",
      "line_number": 200,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long currProducerIndexCache = lvProducerIndexCache();\n        long currentConsumerIndex;\n        long nextConsumerIndex = lvConsumerIndex();\n        E e;\n        do {\n            currentConsumerIndex = nextConsumerIndex;\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return null;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n            e = lvRefElement(buffer, calcCircularRefElementOffset(currentConsumerIndex, mask));\n            // sandwich the element load between 2 consumer index loads\n            nextConsumerIndex = lvConsumerIndex();\n        } while (null == e || nextConsumerIndex != currentConsumerIndex);\n        return e;\n    }",
      "line_number": 210,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long producerIndex = lpProducerIndex();\n        final int offset = calcCircularRefElementOffset(producerIndex, mask);\n        if (null != lvRefElement(buffer, offset)) {\n            return false;\n        }\n        soRefElement(buffer, offset, e);\n        // single producer, so store ordered is valid. It is also required to correctly publish the element\n        // and for the consumers to pick up the tail value.\n        soProducerIndex(producerIndex + 1);\n        return true;\n    }",
      "line_number": 236,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long currentConsumerIndex;\n        long nextConsumerIndex = lvConsumerIndex();\n        E e;\n        do {\n            currentConsumerIndex = nextConsumerIndex;\n            e = lvRefElement(buffer, calcCircularRefElementOffset(currentConsumerIndex, mask));\n            // sandwich the element load between 2 consumer index loads\n            nextConsumerIndex = lvConsumerIndex();\n        } while (nextConsumerIndex != currentConsumerIndex);\n        return e;\n    }",
      "line_number": 260,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "accept",
        "min",
        "c.accept",
        "Math.min",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object"
      ],
      "complexity_score": 17,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long currProducerIndexCache = lvProducerIndexCache();\n        int adjustedLimit = 0;\n        long currentConsumerIndex;\n        do {\n            currentConsumerIndex = lvConsumerIndex();\n            // is there any space in the queue?\n            if (currentConsumerIndex >= currProducerIndexCache) {\n                long currProducerIndex = lvProducerIndex();\n                if (currentConsumerIndex >= currProducerIndex) {\n                    return 0;\n                } else {\n                    currProducerIndexCache = currProducerIndex;\n                    svProducerIndexCache(currProducerIndex);\n                }\n            }\n            // try and claim up to 'limit' elements in one go\n            int remaining = (int) (currProducerIndexCache - currentConsumerIndex);\n            adjustedLimit = Math.min(remaining, limit);\n        } while (!casConsumerIndex(currentConsumerIndex, currentConsumerIndex + adjustedLimit));\n        for (int i = 0; i < adjustedLimit; i++) {\n            c.accept(removeElement(buffer, currentConsumerIndex + i, mask));\n        }\n        return adjustedLimit;\n    }",
      "line_number": 276,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "get",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long producerIndex = this.lpProducerIndex();\n        for (int i = 0; i < limit; i++) {\n            final int offset = calcCircularRefElementOffset(producerIndex, mask);\n            if (null != lvRefElement(buffer, offset)) {\n                return i;\n            }\n            producerIndex++;\n            soRefElement(buffer, offset, s.get());\n            // ordered store -> atomic and ordered for size()\n            soProducerIndex(producerIndex);\n        }\n        return limit;\n    }",
      "line_number": 311,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return MessagePassingQueueUtil.drain(this, c);\n    }",
      "line_number": 335,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return fill(s, capacity());\n    }",
      "line_number": 340,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(final Consumer<E> c, final WaitStrategy w, final ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 345,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(final Supplier<E> s, final WaitStrategy w, final ExitCondition e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpmcAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "final"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, w, e);\n    }",
      "line_number": 350,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscGrowableAtomicUnpaddedArrayQueue",
      "signature": "public SpscGrowableAtomicUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max",
        "Pow2.roundToPowerOfTwo",
        "roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        this(Math.max(8, Pow2.roundToPowerOfTwo(capacity / 8)), capacity);\n    }",
      "line_number": 41,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscGrowableAtomicUnpaddedArrayQueue",
      "signature": "public SpscGrowableAtomicUnpaddedArrayQueue(final int chunkSize, final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkLessThan",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "checkLessThan",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(capacity, 16, \"capacity\");\n        // minimal chunk size of eight makes sure minimal lookahead step is 2\n        RangeUtil.checkGreaterThanOrEqual(chunkSize, 8, \"chunkSize\");\n        maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);\n        int chunkCapacity = Pow2.roundToPowerOfTwo(chunkSize);\n        RangeUtil.checkLessThan(chunkCapacity, maxQueueCapacity, \"chunkCapacity\");\n        long mask = chunkCapacity - 1;\n        // need extra element to point at next array\n        AtomicReferenceArray<E> buffer = allocateRefArray(chunkCapacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        producerBufferLimit = mask - 1;\n        adjustLookAheadStep(chunkCapacity);\n    }",
      "line_number": 45,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(final AtomicReferenceArray<E> buffer, final long mask, final long index, final int offset, final E v, final Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        final long lookAheadStep = this.lookAheadStep;\n        // normal case, go around the buffer or resize if full (unless we hit max capacity)\n        if (lookAheadStep > 0) {\n            int lookAheadElementOffset = calcCircularRefElementOffset(index + lookAheadStep, mask);\n            // Try and look ahead a number of elements so we don't have to do this all the time\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                // joy, there's plenty of room\n                producerBufferLimit = index + lookAheadStep - 1;\n                writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n                return true;\n            }\n            // we're at max capacity, can use up last element\n            final int maxCapacity = maxQueueCapacity;\n            if (mask + 1 == maxCapacity) {\n                if (null == lvRefElement(buffer, offset)) {\n                    writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n                    return true;\n                }\n                // we're full and can't grow\n                return false;\n            }\n            // not at max capacity, so must allow extra slot for next buffer pointer\n            if (null == lvRefElement(buffer, calcCircularRefElementOffset(index + 1, mask))) {\n                // buffer is not full\n                writeToQueue(buffer, v == null ? s.get() : v, index, offset);\n            } else {\n                // allocate new buffer of same length\n                final AtomicReferenceArray<E> newBuffer = allocateRefArray((int) (2 * (mask + 1) + 1));\n                producerBuffer = newBuffer;\n                producerMask = length(newBuffer) - 2;\n                final int offsetInNew = calcCircularRefElementOffset(index, producerMask);\n                linkOldToNew(index, buffer, offset, newBuffer, offsetInNew, v == null ? s.get() : v);\n                int newCapacity = (int) (producerMask + 1);\n                if (newCapacity == maxCapacity) {\n  ",
      "line_number": 65,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "adjustLookAheadStep",
      "signature": "private void adjustLookAheadStep(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "SpscLookAheadUtil.computeLookAheadStep",
        "computeLookAheadStep"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": "        lookAheadStep = SpscLookAheadUtil.computeLookAheadStep(capacity);\n    }",
      "line_number": 140,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 46,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 50,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 54,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 81,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 85,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 89,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerLimit",
      "signature": "final long lvProducerLimit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerLimit;\n    }",
      "line_number": 115,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerLimit",
      "signature": "final boolean casProducerLimit(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "P_LIMIT_UPDATER.compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_LIMIT_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 119,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerLimit",
      "signature": "final void soProducerLimit(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_LIMIT_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_LIMIT_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "BaseMpscLinkedAtomicUnpaddedArrayQueue",
      "signature": "public BaseMpscLinkedAtomicUnpaddedArrayQueue(final int initialCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(initialCapacity, 2, \"initialCapacity\");\n        int p2capacity = Pow2.roundToPowerOfTwo(initialCapacity);\n        // leave lower bit of mask clear\n        long mask = (p2capacity - 1) << 1;\n        // need extra element to point at next array\n        AtomicReferenceArray<E> buffer = allocateRefArray(p2capacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        soProducerLimit(mask);\n    }",
      "line_number": 155,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 185,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        long mask;\n        AtomicReferenceArray<E> buffer;\n        long pIndex;\n        while (true) {\n            long producerLimit = lvProducerLimit();\n            pIndex = lvProducerIndex();\n            // lower bit is indicative of resize, if we see it we spin until it's cleared\n            if ((pIndex & 1) == 1) {\n                continue;\n            }\n            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1)\n            // mask/buffer may get changed by resizing -> only use for array access after successful CAS.\n            mask = this.producerMask;\n            buffer = this.producerBuffer;\n            // a successful CAS ties the ordering, lv(pIndex) - [mask/buffer] -> cas(pIndex)\n            // assumption behind this optimization is that queue is almost always empty or near empty\n            if (producerLimit <= pIndex) {\n                int result = offerSlowPath(mask, pIndex, producerLimit);\n                switch(result) {\n                    case CONTINUE_TO_P_INDEX_CAS:\n                        break;\n                    case RETRY:\n                        continue;\n                    case QUEUE_FULL:\n                        return false;\n                    case QUEUE_RESIZE:\n                        resize(mask, buffer, pIndex, e, null);\n                        return true;\n                }\n            }\n            if (casProducerIndex(pIndex, pIndex + 2)) {\n                break;\n            }\n        }\n        // INDEX visible before ELEMENT\n        final int offset = modifiedCalcCircularRefElementOffset(pIndex, mask);\n        // release element e\n        soRefElement(buffer, offset, e);\n        return true;\n    }",
      "line_number": 190,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            long pIndex = lvProducerIndex();\n            // isEmpty?\n            if ((cIndex - pIndex) / 2 == 0) {\n                return null;\n            }\n            // poll() == null iff queue is empty, null element is not strong enough indicator, so we must\n            // spin until element is visible.\n            do {\n                e = lvRefElement(buffer, offset);\n            } while (e == null);\n        }\n        if (e == JUMP) {\n            final AtomicReferenceArray<E> nextBuffer = nextBuffer(buffer, mask);\n            return newBufferPoll(nextBuffer, cIndex);\n        }\n        // release element null\n        soRefElement(buffer, offset, null);\n        // release cIndex\n        soConsumerIndex(cIndex + 2);\n        return (E) e;\n    }",
      "line_number": 242,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            long pIndex = lvProducerIndex();\n            // isEmpty?\n            if ((cIndex - pIndex) / 2 == 0) {\n                return null;\n            }\n            // peek() == null iff queue is empty, null element is not strong enough indicator, so we must\n            // spin until element is visible.\n            do {\n                e = lvRefElement(buffer, offset);\n            } while (e == null);\n        }\n        if (e == JUMP) {\n            return newBufferPeek(nextBuffer(buffer, mask), cIndex);\n        }\n        return (E) e;\n    }",
      "line_number": 278,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerSlowPath",
      "signature": "private int offerSlowPath(long mask, long pIndex, long producerLimit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final long cIndex = lvConsumerIndex();\n        long bufferCapacity = getCurrentBufferCapacity(mask);\n        if (cIndex + bufferCapacity > pIndex) {\n            if (!casProducerLimit(producerLimit, cIndex + bufferCapacity)) {\n                // retry from top\n                return RETRY;\n            } else {\n                // continue to pIndex CAS\n                return CONTINUE_TO_P_INDEX_CAS;\n            }\n        } else // full and cannot grow\n        if (availableInQueue(pIndex, cIndex) <= 0) {\n            // offer should return false;\n            return QUEUE_FULL;\n        } else // grab index for resize -> set lower bit\n        if (casProducerIndex(pIndex, pIndex + 1)) {\n            // trigger a resize\n            return QUEUE_RESIZE;\n        } else {\n            // failed resize attempt, retry from top\n            return RETRY;\n        }\n    }",
      "line_number": 305,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "nextBuffer",
      "signature": "private AtomicReferenceArray<E> nextBuffer(final AtomicReferenceArray<E> buffer, final long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final int offset = nextArrayOffset(mask);\n        final AtomicReferenceArray<E> nextBuffer = (AtomicReferenceArray<E>) lvRefElement(buffer, offset);\n        consumerBuffer = nextBuffer;\n        consumerMask = (length(nextBuffer) - 2) << 1;\n        soRefElement(buffer, offset, BUFFER_CONSUMED);\n        return nextBuffer;\n    }",
      "line_number": 336,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "nextArrayOffset",
      "signature": "private static int nextArrayOffset(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return modifiedCalcCircularRefElementOffset(mask + 2, Long.MAX_VALUE);\n    }",
      "line_number": 345,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPoll",
      "signature": "private E newBufferPoll(AtomicReferenceArray<E> nextBuffer, long cIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalStateException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final int offset = modifiedCalcCircularRefElementOffset(cIndex, consumerMask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (n == null) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        }\n        soRefElement(nextBuffer, offset, null);\n        soConsumerIndex(cIndex + 2);\n        return n;\n    }",
      "line_number": 349,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPeek",
      "signature": "private E newBufferPeek(AtomicReferenceArray<E> nextBuffer, long cIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalStateException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final int offset = modifiedCalcCircularRefElementOffset(cIndex, consumerMask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (null == n) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        }\n        return n;\n    }",
      "line_number": 360,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == null) {\n            return null;\n        }\n        if (e == JUMP) {\n            final AtomicReferenceArray<E> nextBuffer = nextBuffer(buffer, mask);\n            return newBufferPoll(nextBuffer, cIndex);\n        }\n        soRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 2);\n        return (E) e;\n    }",
      "line_number": 389,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long cIndex = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);\n        Object e = lvRefElement(buffer, offset);\n        if (e == JUMP) {\n            return newBufferPeek(nextBuffer(buffer, mask), cIndex);\n        }\n        return (E) e;\n    }",
      "line_number": 409,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        // result is a long because we want to have a safepoint check at regular intervals\n        long result = 0;\n        final int capacity = capacity();\n        do {\n            final int filled = fill(s, PortableJvmInfo.RECOMENDED_OFFER_BATCH);\n            if (filled == 0) {\n                return (int) result;\n            }\n            result += filled;\n        } while (result <= capacity);\n        return (int) result;\n    }",
      "line_number": 422,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        long mask;\n        AtomicReferenceArray<E> buffer;\n        long pIndex;\n        int claimedSlots;\n        while (true) {\n            long producerLimit = lvProducerLimit();\n            pIndex = lvProducerIndex();\n            // lower bit is indicative of resize, if we see it we spin until it's cleared\n            if ((pIndex & 1) == 1) {\n                continue;\n            }\n            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1)\n            // NOTE: mask/buffer may get changed by resizing -> only use for array access after successful CAS.\n            // Only by virtue offloading them between the lvProducerIndex and a successful casProducerIndex are they\n            // safe to use.\n            mask = this.producerMask;\n            buffer = this.producerBuffer;\n            // a successful CAS ties the ordering, lv(pIndex) -> [mask/buffer] -> cas(pIndex)\n            // we want 'limit' slots, but will settle for whatever is visible to 'producerLimit'\n            // -> producerLimit >= batchIndex\n            long batchIndex = Math.min(producerLimit, pIndex + 2l * limit);\n            if (pIndex >= producerLimit) {\n                int result = offerSlowPath(mask, pIndex, producerLimit);\n                switch(result) {\n                    case CONTINUE_TO_P_INDEX_CAS:\n                    // offer slow path verifies only one slot ahead, we cannot rely on indication here\n                    case RETRY:\n                        continue;\n                    case QUEUE_FULL:\n                        return 0;\n                    case QUEUE_RESIZE:\n                        resize(mask, buffer, pIndex, null, s);\n                        return 1;\n                }\n            }\n            // claim limit slots at o",
      "line_number": 437,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 493,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 508,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            final E e = nextElement;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n            nextElement = getNext();\n            return e;\n        }",
      "line_number": 561,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "setBuffer",
      "signature": "private void setBuffer(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            this.currentBuffer = buffer;\n            this.mask = length(buffer) - 2;\n        }",
      "line_number": 570,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNext",
      "signature": "private E getNext() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "            while (nextIndex < pIndex) {\n                long index = nextIndex++;\n                E e = lvRefElement(currentBuffer, calcCircularRefElementOffset(index, mask));\n                // skip removed/not yet visible elements\n                if (e == null) {\n                    continue;\n                }\n                // not null && not JUMP -> found next element\n                if (e != JUMP) {\n                    return e;\n                }\n                // need to jump to the next buffer\n                int nextBufferIndex = mask + 1;\n                Object nextBuffer = lvRefElement(currentBuffer, calcRefElementOffset(nextBufferIndex));\n                if (nextBuffer == BUFFER_CONSUMED || nextBuffer == null) {\n                    // Consumer may have passed us, or the next buffer is not visible yet: drop out early\n                    return null;\n                }\n                setBuffer((AtomicReferenceArray<E>) nextBuffer);\n                // now with the new array retry the load, it can't be a JUMP, but we need to repeat same index\n                e = lvRefElement(currentBuffer, calcCircularRefElementOffset(index, mask));\n                // skip removed/not yet visible elements\n                if (e == null) {\n                    continue;\n                } else {\n                    return e;\n                }\n            }\n            return null;\n        }",
      "line_number": 575,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private void resize(long oldMask, AtomicReferenceArray<E> oldBuffer, long pIndex, E e, Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseMpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "RangeUtil.checkPositive",
        "checkPositive",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        assert (e != null && s == null) || (e == null || s != null);\n        int newBufferLength = getNextBufferSize(oldBuffer);\n        final AtomicReferenceArray<E> newBuffer;\n        try {\n            newBuffer = allocateRefArray(newBufferLength);\n        } catch (OutOfMemoryError oom) {\n            assert lvProducerIndex() == pIndex + 1;\n            soProducerIndex(pIndex);\n            throw oom;\n        }\n        producerBuffer = newBuffer;\n        final int newMask = (newBufferLength - 2) << 1;\n        producerMask = newMask;\n        final int offsetInOld = modifiedCalcCircularRefElementOffset(pIndex, oldMask);\n        final int offsetInNew = modifiedCalcCircularRefElementOffset(pIndex, newMask);\n        // element in new array\n        soRefElement(newBuffer, offsetInNew, e == null ? s.get() : e);\n        // buffer linked\n        soRefElement(oldBuffer, nextArrayOffset(oldMask), newBuffer);\n        // ASSERT code\n        final long cIndex = lvConsumerIndex();\n        final long availableInQueue = availableInQueue(pIndex, cIndex);\n        RangeUtil.checkPositive(availableInQueue, \"availableInQueue\");\n        // Invalidate racing CASs\n        // We never set the limit beyond the bounds of a buffer\n        soProducerLimit(pIndex + Math.min(newMask, availableInQueue));\n        // make resize visible to the other producers\n        soProducerIndex(pIndex + 2);\n        // INDEX visible before ELEMENT, consistent with consumer expectation\n        // make resize visible to consumer\n        soRefElement(oldBuffer, offsetInOld, JUMP);\n    }",
      "line_number": 608,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 54,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 58,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 85,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 89,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 93,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public final Iterator<E> iterator() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 121,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public final int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "size",
        "IndexedQueueSizeUtil.size"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return IndexedQueueSizeUtil.size(this, IndexedQueueSizeUtil.PLAIN_DIVISOR);\n    }",
      "line_number": 126,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public final boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IndexedQueueSizeUtil.isEmpty",
        "isEmpty"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return IndexedQueueSizeUtil.isEmpty(this);\n    }",
      "line_number": 131,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "this.getClass",
        "getClass",
        "getName"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return this.getClass().getName();\n    }",
      "line_number": 136,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soNext",
      "signature": "protected final void soNext(AtomicReferenceArray<E> curr, AtomicReferenceArray<E> next) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        int offset = nextArrayOffset(curr);\n        soRefElement(curr, offset, next);\n    }",
      "line_number": 150,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvNextArrayAndUnlink",
      "signature": "protected final AtomicReferenceArray<E> lvNextArrayAndUnlink(AtomicReferenceArray<E> curr) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final int offset = nextArrayOffset(curr);\n        final AtomicReferenceArray<E> nextBuffer = (AtomicReferenceArray<E>) lvRefElement(curr, offset);\n        // prevent GC nepotism\n        soRefElement(curr, offset, null);\n        return nextBuffer;\n    }",
      "line_number": 156,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        // result is a long because we want to have a safepoint check at regular intervals\n        long result = 0;\n        final int capacity = capacity();\n        do {\n            final int filled = fill(s, PortableJvmInfo.RECOMENDED_OFFER_BATCH);\n            if (filled == 0) {\n                return (int) result;\n            }\n            result += filled;\n        } while (result <= capacity);\n        return (int) result;\n    }",
      "line_number": 185,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        for (int i = 0; i < limit; i++) {\n            // local load of field to avoid repeated loads after volatile reads\n            final AtomicReferenceArray<E> buffer = producerBuffer;\n            final long index = lpProducerIndex();\n            final long mask = producerMask;\n            final int offset = calcCircularRefElementOffset(index, mask);\n            // expected hot path\n            if (index < producerBufferLimit) {\n                writeToQueue(buffer, s.get(), index, offset);\n            } else {\n                if (!offerColdPath(buffer, mask, index, offset, null, s)) {\n                    return i;\n                }\n            }\n        }\n        return limit;\n    }",
      "line_number": 205,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, wait, exit);\n    }",
      "line_number": 231,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 236,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "Objects.requireNonNull",
        "requireNonNull",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        // Objects.requireNonNull(e);\n        if (null == e) {\n            throw new NullPointerException();\n        }\n        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = producerBuffer;\n        final long index = lpProducerIndex();\n        final long mask = producerMask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        // expected hot path\n        if (index < producerBufferLimit) {\n            writeToQueue(buffer, e, index, offset);\n            return true;\n        }\n        return offerColdPath(buffer, mask, index, offset, e, null);\n    }",
      "line_number": 246,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long index = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        final Object e = lvRefElement(buffer, offset);\n        boolean isNextBuffer = e == JUMP;\n        if (null != e && !isNextBuffer) {\n            // this ensures correctness on 32bit platforms\n            soConsumerIndex(index + 1);\n            soRefElement(buffer, offset, null);\n            return (E) e;\n        } else if (isNextBuffer) {\n            return newBufferPoll(buffer, index);\n        }\n        return null;\n    }",
      "line_number": 273,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final AtomicReferenceArray<E> buffer = consumerBuffer;\n        final long index = lpConsumerIndex();\n        final long mask = consumerMask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        final Object e = lvRefElement(buffer, offset);\n        if (e == JUMP) {\n            return newBufferPeek(buffer, index);\n        }\n        return (E) e;\n    }",
      "line_number": 299,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "linkOldToNew",
      "signature": "final void linkOldToNew(final long currIndex, final AtomicReferenceArray<E> oldBuffer, final int offset, final AtomicReferenceArray<E> newBuffer, final int offsetInNew, final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        soRefElement(newBuffer, offsetInNew, e);\n        // link to next buffer and add next indicator as element of old buffer\n        soNext(oldBuffer, newBuffer);\n        soRefElement(oldBuffer, offset, JUMP);\n        // index is visible after elements (isEmpty/poll ordering)\n        // this ensures atomic write of long on 32bit platforms\n        soProducerIndex(currIndex + 1);\n    }",
      "line_number": 311,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "writeToQueue",
      "signature": "final void writeToQueue(final AtomicReferenceArray<E> buffer, final E e, final long index, final int offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        soRefElement(buffer, offset, e);\n        // this ensures atomic write of long on 32bit platforms\n        soProducerIndex(index + 1);\n    }",
      "line_number": 321,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPeek",
      "signature": "private E newBufferPeek(final AtomicReferenceArray<E> buffer, final long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        AtomicReferenceArray<E> nextBuffer = lvNextArrayAndUnlink(buffer);\n        consumerBuffer = nextBuffer;\n        final long mask = length(nextBuffer) - 2;\n        consumerMask = mask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        return lvRefElement(nextBuffer, offset);\n    }",
      "line_number": 327,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "newBufferPoll",
      "signature": "private E newBufferPoll(final AtomicReferenceArray<E> buffer, final long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/BaseSpscLinkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalStateException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        AtomicReferenceArray<E> nextBuffer = lvNextArrayAndUnlink(buffer);\n        consumerBuffer = nextBuffer;\n        final long mask = length(nextBuffer) - 2;\n        consumerMask = mask;\n        final int offset = calcCircularRefElementOffset(index, mask);\n        final E n = lvRefElement(nextBuffer, offset);\n        if (null == n) {\n            throw new IllegalStateException(\"new buffer must have at least one element\");\n        } else {\n            // this ensures correctness on 32bit platforms\n            soConsumerIndex(index + 1);\n            soRefElement(nextBuffer, offset, null);\n            return n;\n        }\n    }",
      "line_number": 336,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscChunkedAtomicUnpaddedArrayQueue",
      "signature": "public MpscChunkedAtomicUnpaddedArrayQueue(int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscChunkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(max(2, min(1024, roundToPowerOfTwo(maxCapacity / 8))), maxCapacity);\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscChunkedAtomicUnpaddedArrayQueue",
      "signature": "public MpscChunkedAtomicUnpaddedArrayQueue(int initialCapacity, int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscChunkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(initialCapacity, maxCapacity);\n    }",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscChunkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        return length(buffer);\n    }",
      "line_number": 78,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscChunkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return mask;\n    }",
      "line_number": 83,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscGrowableAtomicUnpaddedArrayQueue",
      "signature": "public MpscGrowableAtomicUnpaddedArrayQueue(int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Math.max",
        "max",
        "Pow2.roundToPowerOfTwo",
        "roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(Math.max(2, Pow2.roundToPowerOfTwo(maxCapacity / 8)), maxCapacity);\n    }",
      "line_number": 34,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscGrowableAtomicUnpaddedArrayQueue",
      "signature": "public MpscGrowableAtomicUnpaddedArrayQueue(int initialCapacity, int maxCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(initialCapacity, maxCapacity);\n    }",
      "line_number": 45,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextBufferSize",
      "signature": "protected int getNextBufferSize(AtomicReferenceArray<E> buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "RangeUtil.checkLessThanOrEqual",
        "checkLessThanOrEqual",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final long maxSize = maxQueueCapacity / 2;\n        RangeUtil.checkLessThanOrEqual(length(buffer), maxSize, \"buffer.length\");\n        final int newSize = 2 * (length(buffer) - 1);\n        return newSize + 1;\n    }",
      "line_number": 50,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getCurrentBufferCapacity",
      "signature": "protected long getCurrentBufferCapacity(long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscGrowableAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (mask + 2 == maxQueueCapacity) ? maxQueueCapacity : mask;\n    }",
      "line_number": 58,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscLinkedAtomicUnpaddedQueue",
      "signature": "public MpscLinkedAtomicUnpaddedQueue() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        LinkedQueueAtomicNode<E> node = newNode();\n        spConsumerNode(node);\n        xchgProducerNode(node);\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "prevProducerNode.soNext",
        "NullPointerException",
        "soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final LinkedQueueAtomicNode<E> nextNode = newNode(e);\n        final LinkedQueueAtomicNode<E> prevProducerNode = xchgProducerNode(nextNode);\n        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed\n        // and completes the store in prev.next. This is a \"bubble\".\n        prevProducerNode.soNext(nextNode);\n        return true;\n    }",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "lpValue",
        "E",
        "currConsumerNode.soNext",
        "currConsumerNode.lpValue",
        "soNext",
        "equals",
        "o.equals",
        "prevConsumerNode.soNext",
        "currConsumerNode.spValue",
        "spValue"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 33,
      "source_code": "        if (null == o) {\n            // Null elements are not permitted, so null will never be removed.\n            return false;\n        }\n        final LinkedQueueAtomicNode<E> originalConsumerNode = lpConsumerNode();\n        LinkedQueueAtomicNode<E> prevConsumerNode = originalConsumerNode;\n        LinkedQueueAtomicNode<E> currConsumerNode = getNextConsumerNode(originalConsumerNode);\n        while (currConsumerNode != null) {\n            if (o.equals(currConsumerNode.lpValue())) {\n                LinkedQueueAtomicNode<E> nextNode = getNextConsumerNode(currConsumerNode);\n                // e.g.: consumerNode -> node0 -> node1(o==v) -> node2 ... => consumerNode -> node0 -> node2\n                if (nextNode != null) {\n                    // We are removing an interior node.\n                    prevConsumerNode.soNext(nextNode);\n                } else // This case reflects: prevConsumerNode != originalConsumerNode && nextNode == null\n                // At rest, this would be the producerNode, but we must contend with racing. Changes to subclassed\n                // queues need to consider remove() when implementing offer().\n                {\n                    // producerNode is currConsumerNode, try to atomically update the reference to move it to the\n                    // previous node.\n                    prevConsumerNode.soNext(null);\n                    if (!casProducerNode(currConsumerNode, prevConsumerNode)) {\n                        // If the producer(s) have offered more items we need to remove the currConsumerNode link.\n                        nextNode = spinWaitForNextNode(currConsumerNode);\n                        prevConsumerNode.soNext(nextNode);\n                    }\n                }\n                // Avoid GC nepotism because we are discarding the current node.\n                currConsumerNode.soNext(null);\n                currConsumerNode.spValue(null);\n                return true;\n            }\n            prevConsumerNode = currConsumerNode;\n  ",
      "line_number": 82,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "spNext",
        "get",
        "tail.spNext",
        "s.get",
        "IllegalArgumentException",
        "soNext",
        "oldPNode.soNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 21,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        LinkedQueueAtomicNode<E> tail = newNode(s.get());\n        final LinkedQueueAtomicNode<E> head = tail;\n        for (int i = 1; i < limit; i++) {\n            final LinkedQueueAtomicNode<E> temp = newNode(s.get());\n            // spNext: xchgProducerNode ensures correct construction\n            tail.spNext(temp);\n            tail = temp;\n        }\n        final LinkedQueueAtomicNode<E> oldPNode = xchgProducerNode(tail);\n        oldPNode.soNext(head);\n        return limit;\n    }",
      "line_number": 127,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 148,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "getNextConsumerNode",
      "signature": "private LinkedQueueAtomicNode<E> getNextConsumerNode(LinkedQueueAtomicNode<E> currConsumerNode) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscLinkedAtomicUnpaddedQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait"
      ],
      "dependencies": [
        "currConsumerNode.lvNext",
        "lvNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        LinkedQueueAtomicNode<E> nextNode = currConsumerNode.lvNext();\n        if (nextNode == null && currConsumerNode != lvProducerNode()) {\n            nextNode = spinWaitForNextNode(currConsumerNode);\n        }\n        return nextNode;\n    }",
      "line_number": 152,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscChunkedAtomicUnpaddedArrayQueue",
      "signature": "public SpscChunkedAtomicUnpaddedArrayQueue(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscChunkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Math.max",
        "max",
        "Pow2.roundToPowerOfTwo",
        "roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        this(Math.max(8, Pow2.roundToPowerOfTwo(capacity / 8)), capacity);\n    }",
      "line_number": 39,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscChunkedAtomicUnpaddedArrayQueue",
      "signature": "public SpscChunkedAtomicUnpaddedArrayQueue(int chunkSize, int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscChunkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "checkGreaterThanOrEqual",
        "RangeUtil.checkLessThan",
        "RangeUtil.checkGreaterThanOrEqual",
        "roundToPowerOfTwo",
        "checkLessThan",
        "Pow2.roundToPowerOfTwo",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        RangeUtil.checkGreaterThanOrEqual(capacity, 16, \"capacity\");\n        // minimal chunk size of eight makes sure minimal lookahead step is 2\n        RangeUtil.checkGreaterThanOrEqual(chunkSize, 8, \"chunkSize\");\n        maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);\n        int chunkCapacity = Pow2.roundToPowerOfTwo(chunkSize);\n        RangeUtil.checkLessThan(chunkCapacity, maxQueueCapacity, \"chunkCapacity\");\n        long mask = chunkCapacity - 1;\n        // need extra element to point at next array\n        AtomicReferenceArray<E> buffer = allocateRefArray(chunkCapacity + 1);\n        producerBuffer = buffer;\n        producerMask = mask;\n        consumerBuffer = buffer;\n        consumerMask = mask;\n        // we know it's all empty to start with\n        producerBufferLimit = mask - 1;\n        producerQueueLimit = maxQueueCapacity;\n    }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerColdPath",
      "signature": "final boolean offerColdPath(AtomicReferenceArray<E> buffer, long mask, long pIndex, int offset, E v, Supplier<? extends E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscChunkedAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E",
        "get",
        "s.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        // use a fixed lookahead step based on buffer capacity\n        final long lookAheadStep = (mask + 1) / 4;\n        long pBufferLimit = pIndex + lookAheadStep;\n        long pQueueLimit = producerQueueLimit;\n        if (pIndex >= pQueueLimit) {\n            // we tested against a potentially out of date queue limit, refresh it\n            final long cIndex = lvConsumerIndex();\n            producerQueueLimit = pQueueLimit = cIndex + maxQueueCapacity;\n            // if we're full we're full\n            if (pIndex >= pQueueLimit) {\n                return false;\n            }\n        }\n        // if buffer limit is after queue limit we use queue limit. We need to handle overflow so\n        // cannot use Math.min\n        if (pBufferLimit - pQueueLimit > 0) {\n            pBufferLimit = pQueueLimit;\n        }\n        // go around the buffer or add a new buffer\n        if (// there's sufficient room in buffer/queue to use pBufferLimit\n        pBufferLimit > pIndex + 1 && null == lvRefElement(buffer, calcCircularRefElementOffset(pBufferLimit, mask))) {\n            // joy, there's plenty of room\n            producerBufferLimit = pBufferLimit - 1;\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else if (null == lvRefElement(buffer, calcCircularRefElementOffset(pIndex + 1, mask))) {\n            // buffer is not full\n            writeToQueue(buffer, v == null ? s.get() : v, pIndex, offset);\n        } else {\n            // we got one slot left to write into, and we are not full. Need to link new buffer.\n            // allocate new buffer of same length\n            final AtomicReferenceArray<E> newBuffer = allocateRefArray((int) (mask + 2));\n            producerBuffer = newBuffer;\n            linkOldToNew(pIndex, buffer, offset, newBuffer, offset, v == null ? s.get() : v);\n        }\n        return true;\n    }",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpProducerIndex",
      "signature": "final long lpProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 70,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "final void soProducerIndex(final long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.lazySet",
        "lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 74,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 104,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 108,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(final long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 112,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "SpscAtomicUnpaddedArrayQueue",
      "signature": "public SpscAtomicUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(Math.max(capacity, 4));\n    }",
      "line_number": 147,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "this.lpProducerIndex",
        "lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long producerIndex = this.lpProducerIndex();\n        if (producerIndex >= producerLimit && !offerSlowPath(buffer, mask, producerIndex)) {\n            return false;\n        }\n        final int offset = calcCircularRefElementOffset(producerIndex, mask);\n        soRefElement(buffer, offset, e);\n        // ordered store -> atomic and ordered for size()\n        soProducerIndex(producerIndex + 1);\n        return true;\n    }",
      "line_number": 157,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerSlowPath",
      "signature": "private boolean offerSlowPath(final AtomicReferenceArray<E> buffer, final int mask, final long producerIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final int lookAheadStep = this.lookAheadStep;\n        if (null == lvRefElement(buffer, calcCircularRefElementOffset(producerIndex + lookAheadStep, mask))) {\n            producerLimit = producerIndex + lookAheadStep;\n        } else {\n            final int offset = calcCircularRefElementOffset(producerIndex, mask);\n            if (null != lvRefElement(buffer, offset)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "line_number": 175,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "lpConsumerIndex",
        "this.lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        final long consumerIndex = this.lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(consumerIndex, mask);\n        // local load of field to avoid repeated loads after volatile reads\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            return null;\n        }\n        soRefElement(buffer, offset, null);\n        // ordered store -> atomic and ordered for size()\n        soConsumerIndex(consumerIndex + 1);\n        return e;\n    }",
      "line_number": 194,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return lvRefElement(buffer, calcCircularRefElementOffset(lpConsumerIndex(), mask));\n    }",
      "line_number": 215,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedOffer",
      "signature": "public boolean relaxedOffer(final E message) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return offer(message);\n    }",
      "line_number": 220,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return drain(c, capacity());\n    }",
      "line_number": 235,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return fill(s, capacity());\n    }",
      "line_number": 240,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "accept",
        "c.accept",
        "IllegalArgumentException",
        "this.lpConsumerIndex",
        "lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long consumerIndex = this.lpConsumerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = consumerIndex + i;\n            final int offset = calcCircularRefElementOffset(index, mask);\n            final E e = lvRefElement(buffer, offset);\n            if (null == e) {\n                return i;\n            }\n            soRefElement(buffer, offset, null);\n            // ordered store -> atomic and ordered for size()\n            soConsumerIndex(index + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 245,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(final Supplier<E> s, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final int lookAheadStep = this.lookAheadStep;\n        final long producerIndex = this.lpProducerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = producerIndex + i;\n            final int lookAheadElementOffset = calcCircularRefElementOffset(index + lookAheadStep, mask);\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                int lookAheadLimit = Math.min(lookAheadStep, limit - i);\n                for (int j = 0; j < lookAheadLimit; j++) {\n                    final int offset = calcCircularRefElementOffset(index + j, mask);\n                    soRefElement(buffer, offset, s.get());\n                    // ordered store -> atomic and ordered for size()\n                    soProducerIndex(index + j + 1);\n                }\n                i += lookAheadLimit - 1;\n            } else {\n                final int offset = calcCircularRefElementOffset(index, mask);\n                if (null != lvRefElement(buffer, offset)) {\n                    return i;\n                }\n                soRefElement(buffer, offset, s.get());\n                // ordered store -> atomic and ordered for size()\n                soProducerIndex(index + 1);\n            }\n        }\n        return limit;\n    }",
      "line_number": 271,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(final Consumer<E> c, final WaitStrategy w, final ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "AtomicReference",
        "AtomicReferenceArray",
        "final"
      ],
      "dependencies": [
        "exit.keepRunning",
        "accept",
        "w.idle",
        "c.accept",
        "IllegalArgumentException",
        "this.lpConsumerIndex",
        "keepRunning",
        "idle",
        "lpConsumerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 26,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (null == w)\n            throw new IllegalArgumentException(\"wait is null\");\n        if (null == exit)\n            throw new IllegalArgumentException(\"exit condition is null\");\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        long consumerIndex = this.lpConsumerIndex();\n        int counter = 0;\n        while (exit.keepRunning()) {\n            for (int i = 0; i < 4096; i++) {\n                final int offset = calcCircularRefElementOffset(consumerIndex, mask);\n                final E e = lvRefElement(buffer, offset);\n                if (null == e) {\n                    counter = w.idle(counter);\n                    continue;\n                }\n                consumerIndex++;\n                counter = 0;\n                soRefElement(buffer, offset, null);\n                // ordered store -> atomic and ordered for size()\n                soConsumerIndex(consumerIndex);\n                c.accept(e);\n            }\n        }\n    }",
      "line_number": 308,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(final Supplier<E> s, final WaitStrategy w, final ExitCondition e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/SpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "AtomicReference",
        "AtomicReferenceArray",
        "final"
      ],
      "dependencies": [
        "e.keepRunning",
        "w.idle",
        "get",
        "lpProducerIndex",
        "s.get",
        "IllegalArgumentException",
        "keepRunning",
        "idle",
        "this.lpProducerIndex",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 33,
      "source_code": "        if (null == w)\n            throw new IllegalArgumentException(\"waiter is null\");\n        if (null == e)\n            throw new IllegalArgumentException(\"exit condition is null\");\n        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final int lookAheadStep = this.lookAheadStep;\n        long producerIndex = this.lpProducerIndex();\n        int counter = 0;\n        while (e.keepRunning()) {\n            final int lookAheadElementOffset = calcCircularRefElementOffset(producerIndex + lookAheadStep, mask);\n            if (null == lvRefElement(buffer, lookAheadElementOffset)) {\n                for (int j = 0; j < lookAheadStep; j++) {\n                    final int offset = calcCircularRefElementOffset(producerIndex, mask);\n                    producerIndex++;\n                    soRefElement(buffer, offset, s.get());\n                    // ordered store -> atomic and ordered for size()\n                    soProducerIndex(producerIndex);\n                }\n            } else {\n                final int offset = calcCircularRefElementOffset(producerIndex, mask);\n                if (null != lvRefElement(buffer, offset)) {\n                    counter = w.idle(counter);\n                    continue;\n                }\n                producerIndex++;\n                counter = 0;\n                soRefElement(buffer, offset, s.get());\n                // ordered store -> atomic and ordered for size()\n                soProducerIndex(producerIndex);\n            }\n        }\n    }",
      "line_number": 338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "P_INDEX_UPDATER.compareAndSet",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return P_INDEX_UPDATER.compareAndSet(this, expect, newValue);\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvProducerLimit",
      "signature": "final long lvProducerLimit() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerLimit;\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soProducerLimit",
      "signature": "final void soProducerLimit(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "P_LIMIT_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        P_LIMIT_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 88,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 119,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "final void soConsumerIndex(long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "C_INDEX_UPDATER.lazySet"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        C_INDEX_UPDATER.lazySet(this, newValue);\n    }",
      "line_number": 127,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "MpscAtomicUnpaddedArrayQueue",
      "signature": "public MpscAtomicUnpaddedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        super(capacity);\n    }",
      "line_number": 157,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offerIfBelowThreshold",
      "signature": "public boolean offerIfBelowThreshold(final E e, int threshold) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        do {\n            pIndex = lvProducerIndex();\n            long available = producerLimit - pIndex;\n            long size = capacity - available;\n            if (size >= threshold) {\n                final long cIndex = lvConsumerIndex();\n                size = pIndex - cIndex;\n                if (size >= threshold) {\n                    // the size exceeds threshold\n                    return false;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    producerLimit = cIndex + capacity;\n                    // this is racy, but the race is benign\n                    soProducerLimit(producerLimit);\n                }\n            }\n        } while (!casProducerIndex(pIndex, pIndex + 1));\n        /*\n         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on\n         * the index visibility to poll() we would need to handle the case where the element is not visible.\n         */\n        // Won CAS, move on to storing\n        final int offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return true;\n    }",
      "line_number": 169,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        // use a cached view on consumer index (potentially updated in loop)\n        final int mask = this.mask;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        do {\n            pIndex = lvProducerIndex();\n            if (pIndex >= producerLimit) {\n                final long cIndex = lvConsumerIndex();\n                producerLimit = cIndex + mask + 1;\n                if (pIndex >= producerLimit) {\n                    // FULL :(\n                    return false;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    // this is racy, but the race is benign\n                    soProducerLimit(producerLimit);\n                }\n            }\n        } while (!casProducerIndex(pIndex, pIndex + 1));\n        /*\n         * NOTE: the new producer index value is made visible BEFORE the element in the array. If we relied on\n         * the index visibility to poll() we would need to handle the case where the element is not visible.\n         */\n        // Won CAS, move on to storing\n        final int offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return true;\n    }",
      "line_number": 217,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "failFastOffer",
      "signature": "public final int failFastOffer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if (null == e) {\n            throw new NullPointerException();\n        }\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        final long pIndex = lvProducerIndex();\n        long producerLimit = lvProducerLimit();\n        if (pIndex >= producerLimit) {\n            final long cIndex = lvConsumerIndex();\n            producerLimit = cIndex + capacity;\n            if (pIndex >= producerLimit) {\n                // FULL :(\n                return 1;\n            } else {\n                // update producer limit to the next index that we must recheck the consumer index\n                soProducerLimit(producerLimit);\n            }\n        }\n        // look Ma, no loop!\n        if (!casProducerIndex(pIndex, pIndex + 1)) {\n            // CAS FAIL :(\n            return -1;\n        }\n        // Won CAS, move on to storing\n        final int offset = calcCircularRefElementOffset(pIndex, mask);\n        soRefElement(buffer, offset, e);\n        // AWESOME :)\n        return 0;\n    }",
      "line_number": 257,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        final long cIndex = lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        // Copy field to avoid re-reading after volatile load\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        // If we can't see the next available element we can't poll\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            /*\n             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after\n             * winning the CAS on offer but before storing the element in the queue. Other producers may go on\n             * to fill up the queue after this element.\n             */\n            if (cIndex != lvProducerIndex()) {\n                do {\n                    e = lvRefElement(buffer, offset);\n                } while (e == null);\n            } else {\n                return null;\n            }\n        }\n        spRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 1);\n        return e;\n    }",
      "line_number": 298,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        // Copy field to avoid re-reading after volatile load\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final long cIndex = lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            /*\n             * NOTE: Queue may not actually be empty in the case of a producer (P1) being interrupted after\n             * winning the CAS on offer but before storing the element in the queue. Other producers may go on\n             * to fill up the queue after this element.\n             */\n            if (cIndex != lvProducerIndex()) {\n                do {\n                    e = lvRefElement(buffer, offset);\n                } while (e == null);\n            } else {\n                return null;\n            }\n        }\n        return e;\n    }",
      "line_number": 334,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPoll",
      "signature": "public E relaxedPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final long cIndex = lpConsumerIndex();\n        final int offset = calcCircularRefElementOffset(cIndex, mask);\n        // If we can't see the next available element we can't poll\n        E e = lvRefElement(buffer, offset);\n        if (null == e) {\n            return null;\n        }\n        spRefElement(buffer, offset, null);\n        soConsumerIndex(cIndex + 1);\n        return e;\n    }",
      "line_number": 363,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "relaxedPeek",
      "signature": "public E relaxedPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long cIndex = lpConsumerIndex();\n        return lvRefElement(buffer, calcCircularRefElementOffset(cIndex, mask));\n    }",
      "line_number": 378,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(final Consumer<E> c, final int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == c)\n            throw new IllegalArgumentException(\"c is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative: \" + limit);\n        if (limit == 0)\n            return 0;\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        final int mask = this.mask;\n        final long cIndex = lpConsumerIndex();\n        for (int i = 0; i < limit; i++) {\n            final long index = cIndex + i;\n            final int offset = calcCircularRefElementOffset(index, mask);\n            final E e = lvRefElement(buffer, offset);\n            if (null == e) {\n                return i;\n            }\n            spRefElement(buffer, offset, null);\n            // ordered store -> atomic and ordered for size()\n            soConsumerIndex(index + 1);\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 386,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public int fill(Supplier<E> s, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "min",
        "get",
        "Math.min",
        "s.get",
        "IllegalArgumentException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (null == s)\n            throw new IllegalArgumentException(\"supplier is null\");\n        if (limit < 0)\n            throw new IllegalArgumentException(\"limit is negative:\" + limit);\n        if (limit == 0)\n            return 0;\n        final int mask = this.mask;\n        final long capacity = mask + 1;\n        long producerLimit = lvProducerLimit();\n        long pIndex;\n        int actualLimit;\n        do {\n            pIndex = lvProducerIndex();\n            long available = producerLimit - pIndex;\n            if (available <= 0) {\n                final long cIndex = lvConsumerIndex();\n                producerLimit = cIndex + capacity;\n                available = producerLimit - pIndex;\n                if (available <= 0) {\n                    // FULL :(\n                    return 0;\n                } else {\n                    // update producer limit to the next index that we must recheck the consumer index\n                    soProducerLimit(producerLimit);\n                }\n            }\n            actualLimit = Math.min((int) available, limit);\n        } while (!casProducerIndex(pIndex, pIndex + actualLimit));\n        // right, now we claimed a few slots and can fill them with goodness\n        final AtomicReferenceArray<E> buffer = this.buffer;\n        for (int i = 0; i < actualLimit; i++) {\n            // Won CAS, move on to storing\n            final int offset = calcCircularRefElementOffset(pIndex + i, mask);\n            soRefElement(buffer, offset, s.get());\n        }\n        return actualLimit;\n    }",
      "line_number": 412,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.drain",
        "drain",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.drain(this, c, w, exit);\n    }",
      "line_number": 462,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "fill",
      "signature": "public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-core/src/main/java/org/jctools/queues/atomic/unpadded/MpscAtomicUnpaddedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition"
      ],
      "dependencies": [
        "MessagePassingQueueUtil.fill",
        "fill",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        MessagePassingQueueUtil.fill(this, s, wait, exit);\n    }",
      "line_number": 467,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "was",
      "method_type": "method"
    },
    {
      "name": "IdentityOpenHashSet",
      "signature": "public IdentityOpenHashSet(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        int actualCapacity = Pow2.roundToPowerOfTwo(capacity);\n        // pad data on either end with some empty slots?\n        buffer = (E[]) new Object[actualCapacity];\n        resizeThreshold = (int) (0.75 * buffer.length);\n    }",
      "line_number": 17,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "constructor"
    },
    {
      "name": "add",
      "signature": "public boolean add(E newVal) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "identityHashCode",
        "System.identityHashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final E[] buffer = this.buffer;\n        final int mask = buffer.length - 1;\n\n        final int hash = System.identityHashCode(newVal);\n        final int offset = hash & mask;\n        final E currVal = buffer[offset];\n\n        boolean result;\n        if (currVal == null) {\n            size++;\n            buffer[offset] = newVal;\n            result = true;\n        } else {\n            result = currVal != newVal && addSlowPath(buffer, mask, newVal, hash);\n        }\n\n        if (result && size > resizeThreshold) {\n            resize();\n        }\n        return result;\n    }",
      "line_number": 30,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "addForResize",
      "signature": "private void addForResize(final E[] buffer, final int mask, E newVal) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "identityHashCode",
        "System.identityHashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final int hash = System.identityHashCode(newVal);\n        final int limit = hash + mask;\n        for (int i = hash; i <= limit; i++) {\n            final int offset = i & mask;\n            final E currVal = buffer[offset];\n            if (currVal == null) {\n                buffer[offset] = newVal;\n                return;\n            }\n        }\n    }",
      "line_number": 53,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "addSlowPath",
      "signature": "private boolean addSlowPath(E[] buffer, int mask, E newVal, int hash) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        final int limit = hash + mask;\n        for (int i = hash + 1; i <= limit; i++) {\n            final int offset = i & mask;\n            final E currVal = buffer[offset];\n            if (currVal == null) {\n                size++;\n                buffer[offset] = newVal;\n                return true;\n            }\n            else if (currVal == newVal) {\n                return false;\n            }\n        }\n        return false;\n    }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private void resize() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        final E[] oldBuffer = buffer;\n        final E[] newBuffer = (E[]) new Object[oldBuffer.length * 2];\n        final int mask = newBuffer.length - 1;\n        int countdown = size;\n        for (int i = 0; i < oldBuffer.length && countdown > 0; i++) {\n            if (oldBuffer[i] != null) {\n                addForResize(newBuffer, mask, oldBuffer[i]);\n                countdown--;\n            }\n        }\n\n        buffer = newBuffer;\n        resizeThreshold = (int) (0.75 * buffer.length);\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object val) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "identityHashCode",
        "System.identityHashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        final E[] buffer = this.buffer;\n        final int mask = buffer.length - 1;\n        final int hash = System.identityHashCode(val);\n        final int offset = hash & mask;\n        final E e = buffer[offset];\n        if (e == null) {\n            return false;\n        }\n        else if (e == val) {\n            size--;\n            if (buffer[(hash + 1) & mask] == null) {\n                buffer[offset] = null;\n            }\n            else {\n                compactAndRemove(buffer, mask, hash);\n            }\n            return true;\n        }\n        return removeSlowPath(val, buffer, mask, hash);\n    }",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "removeSlowPath",
      "signature": "private boolean removeSlowPath(Object val, final E[] buffer, final int mask, final int hash) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final int limit = hash + mask;\n        for (int searchIndex = hash + 1; searchIndex <= limit; searchIndex++) {\n            final int offset = searchIndex & mask;\n            final E e = buffer[offset];\n            if (e == null) {\n                return false;\n            }\n            else if (e == val) {\n                size--;\n                if (buffer[(searchIndex + 1) & mask] == null) {\n                    buffer[offset] = null;\n                }\n                else {\n                    compactAndRemove(buffer, mask, searchIndex);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "compactAndRemove",
      "signature": "private void compactAndRemove(final E[] buffer, final int mask, int removeHashIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "identityHashCode",
        "System.identityHashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 9,
      "source_code": "        // remove(9a): [9a,9b,10a,9c,10b,11a,null] -> [9b,9c,10a,10b,null,11a,null]\n        removeHashIndex = removeHashIndex & mask;\n        int j = removeHashIndex;\n        while(true) {\n            int k;\n            // skip elements which belong where they are\n            do {\n                // j := (j+1) modulo num_slots\n                j = (j + 1) & mask;\n                // if slot[j] is unoccupied exit\n                if (buffer[j] == null) {\n                    // delete last duplicate slot\n                    buffer[removeHashIndex] = null;\n                    return;\n                }\n\n                // k := hash(slot[j].key) modulo num_slots\n                k = System.identityHashCode(buffer[j]) & mask;\n                // determine if k lies cyclically in [i,j]\n                // |    i.k.j |\n                // |....j i.k.| or  |.k..j i...|\n            }\n            while ( (removeHashIndex  <= j) ?\n                    ((removeHashIndex < k) && (k <= j)) :\n                    ((removeHashIndex < k) || (k <= j)) );\n            // slot[removeHashIndex] := slot[j]\n            buffer[removeHashIndex] = buffer[j];\n            // removeHashIndex := j\n            removeHashIndex = j;\n        }\n    }",
      "line_number": 148,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object needle) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "identityHashCode",
        "System.identityHashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "        // contains takes a snapshot of the buffer.\n        final E[] buffer = this.buffer;\n        final int mask = buffer.length - 1;\n        final int hash = System.identityHashCode(needle);\n        final E e = buffer[hash & mask];\n        if (e == null) {\n            return false;\n        }\n        else if (e == needle) {\n            return true;\n        }\n        return containsSlowPath(buffer, mask, hash, needle);\n    }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "containsSlowPath",
      "signature": "private boolean containsSlowPath(final E[] buffer, final int mask, final int hash, Object needle) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        for (int i = hash + 1; i <= hash + mask; i++) {\n            final E e = buffer[i & mask];\n            if (e == null) {\n                return false;\n            }\n            else if (e == needle) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "line_number": 197,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "Iter",
      "signature": "public Iter(IdentityOpenHashSet<E> set) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            this.set = set;\n            this.buffer = set.buffer;\n            findNextVal();\n        }",
      "line_number": 223,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 1,
      "source_code": "            if (nextVal == null)\n                throw new NoSuchElementException();\n            E e = nextVal;\n            lastValIndex = nextValIndex;\n            findNextVal();\n            lastVal = e;\n            return e;\n        }",
      "line_number": 235,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "findNextVal",
      "signature": "private void findNextVal() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "            E[] array = buffer;\n            int i = nextValIndex;\n            E e = null;\n            for (; i < array.length; i++) {\n                e = array[i];\n                if (e != null) {\n                    nextVal = e;\n                    nextValIndex = i + 1;\n                    return;\n                }\n            }\n            nextVal = null;\n        }",
      "line_number": 245,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public void remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/IdentityOpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "remove",
        "set.remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            E e;\n            if ((e = lastVal) != null) {\n                lastVal = null;\n                set.remove(e);\n                nextValIndex = lastValIndex - 1;\n                findNextVal();\n            }\n        }",
      "line_number": 261,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "IdentityOpenHashSet",
      "method_type": "method"
    },
    {
      "name": "SingleWriterHashSet",
      "signature": "public SingleWriterHashSet(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        int actualCapacity = Pow2.roundToPowerOfTwo(capacity);\n        // pad data on either end with some empty slots?\n        buffer = (E[]) new Object[actualCapacity];\n        resizeThreshold = (int) (0.75 * buffer.length);\n    }",
      "line_number": 24,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "constructor"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "getIntVolatile",
        "UNSAFE.getIntVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        // size read needs to by volatile so that changes are visible\n        return UNSAFE.getIntVolatile(this, SIZE_OFFSET);\n    }",
      "line_number": 32,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E newVal) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "hashCode",
        "newVal.equals",
        "newVal.hashCode",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final E[] buffer = this.buffer;\n        final long mask = buffer.length - 1;\n\n        final int hash = rehash(newVal.hashCode());\n        final long offset = calcCircularRefElementOffset(hash, mask);\n        final E currVal = lpRefElement(buffer, offset);\n\n        boolean result;\n        if (currVal == null) {\n            size++;\n            soRefElement(buffer, offset, newVal);\n            result = true;\n        }\n        else {\n            result = !newVal.equals(currVal) && addSlowPath(buffer, mask, newVal, hash);\n        }\n\n        if (result && size > resizeThreshold) {\n            resize();\n        }\n        return result;\n    }",
      "line_number": 38,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "addForResize",
      "signature": "private void addForResize(final E[] buffer, final long mask, E newVal) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "hashCode",
        "newVal.hashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final int hash = rehash(newVal.hashCode());\n        final int limit = (int) (hash + mask);\n        for (int i = hash; i <= limit; i++) {\n            final long offset = calcCircularRefElementOffset(i, mask);\n            final E currVal = lpRefElement(buffer, offset);\n            if (currVal == null) {\n                soRefElement(buffer, offset, newVal);\n                return;\n            }\n        }\n    }",
      "line_number": 62,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "addSlowPath",
      "signature": "private boolean addSlowPath(E[] buffer, long mask, E newVal, int hash) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "newVal.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        final int limit = (int) (hash + mask);\n        for (int i = hash + 1; i <= limit; i++) {\n            final long offset = calcCircularRefElementOffset(i, mask);\n            final E currVal = lpRefElement(buffer, offset);\n            if (currVal == null) {\n                size++;\n                soRefElement(buffer, offset, newVal);\n                return true;\n            }\n            else if (newVal.equals(currVal)) {\n                return false;\n            }\n        }\n        return false;\n    }",
      "line_number": 75,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private void resize() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        final E[] oldBuffer = buffer;\n        final E[] newBuffer = (E[]) new Object[oldBuffer.length * 2];\n        final long mask = newBuffer.length - 1;\n        int countdown = size;\n        for (int i = 0; i < oldBuffer.length && countdown > 0; i++) {\n            if (oldBuffer[i] != null) {\n                addForResize(newBuffer, mask, oldBuffer[i]);\n                countdown--;\n            }\n        }\n        // store ordered\n        soBuffer(newBuffer);\n        resizeThreshold = (int) (0.75 * buffer.length);\n    }",
      "line_number": 93,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object val) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "val.equals",
        "hashCode",
        "val.hashCode",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        final E[] buffer = this.buffer;\n        final long mask = buffer.length - 1;\n        final int hash = rehash(val.hashCode());\n        final long offset = calcCircularRefElementOffset(hash, mask);\n        final E e = lpRefElement(buffer, offset);\n        if (e == null) {\n            return false;\n        }\n        else if (val.equals(e)) {\n            size--;\n            if (lpRefElement(buffer, calcCircularRefElementOffset(hash + 1, mask)) == null) {\n                soRefElement(buffer, offset, null);\n            }\n            else {\n                compactAndRemove(buffer, mask, hash);\n            }\n            return true;\n        }\n        return removeSlowPath(val, buffer, mask, hash);\n    }",
      "line_number": 110,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "removeSlowPath",
      "signature": "private boolean removeSlowPath(Object val, E[] buffer, long mask, int hash) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "val.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final int limit = (int) (hash + mask);\n        for (int searchIndex = hash + 1; searchIndex <= limit; searchIndex++) {\n            final long offset = calcCircularRefElementOffset(searchIndex, mask);\n            final E e = lpRefElement(buffer, offset);\n            if (e == null) {\n                return false;\n            }\n            else if (val.equals(e)) {\n                size--;\n                if (lpRefElement(buffer, calcCircularRefElementOffset(searchIndex + 1, mask)) == null) {\n                    soRefElement(buffer, offset, null);\n                }\n                else {\n                    compactAndRemove(buffer, mask, searchIndex);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "line_number": 132,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "compactAndRemove",
      "signature": "private void compactAndRemove(final E[] buffer, final long mask, int removeHashIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "hashCode",
        "putOrderedLong",
        "UNSAFE.putOrderedLong",
        "slotJ.hashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        // remove(9a): [9a,9b,10a,9c,10b,11a,null] -> [9b,10a,9c,10b,11a,null,null]\n        removeHashIndex = (int) (removeHashIndex & mask);\n        int j = removeHashIndex;\n        // every compaction is guarded by two mod count increments: one before and one after actual compaction\n        UNSAFE.putOrderedLong(this, MC_OFFSET, modCount + 1);\n        while (true) {\n            int k;\n            E slotJ;\n            // skip elements which belong where they are\n            do {\n                // j := (j+1) modulo num_slots\n                j = (int) ((j + 1) & mask);\n                slotJ = lpRefElement(buffer, calcCircularRefElementOffset(j, mask));\n                // if slot[j] is unoccupied exit\n                if (slotJ == null) {\n                    // delete last duplicate slot\n                    soRefElement(buffer, calcCircularRefElementOffset(removeHashIndex, mask), null);\n                    UNSAFE.putOrderedLong(this, MC_OFFSET, modCount + 1);\n                    return;\n                }\n\n                // k := hash(slot[j].key) modulo num_slots\n                k = (int) (rehash(slotJ.hashCode()) & mask);\n                // determine if k lies cyclically in [i,j]\n                // |    i.k.j |\n                // |....j i.k.| or |.k..j i...|\n            }\n            while ( (removeHashIndex <= j) ?\n                    ((removeHashIndex < k) && (k <= j)) :\n                    ((removeHashIndex < k) || (k <= j)) );\n            // slot[removeHashIndex] := slot[j]\n            soRefElement(buffer, calcCircularRefElementOffset(removeHashIndex, mask), slotJ);\n            // removeHashIndex := j\n            removeHashIndex = j;\n        }\n    }",
      "line_number": 157,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "toString",
        "Arrays.toString"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return \"SingleWriterHashSet [size=\" + size + \", buffer=\" + Arrays.toString(buffer)\n                + \", resizeThreshold=\" + resizeThreshold + \"]\";\n    }",
      "line_number": 196,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object needle) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        while (true) {\n            long mc = UNSAFE.getLongVolatile(this, MC_OFFSET);\n            boolean result = containsImpl(needle);\n            long newMc = UNSAFE.getLongVolatile(this, MC_OFFSET);\n            if ((newMc & 1) == 0 && mc == newMc) {\n                return result;\n            }\n        }\n    }",
      "line_number": 206,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "containsImpl",
      "signature": "private boolean containsImpl(Object needle) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "needle.equals",
        "hashCode",
        "needle.hashCode",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        // contains takes a snapshot of the buffer.\n        final E[] buffer = this.buffer;\n        final long mask = buffer.length - 1;\n        final int hash = rehash(needle.hashCode());\n        long offset = calcCircularRefElementOffset(hash, mask);\n        final E e = lvRefElement(buffer, offset);\n        if (e == null) {\n            return false;\n        }\n        else if (needle.equals(e)) {\n            return true;\n        }\n        return containsSlowPath(buffer, mask, hash, needle);\n    }",
      "line_number": 217,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "containsSlowPath",
      "signature": "private boolean containsSlowPath(final E[] buffer, final long mask, final int hash, Object needle) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "needle.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        for (int i = hash + 1; i <= hash + mask; i++) {\n            final long offset = calcCircularRefElementOffset(i, mask);\n            final E e = lvRefElement(buffer, offset);\n            if (e == null) {\n                return false;\n            }\n            else if (needle.equals(e)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "line_number": 233,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "Iter",
      "signature": "public Iter(SingleWriterHashSet<E> set) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "set.lvBuffer",
        "E",
        "lvBuffer"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            this.set = set;\n            this.buffer = set.lvBuffer();\n            findNextVal();\n        }",
      "line_number": 260,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 1,
      "source_code": "            if (nextVal == null)\n                throw new NoSuchElementException();\n            E e = nextVal;\n            lastValIndex = nextValIndex;\n            findNextVal();\n            lastVal = e;\n            return e;\n        }",
      "line_number": 272,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "findNextVal",
      "signature": "private void findNextVal() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "            E[] array = buffer;\n            int i = nextValIndex;\n            for (; i < array.length; i++) {\n                E e = array[i];\n                if (e != null) {\n                    nextVal = e;\n                    nextValIndex = i + 1;\n                    return;\n                }\n            }\n            nextVal = null;\n        }",
      "line_number": 282,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public void remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "IllegalStateException",
        "remove",
        "set.remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            if (lastVal == null) {\n                throw new IllegalStateException();\n            }\n\n            set.remove(lastVal);\n            lastVal = null;\n            nextValIndex = lastValIndex - 1;\n            findNextVal();\n        }",
      "line_number": 297,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "soBuffer",
      "signature": "private void soBuffer(final E[] buffer) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedObject",
        "UNSAFE.putOrderedObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedObject(this, BUFFER_OFFSET, buffer);\n    }",
      "line_number": 313,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "lvBuffer",
      "signature": "private E[] lvBuffer() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/SingleWriterHashSet.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return (E[]) UNSAFE.getObjectVolatile(this, BUFFER_OFFSET);\n    }",
      "line_number": 318,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SingleWriterHashSet",
      "method_type": "method"
    },
    {
      "name": "OpenHashSet",
      "signature": "public OpenHashSet(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        int actualCapacity = Pow2.roundToPowerOfTwo(capacity);\n        // pad data on either end with some empty slots?\n        buffer = (E[]) new Object[actualCapacity];\n        resizeThreshold = (int) (0.75 * buffer.length);\n    }",
      "line_number": 17,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "constructor"
    },
    {
      "name": "add",
      "signature": "public boolean add(E newVal) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "hashCode",
        "newVal.equals",
        "newVal.hashCode",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final E[] buffer = this.buffer;\n        final int mask = buffer.length - 1;\n\n        final int hash = rehash(newVal.hashCode());\n        final int offset = hash & mask;\n        final E currVal = buffer[offset];\n\n        boolean result;\n        if (currVal == null) {\n            size++;\n            buffer[offset] = newVal;\n            result = true;\n        } else {\n            result = !newVal.equals(currVal) && addSlowPath(buffer, mask, newVal, hash);\n        }\n\n        if (result && size > resizeThreshold) {\n            resize();\n        }\n        return result;\n    }",
      "line_number": 30,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "addForResize",
      "signature": "private void addForResize(final E[] buffer, final int mask, E newVal) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "hashCode",
        "newVal.hashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final int hash = rehash(newVal.hashCode());\n        final int limit = hash + mask;\n        for (int i = hash; i <= limit; i++) {\n            final int offset = i & mask;\n            final E currVal = buffer[offset];\n            if (currVal == null) {\n                buffer[offset] = newVal;\n                return;\n            }\n        }\n    }",
      "line_number": 53,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "addSlowPath",
      "signature": "private boolean addSlowPath(E[] buffer, int mask, E newVal, int hash) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "newVal.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        final int limit = hash + mask;\n        for (int i = hash + 1; i <= limit; i++) {\n            final int offset = i & mask;\n            final E currVal = buffer[offset];\n            if (currVal == null) {\n                size++;\n                buffer[offset] = newVal;\n                return true;\n            }\n            else if (newVal.equals(currVal)) {\n                return false;\n            }\n        }\n        return false;\n    }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "resize",
      "signature": "private void resize() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        final E[] oldBuffer = buffer;\n        final E[] newBuffer = (E[]) new Object[oldBuffer.length * 2];\n        final int mask = newBuffer.length - 1;\n        int countdown = size;\n        for (int i = 0; i < oldBuffer.length && countdown > 0; i++) {\n            if (oldBuffer[i] != null) {\n                addForResize(newBuffer, mask, oldBuffer[i]);\n                countdown--;\n            }\n        }\n\n        buffer = newBuffer;\n        resizeThreshold = (int) (0.75 * buffer.length);\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object val) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "val.equals",
        "hashCode",
        "val.hashCode",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        final E[] buffer = this.buffer;\n        final int mask = buffer.length - 1;\n        final int hash = rehash(val.hashCode());\n        final int offset = hash & mask;\n        final E e = buffer[offset];\n        if (e == null) {\n            return false;\n        }\n        else if (val.equals(e)) {\n            size--;\n            if (buffer[(hash + 1) & mask] == null) {\n                buffer[offset] = null;\n            }\n            else {\n                compactAndRemove(buffer, mask, hash);\n            }\n            return true;\n        }\n        return removeSlowPath(val, buffer, mask, hash);\n    }",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "removeSlowPath",
      "signature": "private boolean removeSlowPath(Object val, final E[] buffer, final int mask, final int hash) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "val.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final int limit = hash + mask;\n        for (int searchIndex = hash + 1; searchIndex <= limit; searchIndex++) {\n            final int offset = searchIndex & mask;\n            final E e = buffer[offset];\n            if (e == null) {\n                return false;\n            }\n            else if (val.equals(e)) {\n                size--;\n                if (buffer[(searchIndex + 1) & mask] == null) {\n                    buffer[offset] = null;\n                }\n                else {\n                    compactAndRemove(buffer, mask, searchIndex);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "line_number": 123,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "compactAndRemove",
      "signature": "private void compactAndRemove(final E[] buffer, final int mask, int removeHashIndex) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "hashCode",
        "slotJ.hashCode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 9,
      "source_code": "        // remove(9a): [9a,9b,10a,9c,10b,11a,null] -> [9b,9c,10a,10b,null,11a,null]\n        removeHashIndex = removeHashIndex & mask;\n        int j = removeHashIndex;\n        while (true) {\n            int k;\n            E slotJ;\n            // skip elements which belong where they are\n            do {\n                // j := (j+1) modulo num_slots\n                j = (j + 1) & mask;\n                slotJ = buffer[j];\n                // if slot[j] is unoccupied exit\n                if (slotJ == null) {\n                    // delete last duplicate slot\n                    buffer[removeHashIndex] = null;\n                    return;\n                }\n\n                // k := hash(slot[j].key) modulo num_slots\n                k = rehash(slotJ.hashCode()) & mask;\n                // determine if k lies cyclically in [i,j]\n                // |    i.k.j |\n                // |....j i.k.| or  |.k..j i...|\n            }\n            while ( (removeHashIndex <= j) ?\n                    ((removeHashIndex < k) && (k <= j)) :\n                    ((removeHashIndex < k) || (k <= j)) );\n            // slot[removeHashIndex] := slot[j]\n            buffer[removeHashIndex] = slotJ;\n            // removeHashIndex := j\n            removeHashIndex = j;\n        }\n    }",
      "line_number": 148,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object needle) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "needle.equals",
        "hashCode",
        "needle.hashCode",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "        // contains takes a snapshot of the buffer.\n        final E[] buffer = this.buffer;\n        final int mask = buffer.length - 1;\n        final int hash = rehash(needle.hashCode());\n        final E e = buffer[hash & mask];\n        if (e == null) {\n            return false;\n        }\n        else if (needle.equals(e)) {\n            return true;\n        }\n        return containsSlowPath(buffer, mask, hash, needle);\n    }",
      "line_number": 188,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "containsSlowPath",
      "signature": "private boolean containsSlowPath(final E[] buffer, final int mask, final int hash, Object needle) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "needle.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        for (int i = hash + 1; i <= hash + mask; i++) {\n            final E e = buffer[i & mask];\n            if (e == null) {\n                return false;\n            }\n            else if (needle.equals(e)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "line_number": 203,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "Iter",
      "signature": "public Iter(OpenHashSet<E> set) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            this.set = set;\n            this.buffer = set.buffer;\n            findNextVal();\n        }",
      "line_number": 229,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 1,
      "source_code": "            if (nextVal == null)\n                throw new NoSuchElementException();\n            E e = nextVal;\n            lastValIndex = nextValIndex;\n            findNextVal();\n            lastVal = e;\n            return e;\n        }",
      "line_number": 241,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "findNextVal",
      "signature": "private void findNextVal() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "            E[] array = buffer;\n            int i = nextValIndex;\n            E e = null;\n            for (; i < array.length; i++) {\n                e = array[i];\n                if (e != null) {\n                    nextVal = e;\n                    nextValIndex = i + 1;\n                    return;\n                }\n            }\n            nextVal = null;\n        }",
      "line_number": 251,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public void remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/sets/OpenHashSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "remove",
        "set.remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            E e;\n            if ((e = lastVal) != null) {\n                lastVal = null;\n                set.remove(e);\n                nextValIndex = lastValIndex - 1;\n                findNextVal();\n            }\n        }",
      "line_number": 267,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "OpenHashSet",
      "method_type": "method"
    },
    {
      "name": "MpscLinkedArrayQueue",
      "signature": "public MpscLinkedArrayQueue(int arrayCapacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference"
      ],
      "dependencies": [
        "AtomicLong",
        "lazySet",
        "AtomicReference",
        "producerArray.lazySet",
        "ARA2"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        int c = arrayCapacity;\n        this.maxOffset = c - 1;\n        ARA2 array = new ARA2(c + 1, 0);\n        this.producerIndex = new AtomicLong();\n        this.consumerIndex = new AtomicLong();\n        this.producerArray = new AtomicReference<ARA2>();\n        this.consumerArray = array;\n        this.producerArray.lazySet(array);\n    }",
      "line_number": 19,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "constructor"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(T value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement",
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "array.casNext",
        "lazySet",
        "compareAndSet",
        "next",
        "array.next",
        "IllegalStateException",
        "get",
        "requireNonNull",
        "svNext",
        "array.lazySet",
        "ARA2",
        "Objects.requireNonNull",
        "producerArray.compareAndSet",
        "casNext",
        "producerIndex.getAndIncrement",
        "getAndIncrement",
        "array.svNext",
        "producerArray.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        Objects.requireNonNull(value);\n\n        final int m = maxOffset;\n\n        ARA2 array = producerArray.get();\n        final long index = producerIndex.getAndIncrement();\n\n        long start = array.start;\n        long end = array.end;\n\n        if (start - index > 0L) {\n            throw new IllegalStateException(index + \" vs. \" + start);\n        } else\n        if (index < end) {\n            int offset = (int)(index - start);\n            array.lazySet(offset, value);\n        }\n        else { //(index >= end)\n            for (;;) {\n                Object nextArray = array.next();\n                if (nextArray == null) {\n                    if (array.casNext(null, ALLOCATING)) {\n                        nextArray = new ARA2(m + 2, end);\n                        array.svNext(nextArray);\n                    } else {\n                        while ((nextArray = array.next()) == ALLOCATING);\n                    }\n                } else {\n                    while ((nextArray = array.next()) == ALLOCATING);\n                }\n\n                ARA2 nextArray2 = (ARA2)nextArray;\n                if (array.end < index) {\n                    producerArray.compareAndSet(array, nextArray2);\n                }\n                array = nextArray2;\n\n                start = end;\n                end = array.end;\n                if (index < end) {\n                    break;\n                }\n            }\n            int offset = (int)(index - start);\n            array.lazySet(offset, value);\n        }\n\n        return true;\n    }",
      "line_number": 31,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public T poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "array.next",
        "next",
        "get",
        "array.lazySet",
        "consumerIndex.get",
        "producerIndex.get",
        "consumerIndex.lazySet",
        "array.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final long index = consumerIndex.get();\n        ARA2 array = consumerArray;\n        int offset = consumerOffset;\n        final int m = maxOffset;\n        if (offset > m) {\n            for (;;) {\n                Object next = array.next();\n                if (next == ALLOCATING) {\n                    continue;\n                }\n                if (next != null) {\n                    offset = 0;\n                    array = (ARA2)next;\n                    consumerArray = array;\n                    break;\n                }\n                if (producerIndex.get() <= index) {\n                    return null;\n                }\n            }\n        }\n        for (;;) {\n            Object o = array.get(offset);\n            if (o != null) {\n                consumerOffset = offset + 1;\n                consumerIndex.lazySet(index + 1);\n                array.lazySet(offset, null);\n                return (T)o;\n            }\n            if (producerIndex.get() <= index) {\n                return null;\n            }\n        }\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "weakPoll",
      "signature": "public T weakPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySet",
        "array.next",
        "next",
        "get",
        "array.lazySet",
        "consumerIndex.get",
        "consumerIndex.lazySet",
        "array.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        final long index = consumerIndex.get();\n        ARA2 array = consumerArray;\n        int offset = consumerOffset;\n        final int m = maxOffset;\n        if (offset > m) {\n            Object next = array.next();\n            if (next == null || next == ALLOCATING) {\n                return null;\n            }\n            offset = 0;\n            array = (ARA2)next;\n            consumerOffset = 0;\n            consumerArray = array;\n        }\n        Object o = array.get(offset);\n        if (o != null) {\n            consumerOffset = offset + 1;\n            consumerIndex.lazySet(index + 1);\n            array.lazySet(offset, null);\n            return (T)o;\n        }\n        return null;\n    }",
      "line_number": 121,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public T peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "array.next",
        "next",
        "get",
        "consumerIndex.get",
        "producerIndex.get",
        "array.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final long index = consumerIndex.get();\n        ARA2 array = consumerArray;\n        int offset = consumerOffset;\n        final int m = maxOffset;\n        if (offset > m) {\n            for (;;) {\n                Object next = array.next();\n                if (next == ALLOCATING) {\n                    continue;\n                }\n                if (next != null) {\n                    offset = 0;\n                    array = (ARA2)next;\n                    break;\n                }\n                if (producerIndex.get() <= index) {\n                    return null;\n                }\n            }\n        }\n        for (;;) {\n            Object o = array.get(offset);\n            if (o != null) {\n                return (T)o;\n            }\n            if (producerIndex.get() <= index) {\n                return null;\n            }\n        }\n    }",
      "line_number": 148,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "weakPeek",
      "signature": "public T weakPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "array.get",
        "get",
        "array.next",
        "next"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        ARA2 array = consumerArray;\n        int offset = consumerOffset;\n        final int m = maxOffset;\n        if (offset > m) {\n            Object next = array.next();\n            if (next == null || next == ALLOCATING) {\n                return null;\n            }\n            offset = 0;\n            array = (ARA2)next;\n        }\n        Object o = array.get(offset);\n        return (T)o;\n    }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "consumerIndex.get",
        "producerIndex.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex.get() == producerIndex.get();\n    }",
      "line_number": 197,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "get",
        "consumerIndex.get",
        "producerIndex.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        long after = consumerIndex.get();\n        for (;;) {\n            final long before = after;\n            final long pidx = producerIndex.get();\n            after = consumerIndex.get();\n            if (before == after) {\n                return (int)(pidx - before);\n            }\n        }\n    }",
      "line_number": 202,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "ARA2",
      "signature": "public ARA2(int capacity, long start) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            super(capacity);\n            this.start = start;\n            this.end = start + capacity - 1;\n            this.nextOffset = capacity - 1;\n        }",
      "line_number": 220,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public Object next() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return get(nextOffset);\n        }",
      "line_number": 226,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "public boolean casNext(Object expected, Object newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return compareAndSet(nextOffset, expected, newValue);\n        }",
      "line_number": 229,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "svNext",
      "signature": "public void svNext(Object newNext) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            set(nextOffset, newNext);\n        }",
      "line_number": 232,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscLinkedArrayQueue",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "public final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerIndex;\n    }",
      "line_number": 55,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "protected final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, P_INDEX_OFFSET, expect, newValue);\n    }",
      "line_number": 59,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "public final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(this, C_INDEX_OFFSET);\n    }",
      "line_number": 96,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "protected final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerIndex;\n    }",
      "line_number": 99,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "protected final void soConsumerIndex(long v) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, C_INDEX_OFFSET, v);\n    }",
      "line_number": 102,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "MpscSequencedArrayQueue",
      "signature": "public MpscSequencedArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        super(Math.max(2, capacity));\n    }",
      "line_number": 133,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "spRefElement",
        "NullPointerException",
        "UnsafeRefArrayAccess.spRefElement"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 25,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n\n        // local load of field to avoid repeated loads after volatile reads\n        final long[] lSequenceBuffer = sequenceBuffer;\n        long currentProducerIndex;\n        long seqOffset;\n\n        while (true) {\n            currentProducerIndex = lvProducerIndex(); // LoadLoad\n            seqOffset = calcCircularLongElementOffset(currentProducerIndex, mask);\n            final long seq = lvLongElement(lSequenceBuffer, seqOffset); // LoadLoad\n            final long delta = seq - currentProducerIndex;\n\n            if (delta == 0) {\n                // this is expected if we see this first time around\n                if (casProducerIndex(currentProducerIndex, currentProducerIndex + 1)) {\n                    // Successful CAS: full barrier\n                    break;\n                }\n                // failed cas, retry 1\n            } else if (delta < 0) {\n                // poll has not moved this value forward\n                return false;\n            }\n\n            // another producer has moved the sequence by one, retry 2\n        }\n\n        // on 64bit(no compressed oops) JVM this is the same as seqOffset\n        final long elementOffset = calcCircularRefElementOffset(currentProducerIndex, mask);\n        UnsafeRefArrayAccess.spRefElement(buffer, elementOffset, e);\n\n        // increment sequence by 1, the value expected by consumer\n        // (seeing this value from a producer will lead to retry 2)\n        // StoreStore\n        soLongElement(lSequenceBuffer, seqOffset, currentProducerIndex + 1);\n\n        return true;\n    }",
      "line_number": 138,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "lpRefElement",
        "spRefElement",
        "UnsafeRefArrayAccess.lpRefElement",
        "UnsafeRefArrayAccess.spRefElement"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // local load of field to avoid repeated loads after volatile reads\n        final long[] lSequenceBuffer = sequenceBuffer;\n\n        long consumerIndex = lvConsumerIndex();// LoadLoad\n        final long seqOffset = calcCircularLongElementOffset(consumerIndex, mask);\n        final long seq = lvLongElement(lSequenceBuffer, seqOffset);// LoadLoad\n        final long delta = seq - (consumerIndex + 1);\n\n        if (delta < 0) {\n            // queue is empty\n            return null;\n        }\n\n        // on 64bit(no compressed oops) JVM this is the same as seqOffset\n        final long offset = calcCircularRefElementOffset(consumerIndex, mask);\n        final E e = UnsafeRefArrayAccess.lpRefElement(buffer, offset);\n        UnsafeRefArrayAccess.spRefElement(buffer, offset, null);\n        // Move sequence ahead by capacity, preparing it for next offer\n        // (seeing this value from a consumer will lead to retry 2)\n        // StoreStore\n        soLongElement(lSequenceBuffer, seqOffset, consumerIndex + mask + 1);\n        soConsumerIndex(consumerIndex+1);\n        return e;\n    }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lpRefElement",
        "UnsafeRefArrayAccess.lpRefElement"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UnsafeRefArrayAccess.lpRefElement(buffer, calcCircularRefElementOffset(lvConsumerIndex(), mask));\n    }",
      "line_number": 209,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final int limit = capacity();\n        return drain(c,limit);\n    }",
      "line_number": 229,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "drain",
      "signature": "public int drain(Consumer<E> c, int limit) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "c.accept",
        "accept"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "        for (int i=0;i<limit;i++) {\n            E e = relaxedPoll();\n            if(e==null){\n                return i;\n            }\n            c.accept(e);\n        }\n        return limit;\n    }",
      "line_number": 240,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscSequencedArrayQueueL1Pad",
      "method_type": "method"
    },
    {
      "name": "SpscOffHeapIntQueue",
      "signature": "public SpscOffHeapIntQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\tthis(allocateAlignedByteBuffer(\n\t\t        getRequiredBufferSize(capacity),\n\t\t        PortableJvmInfo.CACHE_LINE_SIZE),\n\t\t        Pow2.roundToPowerOfTwo(capacity),(byte)(PRODUCER | CONSUMER));\n\t}",
      "line_number": 42,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "constructor"
    },
    {
      "name": "getRequiredBufferSize",
      "signature": "public static int getRequiredBufferSize(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "final"
      ],
      "dependencies": [
        "IllegalArgumentException",
        "roundToPowerOfTwo",
        "Pow2.roundToPowerOfTwo"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "\t\tint p2Capacity = Pow2.roundToPowerOfTwo(capacity);\n\t\tif (p2Capacity > (Pow2.MAX_POW2 >> INT_ELEMENT_SCALE))\n\t\t\tthrow new IllegalArgumentException(\"capacity exceeds max buffer capacity: \" + (Pow2.MAX_POW2 >> INT_ELEMENT_SCALE));\n\t\treturn 4 * PortableJvmInfo.CACHE_LINE_SIZE + (p2Capacity << INT_ELEMENT_SCALE);\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final Integer e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "UNSAFE.putInt",
        "putInt"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "\t\tif (null == e) {\n\t\t\tthrow new NullPointerException(\"Null is not a valid element\");\n\t\t}\n\n\t\tfinal long currentTail = getTailPlain();\n\t\tfinal long wrapPoint = currentTail - capacity;\n\t\tif (getHeadCache() <= wrapPoint) {\n\t\t\tsetHeadCache(getHead());\n\t\t\tif (getHeadCache() <= wrapPoint) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlong offset = calcElementOffset(currentTail);\n\t\tUnsafeAccess.UNSAFE.putInt(offset, e);\n\n\t\tsetTail(currentTail + 1);\n\n\t\treturn true;\n\t}",
      "line_number": 90,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "offerInt",
      "signature": "public boolean offerInt(final int e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.putInt",
        "putInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long currentTail = getTailPlain();\n        final long wrapPoint = currentTail - capacity;\n        if (getHeadCache() <= wrapPoint) {\n            setHeadCache(getHead());\n            if (getHeadCache() <= wrapPoint) {\n                return false;\n            }\n        }\n\n        long offset = calcElementOffset(currentTail);\n        UnsafeAccess.UNSAFE.putInt(offset, e);\n\n        setTail(currentTail + 1);\n\n        return true;\n    }",
      "line_number": 111,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public Integer poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 2,
      "source_code": "\t\tint i = pollInt();\n\t\tif(i == Integer.MIN_VALUE) {\n\t\t    return null;\n\t\t}\n\t\treturn i;\n\t}",
      "line_number": 129,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "pollInt",
      "signature": "public int pollInt() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.getInt",
        "getInt"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "\t\tfinal long currentHead = getHeadPlain();\n\t\tif (currentHead >= getTailCache()) {\n\t\t\tsetTailCache(getTail());\n\t\t\tif (currentHead >= getTailCache()) {\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}\n\t\t}\n\n\t\tfinal long offset = calcElementOffset(currentHead);\n\t\tfinal int e = UnsafeAccess.UNSAFE.getInt(offset);\n\t\tsetHead(currentHead + 1);\n\t\treturn e;\n    }",
      "line_number": 137,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "calcElementOffset",
      "signature": "private long calcElementOffset(final long currentHead) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return arrayBase + ((currentHead & mask) << INT_ELEMENT_SCALE);\n    }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public Integer peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 2,
      "source_code": "\t    int i = peekInt();\n        if(i == Integer.MIN_VALUE) {\n            return null;\n        }\n        return i;\n    }",
      "line_number": 155,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "peekInt",
      "signature": "public int peekInt() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.getInt",
        "getInt"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long currentHead = getHeadPlain();\n        if (currentHead >= getTailCache()) {\n            setTailCache(getTail());\n            if (currentHead >= getTailCache()) {\n                return Integer.MIN_VALUE;\n            }\n        }\n\n        final long offset = calcElementOffset(currentHead);\n        return UnsafeAccess.UNSAFE.getInt(offset);\n    }",
      "line_number": 163,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn (int) (getTail() - getHead());\n\t}",
      "line_number": 176,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn getTail() == getHead();\n\t}",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "getHeadPlain",
      "signature": "private long getHeadPlain() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn UnsafeAccess.UNSAFE.getLong(null, headAddress);\n\t}",
      "line_number": 188,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "getHead",
      "signature": "private long getHead() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "\t\treturn UnsafeAccess.UNSAFE.getLongVolatile(null, headAddress);\n\t}",
      "line_number": 191,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "setHead",
      "signature": "private void setHead(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\tUnsafeAccess.UNSAFE.putOrderedLong(null, headAddress, value);\n\t}",
      "line_number": 195,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "getTailPlain",
      "signature": "private long getTailPlain() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn UnsafeAccess.UNSAFE.getLong(null, tailAddress);\n\t}",
      "line_number": 199,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "getTail",
      "signature": "private long getTail() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "\t\treturn UnsafeAccess.UNSAFE.getLongVolatile(null, tailAddress);\n\t}",
      "line_number": 202,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "setTail",
      "signature": "private void setTail(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\tUnsafeAccess.UNSAFE.putOrderedLong(null, tailAddress, value);\n\t}",
      "line_number": 206,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "getHeadCache",
      "signature": "private long getHeadCache() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn UnsafeAccess.UNSAFE.getLong(null, headCacheAddress);\n\t}",
      "line_number": 210,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "setHeadCache",
      "signature": "private void setHeadCache(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putLong",
        "UNSAFE.putLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\tUnsafeAccess.UNSAFE.putLong(headCacheAddress, value);\n\t}",
      "line_number": 214,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "getTailCache",
      "signature": "private long getTailCache() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn UnsafeAccess.UNSAFE.getLong(null, tailCacheAddress);\n\t}",
      "line_number": 218,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "setTailCache",
      "signature": "private void setTailCache(final long value) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/SpscOffHeapIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putLong",
        "UNSAFE.putLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\tUnsafeAccess.UNSAFE.putLong(tailCacheAddress, value);\n\t}",
      "line_number": 222,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "SpscOffHeapIntQueue",
      "method_type": "method"
    },
    {
      "name": "BQueue",
      "signature": "public BQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        super(capacity);\n    }",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        if (offer(e)) {\n            return true;\n        }\n        throw new IllegalStateException(\"Queue is full\");\n    }",
      "line_number": 145,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "offset",
      "signature": "private long offset(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ARRAY_BASE + ((index & mask) << ELEMENT_SHIFT);\n    }",
      "line_number": 152,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.putOrderedObject",
        "putOrderedObject",
        "NullPointerException",
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n\n        if (tail >= batchTail) {\n            if (null != UNSAFE.getObjectVolatile(buffer, offset(tail + OFFER_BATCH_SIZE))) {\n                return false;\n            }\n            batchTail = tail + OFFER_BATCH_SIZE;\n        }\n        UNSAFE.putOrderedObject(buffer, offset(tail), e);\n        tail++;\n\n        return true;\n    }",
      "line_number": 155,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedObject",
        "getObject",
        "UNSAFE.getObject",
        "UNSAFE.putOrderedObject"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        if (head >= batchHead) {\n            if (!backtrackPoll()) {\n                return null;\n            }\n        }\n\n        final long offset = offset(head);\n        @SuppressWarnings(\"unchecked\")\n        final E e = (E) UNSAFE.getObject(buffer, offset);\n        UNSAFE.putOrderedObject(buffer, offset, null);\n        head++;\n        return e;\n    }",
      "line_number": 171,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "backtrackPoll",
      "signature": "boolean backtrackPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "wait"
      ],
      "dependencies": [
        "getObjectVolatile",
        "min",
        "UNSAFE.getObjectVolatile",
        "Math.min"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        if (batchHistory < POLL_BATCH_SIZE) {\n            batchHistory = Math.min(POLL_BATCH_SIZE, batchHistory << 1);\n        }\n        batchSize = batchHistory;\n        batchHead = head + batchSize - 1;\n        while (UNSAFE.getObjectVolatile(buffer, offset(batchHead)) == null) {\n            spinWait();\n            if (batchSize > 1) {\n                batchSize = batchSize >> 1;\n                batchHead = head + batchSize - 1;\n            } else {\n                batchHead = head;\n                return false;\n            }\n        }\n        batchHistory = batchSize;\n        return true;\n    }",
      "line_number": 186,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "spinWait",
      "signature": "private void spinWait() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "System.nanoTime",
        "nanoTime"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        if(TICKS == 0){\n            return;\n        }\n\t    final long deadline = System.nanoTime() + TICKS;\n\t    while(deadline >= System.nanoTime());\n    }",
      "line_number": 206,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public E remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = poll();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 214,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "element",
      "signature": "public E element() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = peek();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 223,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    \tthrow new UnsupportedOperationException();\n    }",
      "line_number": 244,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(final T[] a) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "T",
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 256,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 260,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "containsAll",
      "signature": "public boolean containsAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "    \tthrow new UnsupportedOperationException();\n    }",
      "line_number": 264,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(final Collection<? extends E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        for (final E e : c) {\n            add(e);\n        }\n\n        return true;\n    }",
      "line_number": 268,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "removeAll",
      "signature": "public boolean removeAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 276,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "retainAll",
      "signature": "public boolean retainAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/BQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 280,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BQueueL0Pad",
      "method_type": "method"
    },
    {
      "name": "ThreadWeakRef",
      "signature": "public ThreadWeakRef(ReferenceQueue<? super Thread> q, Object r) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscOnSpscQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "\t\t\tsuper(Thread.currentThread(), q);\n\t\t\tthis.r = r;\n\t\t}",
      "line_number": 59,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscOnSpscL0Pad",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscOnSpscQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "refQ.remove",
        "remove",
        "weakRefHolder.remove",
        "Thread.interrupted",
        "interrupted"
      ],
      "concurrency_patterns": [],
      "complexity_score": 14,
      "source_code": "\t\t\t\twhile(true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThreadWeakRef remove = (ThreadWeakRef)refQ.remove();\n\t\t\t\t\t\tremoveQueue(remove.r);\n\t\t\t\t\t\tweakRefHolder.remove(remove);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tif (Thread.interrupted()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}",
      "line_number": 78,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscOnSpscL0Pad",
      "method_type": "method"
    },
    {
      "name": "addQueue",
      "signature": "protected final void addQueue(Queue<E> q) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscOnSpscQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "weakRefHolder.add",
        "add",
        "UNSAFE.compareAndSwapObject",
        "E",
        "ThreadWeakRef",
        "arraycopy",
        "System.arraycopy"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "\t\tQueue[] oldQs;\n\t\tQueue[] newQs;\n\t\tdo {\n\t\t\toldQs = queues;\n\t\t\tnewQs = new Queue[oldQs.length + 1];\n\t\t\tSystem.arraycopy(oldQs, 0, newQs, 0, oldQs.length);\n\t\t\tnewQs[oldQs.length] = q;\n\t\t} while (!UNSAFE.compareAndSwapObject(this, QUEUES_OFFSET, oldQs, newQs));\n\t\tweakRefHolder.add(new ThreadWeakRef(refQ, q));\n\t}",
      "line_number": 98,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscOnSpscL0Pad",
      "method_type": "method"
    },
    {
      "name": "removeQueue",
      "signature": "protected final void removeQueue(Object q) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscOnSpscQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "arraycopy",
        "System.arraycopy"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\t\tQueue[] oldQs;\n\t\tQueue[] newQs;\n\t\tdo {\n\t\t\toldQs = queues;\n\t\t\tint i = 0;\n\t\t\tfinal int length = oldQs.length;\n\t\t\tfor (; i < length; i++) {\n\t\t\t\tif (q == oldQs[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// not here...\n\t\t\tif (i == length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// copy over all but that element\n\t\t\tnewQs = new Queue[length - 1];\n\t\t\tSystem.arraycopy(oldQs, 0, newQs, 0, i);\n\t\t\tSystem.arraycopy(oldQs, i + 1, newQs, i, length - i - 1);\n\t\t} while (!UNSAFE.compareAndSwapObject(this, QUEUES_OFFSET, oldQs, newQs));\n\t}",
      "line_number": 111,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscOnSpscL0Pad",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscOnSpscQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "producerQueue.get",
        "offer",
        "get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "\t\treturn producerQueue.get().offer(e);\n\t}",
      "line_number": 148,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscOnSpscL0Pad",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpscOnSpscQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "Thread",
        "ThreadLocal"
      ],
      "dependencies": [
        "nextInt",
        "current",
        "ThreadLocalRandom.current",
        "poll",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\t\tQueue<E>[] qs = this.queues;\n\t\tfinal int start = ThreadLocalRandom.current().nextInt(qs.length);\n\t\tfor (int i = start; i < qs.length; i++) {\n\t\t\tE e = qs[i].poll();\n\t\t\tif (e != null)\n\t\t\t\treturn e;\n\t\t}\n\t\tfor (int i = 0; i < start; i++) {\n\t\t\tE e = qs[i].poll();\n\t\t\tif (e != null)\n\t\t\t\treturn e;\n\t\t}\n\t\treturn null;\n\t}",
      "line_number": 153,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscOnSpscL0Pad",
      "method_type": "method"
    },
    {
      "name": "calcOffset",
      "signature": "protected final long calcOffset(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return REF_ARRAY_BASE + ((index & mask) << REF_ELEMENT_SHIFT);\n    }",
      "line_number": 88,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "spElement",
      "signature": "protected final void spElement(E[] buffer, long offset, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putObject",
        "UNSAFE.putObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putObject(buffer, offset, e);\n    }",
      "line_number": 92,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "soElement",
      "signature": "protected final void soElement(E[] buffer, long offset, Object e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedObject",
        "UNSAFE.putOrderedObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedObject(buffer, offset, e);\n    }",
      "line_number": 95,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "svElement",
      "signature": "protected final void svElement(E[] buffer, long offset, Object e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.putObjectVolatile",
        "putObjectVolatile"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        UNSAFE.putObjectVolatile(buffer, offset, e);\n    }",
      "line_number": 99,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "lvElement",
      "signature": "protected final Object lvElement(E[] buffer, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getObjectVolatile(buffer, offset);\n    }",
      "line_number": 104,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "lvTail",
      "signature": "protected final long lvTail() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return tail;\n    }",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "protected final boolean casTail(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UnsafeAccess.UNSAFE.compareAndSwapLong(this, TAIL_OFFSET, expect, newValue);\n    }",
      "line_number": 145,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "lvHead",
      "signature": "protected final long lvHead() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return head;\n    }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "protected final boolean casHead(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UnsafeAccess.UNSAFE.compareAndSwapLong(this, HEAD_OFFSET, expect, newValue);\n    }",
      "line_number": 186,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "MpmcConcurrentQueueStateMarkers",
      "signature": "public MpmcConcurrentQueueStateMarkers(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        super(capacity);\n    }",
      "line_number": 214,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        if (offer(e)) {\n            return true;\n        }\n        throw new IllegalStateException(\"Queue is full\");\n    }",
      "line_number": 218,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n        long currentTail;\n        long offsetWrapSign;\n        Object wrapSign;\n        long currentTailWrapSign;\n        Object pollSign;\n        final E[] lb = buffer;\n        for (;;) {\n            currentTail = lvTail();\n            offsetWrapSign = calcOffset(currentTail);\n            wrapSign = lvElement(lb, offsetWrapSign);\n            currentTailWrapSign = capacity & currentTail;\n            if (currentTailWrapSign == 0 && wrapSign == N_OFFER) {\n                if (casTail(currentTail, currentTail + 1)) {\n                    pollSign = N_POLL;\n                    break;\n                }\n            }\n            else if (currentTailWrapSign != 0 && wrapSign == P_OFFER) {\n                if (casTail(currentTail, currentTail + 1)) {\n                    pollSign = P_POLL;\n                    break;\n                }\n            }\n            else if(null != lvElement(lb,  offsetWrapSign + SIZE_OF_ELEMENT)) {\n                return false;\n            }\n        }\n        spElement(lb, offsetWrapSign + SIZE_OF_ELEMENT, e);\n        soElement(lb, offsetWrapSign, pollSign);\n        return true;\n    }",
      "line_number": 226,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        E e;\n        long currentHead;\n        long offsetWrapSign;\n        Object wrapSign;\n        long currentHeadWrapSign;\n        Object offerSign;\n        final E[] lb = buffer;\n        for (;;) {\n            currentHead = lvHead();\n            offsetWrapSign =  calcOffset(currentHead);\n            wrapSign = lvElement(lb, offsetWrapSign);\n            currentHeadWrapSign = capacity & currentHead;\n\n            if (currentHeadWrapSign == 0 && wrapSign == N_POLL) {\n                if (casHead(currentHead, currentHead + 1)) {\n                    offerSign = P_OFFER;\n                    break;\n                }\n            }\n            else if (currentHeadWrapSign != 0 && wrapSign == P_POLL) {\n                if (casHead(currentHead, currentHead + 1)) {\n                    offerSign = N_OFFER;\n                    break;\n                }\n            }\n            else if(null == lvElement(lb, offsetWrapSign + SIZE_OF_ELEMENT)) {\n                return null;\n            }\n        }\n        final long offsetE = offsetWrapSign + SIZE_OF_ELEMENT;\n        e = (E) lvElement(lb, offsetE);\n        spElement(lb,offsetE, null);\n        soElement(lb, offsetWrapSign, offerSign);\n        return e;\n    }",
      "line_number": 264,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public E remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = poll();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 301,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "element",
      "signature": "public E element() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = peek();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 310,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (E) lvElement(buffer, calcOffset(lvHead()) + SIZE_OF_ELEMENT);\n    }",
      "line_number": 321,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "o.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (null == o) {\n            return false;\n        }\n\n        for (long i = lvHead(), limit = lvTail(); i < limit; i++) {\n            @SuppressWarnings(\"unchecked\")\n            final E e = (E) lvElement(buffer, calcOffset(i) + SIZE_OF_ELEMENT);\n            if (o.equals(e)) {\n                return true;\n            }\n        }\n\n        return false;\n    }",
      "line_number": 333,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(final T[] a) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "T",
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 357,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 361,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "containsAll",
      "signature": "public boolean containsAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "        for (final Object o : c) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n\n        return true;\n    }",
      "line_number": 365,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(final Collection<? extends E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        for (final E e : c) {\n            add(e);\n        }\n\n        return true;\n    }",
      "line_number": 375,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "removeAll",
      "signature": "public boolean removeAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 383,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "retainAll",
      "signature": "public boolean retainAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 387,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcConcurrentQueueSMBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "InlinedCountersSpscConcurrentArrayQueue",
      "signature": "public InlinedCountersSpscConcurrentArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        super(capacity);\n    }",
      "line_number": 173,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "headLazySet",
      "signature": "private void headLazySet(long v) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, HEAD_OFFSET, v);\n    }",
      "line_number": 177,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "getHead",
      "signature": "private long getHead() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return head;\n    }",
      "line_number": 181,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "tailLazySet",
      "signature": "private void tailLazySet(long v) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, TAIL_OFFSET, v);\n    }",
      "line_number": 185,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "getTail",
      "signature": "private long getTail() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return tail;\n    }",
      "line_number": 189,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        if (offer(e)) {\n            return true;\n        }\n        throw new IllegalStateException(\"Queue is full\");\n    }",
      "line_number": 193,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "offset",
      "signature": "private long offset(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ARRAY_BASE + ((index & mask) << ELEMENT_SHIFT);\n    }",
      "line_number": 200,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putObject",
        "UNSAFE.putObject",
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n\n        final long currentTail = getTail();\n        final long wrapPoint = currentTail - capacity + 32;\n        if (headCache <= wrapPoint) {\n            headCache = getHead();\n            if (headCache <= wrapPoint) {\n                return false;\n            }\n        }\n        UNSAFE.putObject(buffer, offset(currentTail), e);\n        tailLazySet(currentTail + 1);\n\n        return true;\n    }",
      "line_number": 204,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putObject",
        "UNSAFE.putObject",
        "getObject",
        "UNSAFE.getObject"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long currentHead = getHead();\n        if (currentHead >= tailCache) {\n            tailCache = getTail();\n            if (currentHead >= tailCache) {\n                return null;\n            }\n        }\n\n        final long offset = offset(currentHead);\n        @SuppressWarnings(\"unchecked\")\n        final E e = (E) UNSAFE.getObject(buffer, offset);\n        UNSAFE.putObject(buffer, offset, null);\n\n        headLazySet(currentHead + 1);\n\n        return e;\n    }",
      "line_number": 223,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public E remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = poll();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 242,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "element",
      "signature": "public E element() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = peek();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 251,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        long currentHead = getHead();\n        return getElement(currentHead);\n    }",
      "line_number": 260,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "getElement",
      "signature": "private E getElement(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getObject",
        "UNSAFE.getObject"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final long offset = offset(index);\n        return (E) UNSAFE.getObject(buffer, offset);\n    }",
      "line_number": 266,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (int) (getTail() - getHead());\n    }",
      "line_number": 271,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getTail() == getHead();\n    }",
      "line_number": 275,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "o.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (null == o) {\n            return false;\n        }\n\n        for (long i = getHead(), limit = getTail(); i < limit; i++) {\n            final E e = getElement(i);\n            if (o.equals(e)) {\n                return true;\n            }\n        }\n\n        return false;\n    }",
      "line_number": 279,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(final T[] a) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "T",
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 302,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 306,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "containsAll",
      "signature": "public boolean containsAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "        for (final Object o : c) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n\n        return true;\n    }",
      "line_number": 310,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(final Collection<? extends E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        for (final E e : c) {\n            add(e);\n        }\n\n        return true;\n    }",
      "line_number": 320,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "removeAll",
      "signature": "public boolean removeAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 328,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "retainAll",
      "signature": "public boolean retainAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 332,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "InlinedRingBufferL0Pad",
      "method_type": "method"
    },
    {
      "name": "FloatingCountersSpscConcurrentArrayQueue",
      "signature": "public FloatingCountersSpscConcurrentArrayQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        super(capacity);\n    }",
      "line_number": 103,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        if (offer(e)) {\n            return true;\n        }\n        throw new IllegalStateException(\"Queue is full\");\n    }",
      "line_number": 107,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "offset",
      "signature": "private long offset(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ARRAY_BASE + ((index & mask) << ELEMENT_SHIFT);\n    }",
      "line_number": 114,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lpVal",
        "head.lvVal",
        "tail.lvVal",
        "headCache.spVal",
        "tail.soVal",
        "putObject",
        "UNSAFE.putObject",
        "NullPointerException",
        "soVal",
        "spVal",
        "lvVal",
        "headCache.lpVal"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n\n        final long currTail = tail.lvVal();\n        final long wrapPoint = currTail - capacity + 32;\n        if (headCache.lpVal() <= wrapPoint) {\n            final long currHead = head.lvVal();\n            headCache.spVal(currHead);\n            if (currHead <= wrapPoint) {\n                return false;\n            }\n        }\n        UNSAFE.putObject(buffer, offset(currTail), e);\n        tail.soVal(currTail + 1);\n\n        return true;\n    }",
      "line_number": 118,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "tailCache.spVal",
        "lpVal",
        "head.lvVal",
        "tail.lvVal",
        "putObject",
        "UNSAFE.putObject",
        "getObject",
        "soVal",
        "spVal",
        "lvVal",
        "head.soVal",
        "tailCache.lpVal",
        "UNSAFE.getObject"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final long currHead = head.lvVal();\n        if (currHead >= tailCache.lpVal()) {\n            final long currTail = tail.lvVal();\n            tailCache.spVal(currTail);\n            if (currHead >= currTail) {\n                return null;\n            }\n        }\n\n        final long offset = offset(currHead);\n        @SuppressWarnings(\"unchecked\")\n        final E e = (E) UNSAFE.getObject(buffer, offset);\n        UNSAFE.putObject(buffer, offset, null);\n\n        head.soVal(currHead + 1);\n\n        return e;\n    }",
      "line_number": 138,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public E remove() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = poll();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 158,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "element",
      "signature": "public E element() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        final E e = peek();\n        if (null == e) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n\n        return e;\n    }",
      "line_number": 167,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "head.lvVal",
        "lvVal"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        long currentHead = head.lvVal();\n        return getElement(currentHead);\n    }",
      "line_number": 176,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "getElement",
      "signature": "private E getElement(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getObject",
        "UNSAFE.getObject"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final long offset = offset(index);\n        return (E) UNSAFE.getObject(buffer, offset);\n    }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "head.lvVal",
        "tail.lvVal",
        "lvVal",
        "o.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (null == o) {\n            return false;\n        }\n\n        for (long i = head.lvVal(), limit = tail.lvVal(); i < limit; i++) {\n            final E e = getElement(i);\n            if (o.equals(e)) {\n                return true;\n            }\n        }\n\n        return false;\n    }",
      "line_number": 195,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(final T[] a) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "T",
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 218,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(final Object o) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 222,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "containsAll",
      "signature": "public boolean containsAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "        for (final Object o : c) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n\n        return true;\n    }",
      "line_number": 226,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(final Collection<? extends E> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        for (final E e : c) {\n            add(e);\n        }\n\n        return true;\n    }",
      "line_number": 236,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "removeAll",
      "signature": "public boolean removeAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 244,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "retainAll",
      "signature": "public boolean retainAll(final Collection<?> c) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        throw new UnsupportedOperationException();\n    }",
      "line_number": 248,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FloatingCaqL0Pad",
      "method_type": "method"
    },
    {
      "name": "waitPoll",
      "signature": "public E waitPoll(Queue<E> q) throws InterruptedException {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/blocking/ScParkTakeStrategy.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "wait",
        "lock",
        "Thread"
      ],
      "dependencies": [
        "q.poll",
        "currentThread",
        "lazySet",
        "currentThread.isInterrupted",
        "InterruptedException",
        "Thread.currentThread",
        "WAITING_UPDATER.lazySet",
        "park",
        "LockSupport.park",
        "poll",
        "isInterrupted",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 25,
      "source_code": "        E e = q.poll();\n        if (e != null) {\n            return e;\n        }\n\n        Thread currentThread = Thread.currentThread();\n        waiting = currentThread;\n\n        while ((e = q.poll()) == null) {\n            LockSupport.park();\n\n            if (currentThread.isInterrupted()) {\n                throw new InterruptedException(\"Interrupted while waiting for the queue to become non-empty.\");\n            }\n        }\n\n        WAITING_UPDATER.lazySet(this, null);\n\n        return e;\n    }",
      "line_number": 28,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ScParkTakeStrategy",
      "method_type": "method"
    },
    {
      "name": "setNext",
      "signature": "public void setNext(Node next) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/NodeImpl.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        lazySet(next);\n    }",
      "line_number": 22,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "NodeImpl",
      "method_type": "method"
    },
    {
      "name": "getNext",
      "signature": "public Node getNext() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/NodeImpl.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return get();\n    }",
      "line_number": 27,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "NodeImpl",
      "method_type": "method"
    },
    {
      "name": "lvProducerNode",
      "signature": "protected final Node lvProducerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return producerNode;\n    }",
      "line_number": 49,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "xchgProducerNode",
      "signature": "protected final Node xchgProducerNode(Node node) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "getAndSet"
      ],
      "dependencies": [
        "getAndSetObject",
        "UNSAFE.getAndSetObject"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        // TODO: add support for JDK < 8 per org.jctools.queues.MpscLinkedQueue / MpscLinkedQueue8\n        return (Node) UNSAFE.getAndSetObject(this, P_NODE_OFFSET, node);\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "spConsumerNode",
      "signature": "protected final void spConsumerNode(Node node) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        consumerNode = node;\n    }",
      "line_number": 84,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "lvConsumerNode",
      "signature": "protected final Node lvConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return (Node) UNSAFE.getObjectVolatile(this, C_NODE_OFFSET);\n    }",
      "line_number": 88,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "lpConsumerNode",
      "signature": "protected final Node lpConsumerNode() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return consumerNode;\n    }",
      "line_number": 92,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(Node node) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "setNext",
        "NullPointerException",
        "node.setNext",
        "prev.setNext"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (node == null) {\n            throw new NullPointerException();\n        }\n        node.setNext(null);\n        Node prev = xchgProducerNode(node);\n        // bubble potential\n        prev.setNext(node);\n        return true;\n    }",
      "line_number": 106,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public Node poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "signal"
      ],
      "dependencies": [
        "this.lpConsumerNode",
        "setNext",
        "this.lvProducerNode",
        "spConsumerNode",
        "cNode.getNext",
        "next.getNext",
        "lvProducerNode",
        "this.spConsumerNode",
        "getNext",
        "cNode.setNext",
        "lpConsumerNode"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        Node cNode = this.lpConsumerNode();\n        Node next = cNode.getNext();\n\n        if (cNode == this.stub) {\n            // consumer is stub, and next is null means queue is empty\n            if (next == null) {\n                return null;\n            }\n\n            // next is not null, we see a way out of stub, cNode is swapped for next and start again\n            this.spConsumerNode(next);\n            cNode = next;\n            next = next.getNext();\n        }\n        // cNode is not stub AND next is not null\n        if (next != null) {\n            this.spConsumerNode(next);\n            // prevent GC nepotism, signal consumed to size\n            cNode.setNext(stub);\n            return cNode;\n        }\n\n        Node pNode = this.lvProducerNode();\n        // doesn't this imply a bubble?\n        if (cNode != pNode) {\n            return null;\n        }\n\n        offer(stub);\n        next = cNode.getNext();\n        if (next != null) {\n            this.spConsumerNode(next);\n            // prevent GC nepotism, signal consumed to size\n            cNode.setNext(stub);\n            return cNode;\n        }\n\n        return null;\n    }",
      "line_number": 117,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public Node peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "this.lpConsumerNode",
        "tail.getNext",
        "getNext",
        "lpConsumerNode"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final Node tail = this.lpConsumerNode();\n\n        if (tail == stub) {\n            return tail.getNext();\n        } else {\n            return tail;\n        }\n    }",
      "line_number": 158,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/intrusive/MpscIntrusiveLinkedQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getNext",
        "chaserNode.getNext"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n        // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n        final Node stub = this.stub;\n        Node chaserNode = lvConsumerNode();\n        if (chaserNode == stub) {\n            chaserNode = chaserNode.getNext();\n        }\n\n        final Node producerNode = lvProducerNode();\n        int size = 0;\n        // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n        while (chaserNode != null && chaserNode != stub &&\n               size < Integer.MAX_VALUE) // stop at max int\n        {\n            if (chaserNode == producerNode) {\n                return size + 1;\n            }\n            chaserNode = chaserNode.getNext();\n            size++;\n        }\n        return size;\n    }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscIntrusiveLinkedQueuePad0",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "protected final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            return producerIndex;\n        }",
      "line_number": 31,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "protected final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapLong(this, P_INDEX_OFFSET, expect, newValue);\n        }",
      "line_number": 35,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "lvConsumerIndex",
        "consumer.lvConsumerIndex"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "            if (null == e) {\n                throw new NullPointerException(\"Null is not a valid element\");\n            }\n\n            // local load of field to avoid repeated loads after volatile reads\n            final long mask = this.mask;\n            final long capacity = mask + 1;\n            final long[] sBuffer = sequenceBuffer;\n            long currIndex;\n            long sOffset;\n            long cIndex = Long.MAX_VALUE;// start with bogus value, hope we don't need it\n            while (true) {\n                currIndex = lvProducerIndex(); // LoadLoad\n                sOffset = calcSequenceOffset(currIndex, mask);\n                final long delta = lvSequence(sBuffer, sOffset) - currIndex;\n\n                if (delta == 0) {\n                    // this is expected if we see this first time around\n                    if (casProducerIndex(currIndex, currIndex + 1)) {\n                        // Successful CAS: full barrier\n                        break;\n                    }\n                    // failed cas, retry 1\n                } else if (delta < 0 && // poll has not moved this value forward\n                        currIndex - capacity <= cIndex && // test against cached cIndex\n                        currIndex - capacity <= (cIndex = consumer.lvConsumerIndex())) { // test against\n                                                                                         // latest\n                    // Extra check required to ensure [Queue.offer == false iff queue is full]\n                    return false;\n                }\n                // another producer has moved the sequence by one, retry 2\n            }\n            addElement(sBuffer, buffer, mask, currIndex, sOffset, e);\n\n            return true;\n        }",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "addElement",
      "signature": "private void addElement(long[] sBuffer, E[] eBuffer, long mask, long index, long sOffset, final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            // on 64bit(no compressed oops) JVM this is the same as seqOffset\n            final long elementOffset = calcOffset(index, mask);\n            spElement(elementOffset, e);\n\n            // increment sequence by 1, the value expected by consumer\n            // (seeing this value from a producer will lead to retry 2)\n            soSequence(sBuffer, sOffset, index + 1); // StoreStore\n        }",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakOffer",
      "signature": "public boolean weakOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "            if (null == e) {\n                throw new NullPointerException(\"Null is not a valid element\");\n            }\n            final long[] sBuffer = sequenceBuffer;\n            final long mask = this.mask;\n            final E[] eBuffer = buffer;\n            return weakOffer(sBuffer, eBuffer, mask, e);\n        }",
      "line_number": 112,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakOffer",
      "signature": "private boolean weakOffer(final long[] sBuffer, final E[] eBuffer, final long mask, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "            long currIndex;\n            long sOffset;\n\n            while(true) {\n                currIndex = lvProducerIndex();\n                sOffset = calcSequenceOffset(currIndex, mask);\n                long delta = lvSequence(sBuffer, sOffset) - currIndex;\n                if (delta == 0) {\n                    // this is expected if we see this first time around\n                    if (casProducerIndex(currIndex, currIndex + 1)) {\n                        break;\n                    }\n                    // failed cas, retry 1\n                } else if (delta < 0) {\n                    // poll has not moved this value forward, but that doesn't mean\n                    // queue is full.\n                    return false;\n                }\n            }\n\n            addElement(sBuffer, eBuffer, mask, currIndex, sOffset, e);\n            return true;\n        }",
      "line_number": 122,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "produce",
      "signature": "public int produce(ProducerFunction<E> producer, int batchSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "E",
        "producer.produce",
        "produce"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "            final long[] sBuffer = this.sequenceBuffer;\n            final E[] eBuffer = this.buffer;\n            final long mask = this.mask;\n            long tDelta;\n            long currIndex;\n            long targetIndex;\n            do {\n                currIndex = lvProducerIndex();// LoadLoad\n                targetIndex = currIndex + batchSize - 1;\n                final long tsOffset = calcSequenceOffset(targetIndex, mask);\n                tDelta = lvSequence(sBuffer, tsOffset) - targetIndex;\n            } while ((tDelta == 0 && !casProducerIndex(currIndex, targetIndex+1)) || tDelta > 0);\n\n            if (tDelta == 0) {\n                // can now produce all elements\n                for (int i = 0; i < batchSize; i++) {\n                    // The 'availability' of the target slot is not indicative of the 'availability' of every slot up to\n                    // it. We have to consume all the elements now that we claimed the slots, so if they are not visible\n                    // we must block.\n                    long eSequence;\n                    long eDelta;\n                    long sOffset;\n                    do {\n                        sOffset = calcSequenceOffset(currIndex, mask);\n                        eSequence = lvSequence(sBuffer, sOffset);// LoadLoad\n                        eDelta = eSequence - currIndex;\n                    } while (eDelta != 0);\n                    addElement(sBuffer, eBuffer, mask, currIndex++, sOffset, producer.produce());\n                }\n                return batchSize;\n            }\n            // bugger, queue is either:\n            // (a) full\n            // (b) has less than batchSize slots open\n            // (c) slot at batch target is not available\n            // we take the easy way out and weakOffer through this case\n            int i = 0;\n            for (; i < batchSize; i++) {\n                if (!weakOffer(sBuffer, eBuffer, mask, producer.produce())) {\n                    break;\n                }\n           ",
      "line_number": 148,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "protected final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            return consumerIndex;\n        }",
      "line_number": 205,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "casConsumerIndex",
      "signature": "protected final boolean casConsumerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapLong(this, C_INDEX_OFFSET, expect, newValue);\n        }",
      "line_number": 209,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakPoll",
      "signature": "public E weakPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 3,
      "source_code": "            // local load of field to avoid repeated loads after volatile reads\n            return weakPoll(sequenceBuffer, buffer, mask);\n        }",
      "line_number": 237,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakPoll",
      "signature": "private E weakPoll(final long[] sBuffer, E[] eBuffer, final long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "            long currIndex;\n            long sOffset;\n            while (true) {\n                currIndex = lvConsumerIndex();// LoadLoad\n                sOffset = calcSequenceOffset(currIndex, mask);\n                final long delta = lvSequence(sBuffer, sOffset) - (currIndex + 1);\n\n                if (delta == 0) {\n                    if (casConsumerIndex(currIndex, currIndex + 1)) {\n                        // Successful CAS: full barrier\n                        break;\n                    }\n                    // failed cas, retry 1\n                } else if (delta < 0) {\n                    // nothing here, but queue might not be empty\n                    return null;\n                }\n\n                // another consumer beat us and moved sequence ahead, retry 2\n            }\n\n            return consumeElement(sBuffer, eBuffer, mask, currIndex, sOffset);\n        }",
      "line_number": 242,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "producer.lvProducerIndex",
        "lvProducerIndex",
        "poll",
        "Queue.poll",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 21,
      "source_code": "            // local load of fields to avoid repeated loads after volatile reads\n            final long[] sBuffer = sequenceBuffer;\n            final long mask = this.mask;\n            final Producer<E> producer = this.producer;\n            long currentConsumerIndex;\n            long sOffset;\n            long pIndex = -1; // start with bogus value, hope we don't need it\n            while (true) {\n                currentConsumerIndex = lvConsumerIndex();// LoadLoad\n                sOffset = calcSequenceOffset(currentConsumerIndex, mask);\n                final long delta = lvSequence(sBuffer, sOffset) - (currentConsumerIndex + 1);\n\n                if (delta == 0) {\n                    if (casConsumerIndex(currentConsumerIndex, currentConsumerIndex + 1)) {\n                        // Successful CAS: full barrier\n                        break;\n                    }\n                    // failed cas, retry 1\n                } else if (delta < 0 && // slot has not been moved by producer\n                        currentConsumerIndex >= pIndex && // test against cached pIndex\n                        currentConsumerIndex == (pIndex = producer.lvProducerIndex())) { // update pIndex if\n                                                                                         // we must\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                }\n\n                // another consumer beat us and moved sequence ahead, retry 2\n            }\n\n            return consumeElement(sBuffer, buffer, mask, currentConsumerIndex, sOffset);\n        }",
      "line_number": 274,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lvProducerIndex",
        "producer.lvProducerIndex"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            long currConsumerIndex;\n            E e;\n            do {\n                currConsumerIndex = lvConsumerIndex();\n                // other consumers may have grabbed the element, or queue might be empty\n                e = lpElement(calcOffset(currConsumerIndex));\n                // only return null if queue is empty\n            } while (e == null && currConsumerIndex != producer.lvProducerIndex());\n            return e;\n        }",
      "line_number": 308,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "consumeElement",
      "signature": "private E consumeElement(long[] sBuffer, E[] eBuffer, long mask, long currIndex, long sOffset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "            final long eOffset = calcOffset(currIndex, mask);\n            final E e = lpElement(eOffset);\n            spElement(eBuffer, eOffset, null);\n\n            // Move sequence ahead by capacity, preparing it for next offer\n            // (seeing this value from a consumer will lead to retry 2)\n            soSequence(sBuffer, sOffset, currIndex + mask + 1);// StoreStore\n            return e;\n        }",
      "line_number": 326,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "consume",
      "signature": "public int consume(ConsumerFunction<E> consumer, int batchSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "consumer.consume",
        "consume",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "            final long[] sBuffer = this.sequenceBuffer;\n            final E[] eBuffer = this.buffer;\n            final long mask = this.mask;\n            long tDelta;\n            long currIndex;\n            long targetIndex;\n            do {\n                currIndex = lvConsumerIndex();// LoadLoad\n                targetIndex = currIndex + batchSize - 1;\n                final long sOffset = calcSequenceOffset(targetIndex, mask);\n                tDelta = lvSequence(sBuffer, sOffset) - (targetIndex + 1);\n            } while ((tDelta == 0 && !casConsumerIndex(currIndex, targetIndex+1)) || tDelta > 0);\n\n            if (tDelta == 0) {\n                // can now consume all elements\n                for (int i = 0; i < batchSize; i++) {\n                    // The 'availability' of the target slot is not indicative of the 'availability' of every slot up to\n                    // it. We have to consume all the elements now that we claimed the slots, so if they are not visible\n                    // we must block.\n                    long eDelta;\n                    long sOffset;\n                    do {\n                        sOffset = calcSequenceOffset(currIndex, mask);\n                        eDelta = lvSequence(sBuffer, sOffset) - (currIndex + 1);\n                    } while (eDelta != 0);\n                    E e = consumeElement(sBuffer, eBuffer, mask, currIndex++, sOffset);\n                    consumer.consume(e);\n                }\n                return batchSize;\n            }\n            // bugger, queue is either:\n            // (a) empty\n            // (b) has less than batchSize elements\n            // (c) slot at batch target is unavailable\n            // we take the easy way out and weakPoll through this case\n            int i = 0;\n            for (; i < batchSize; i++) {\n                final E e = weakPoll(sBuffer, eBuffer, mask);\n                if (e == null) {\n                    break;\n                }\n                consumer.consume(e);\n            }\n",
      "line_number": 338,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakPeek",
      "signature": "public E weakPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            final long currConsumerIndex = lvConsumerIndex();\n            // other consumers may have grabbed the element, or queue might be empty\n            final E e = lpElement(calcOffset(currConsumerIndex));\n            return e;\n        }",
      "line_number": 386,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "MpmcArrayConcurrentQueue",
      "signature": "public MpmcArrayConcurrentQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        super(Math.max(2, capacity));\n    }",
      "line_number": 426,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpmcArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "calcOffset",
      "signature": "protected final long calcOffset(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return REF_ARRAY_BASE + ((index & mask) << REF_ELEMENT_SHIFT);\n    }",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "calcOffset",
      "signature": "protected final long calcOffset(long index, long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return REF_ARRAY_BASE + ((index & mask) << REF_ELEMENT_SHIFT);\n    }",
      "line_number": 66,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "spElement",
      "signature": "protected final void spElement(long offset, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putObject",
        "UNSAFE.putObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putObject(buffer, offset, e);\n    }",
      "line_number": 70,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "soElement",
      "signature": "protected final void soElement(long offset, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedObject",
        "UNSAFE.putOrderedObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedObject(buffer, offset, e);\n    }",
      "line_number": 74,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "svElement",
      "signature": "protected final void svElement(long offset, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.putObjectVolatile",
        "putObjectVolatile"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        UNSAFE.putObjectVolatile(buffer, offset, e);\n    }",
      "line_number": 78,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "lpElement",
      "signature": "protected final E lpElement(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getObject",
        "UNSAFE.getObject"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (E) UNSAFE.getObject(buffer, offset);\n    }",
      "line_number": 83,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "lvElement",
      "signature": "protected final E lvElement(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return (E) UNSAFE.getObjectVolatile(buffer, offset);\n    }",
      "line_number": 88,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "spElement",
      "signature": "protected final void spElement(E[] buffer, long offset, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putObject",
        "UNSAFE.putObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putObject(buffer, offset, e);\n    }",
      "line_number": 92,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "soElement",
      "signature": "protected final void soElement(E[] buffer, long offset, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedObject",
        "UNSAFE.putOrderedObject"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedObject(buffer, offset, e);\n    }",
      "line_number": 96,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "svElement",
      "signature": "protected final void svElement(E[] buffer, long offset, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.putObjectVolatile",
        "putObjectVolatile"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        UNSAFE.putObjectVolatile(buffer, offset, e);\n    }",
      "line_number": 100,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "lpElement",
      "signature": "protected final E lpElement(E[] buffer, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getObject",
        "UNSAFE.getObject"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (E) UNSAFE.getObject(buffer, offset);\n    }",
      "line_number": 105,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "lvElement",
      "signature": "protected final E lvElement(E[] buffer, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return (E) UNSAFE.getObjectVolatile(buffer, offset);\n    }",
      "line_number": 110,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentCircularArrayL0Pad",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "protected final long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            return producerIndex;\n        }",
      "line_number": 31,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "casProducerIndex",
      "signature": "protected final boolean casProducerIndex(long expect, long newValue) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapLong(this, P_INDEX_OFFSET, expect, newValue);\n        }",
      "line_number": 35,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "lvConsumerIndex",
        "consumer.lvConsumerIndex"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "            if (null == e) {\n                throw new NullPointerException(\"Null is not a valid element\");\n            }\n\n            // local load of field to avoid repeated loads after volatile reads\n            final long mask = this.mask;\n            final long capacity = mask + 1;\n            final long[] sBuffer = sequenceBuffer;\n            long currIndex;\n            long sOffset;\n            long cIndex = Long.MAX_VALUE;// start with bogus value, hope we don't need it\n            while (true) {\n                currIndex = lvProducerIndex(); // LoadLoad\n                sOffset = calcSequenceOffset(currIndex, mask);\n                final long delta = lvSequence(sBuffer, sOffset) - currIndex;\n\n                if (delta == 0) {\n                    // this is expected if we see this first time around\n                    if (casProducerIndex(currIndex, currIndex + 1)) {\n                        // Successful CAS: full barrier\n                        break;\n                    }\n                    // failed cas, retry 1\n                } else if (delta < 0 && // poll has not moved this value forward\n                        currIndex - capacity <= cIndex && // test against cached cIndex\n                        currIndex - capacity <= (cIndex = consumer.lvConsumerIndex())) { // test against\n                                                                                         // latest\n                    // Extra check required to ensure [Queue.offer == false iff queue is full]\n                    return false;\n                }\n                // another producer has moved the sequence by one, retry 2\n            }\n            addElement(sBuffer, buffer, mask, currIndex, sOffset, e);\n\n            return true;\n        }",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "addElement",
      "signature": "private void addElement(long[] sBuffer, E[] eBuffer, long mask, long index, long sOffset, final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            // on 64bit(no compressed oops) JVM this is the same as seqOffset\n            final long elementOffset = calcOffset(index, mask);\n            spElement(elementOffset, e);\n\n            // increment sequence by 1, the value expected by consumer\n            // (seeing this value from a producer will lead to retry 2)\n            soSequence(sBuffer, sOffset, index + 1); // StoreStore\n        }",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakOffer",
      "signature": "public boolean weakOffer(E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "            if (null == e) {\n                throw new NullPointerException(\"Null is not a valid element\");\n            }\n            final long[] sBuffer = sequenceBuffer;\n            final long mask = this.mask;\n            final E[] eBuffer = buffer;\n            return weakOffer(sBuffer, eBuffer, mask, e);\n        }",
      "line_number": 112,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakOffer",
      "signature": "private boolean weakOffer(final long[] sBuffer, final E[] eBuffer, final long mask, E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "            long currIndex;\n            long sOffset;\n\n            while(true) {\n                currIndex = lvProducerIndex();\n                sOffset = calcSequenceOffset(currIndex, mask);\n                long delta = lvSequence(sBuffer, sOffset) - currIndex;\n                if (delta == 0) {\n                    // this is expected if we see this first time around\n                    if (casProducerIndex(currIndex, currIndex + 1)) {\n                        break;\n                    }\n                    // failed cas, retry 1\n                } else if (delta < 0) {\n                    // poll has not moved this value forward, but that doesn't mean\n                    // queue is full.\n                    return false;\n                }\n            }\n\n            addElement(sBuffer, eBuffer, mask, currIndex, sOffset, e);\n            return true;\n        }",
      "line_number": 122,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "produce",
      "signature": "public int produce(ProducerFunction<E> producer, int batchSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "E",
        "producer.produce",
        "produce"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "            final long[] sBuffer = this.sequenceBuffer;\n            final E[] eBuffer = this.buffer;\n            final long mask = this.mask;\n            long tDelta;\n            long currIndex;\n            long targetIndex;\n            do {\n                currIndex = lvProducerIndex();// LoadLoad\n                targetIndex = currIndex + batchSize - 1;\n                final long tsOffset = calcSequenceOffset(targetIndex, mask);\n                tDelta = lvSequence(sBuffer, tsOffset) - targetIndex;\n            } while ((tDelta == 0 && !casProducerIndex(currIndex, targetIndex+1)) || tDelta > 0);\n\n            if (tDelta == 0) {\n                // can now produce all elements\n                for (int i = 0; i < batchSize; i++) {\n                    // The 'availability' of the target slot is not indicative of the 'availability' of every slot up to\n                    // it. We have to consume all the elements now that we claimed the slots, so if they are not visible\n                    // we must block.\n                    long eSequence;\n                    long eDelta;\n                    long sOffset;\n                    do {\n                        sOffset = calcSequenceOffset(currIndex, mask);\n                        eSequence = lvSequence(sBuffer, sOffset);// LoadLoad\n                        eDelta = eSequence - currIndex;\n                    } while (eDelta != 0);\n                    addElement(sBuffer, eBuffer, mask, currIndex++, sOffset, producer.produce());\n                }\n                return batchSize;\n            }\n            // bugger, queue is either:\n            // (a) full\n            // (b) has less than batchSize slots open\n            // (c) slot at batch target is not available\n            // we take the easy way out and weakOffer through this case\n            int i = 0;\n            for (; i < batchSize; i++) {\n                if (!weakOffer(sBuffer, eBuffer, mask, producer.produce())) {\n                    break;\n                }\n           ",
      "line_number": 148,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "lvConsumerIndex",
      "signature": "protected final long lvConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "            return UNSAFE.getLongVolatile(this, C_INDEX_OFFSET);\n        }",
      "line_number": 205,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "lpConsumerIndex",
      "signature": "protected final long lpConsumerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            return consumerIndex;\n        }",
      "line_number": 209,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "soConsumerIndex",
      "signature": "protected final void soConsumerIndex(long v) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            UNSAFE.putOrderedLong(this, C_INDEX_OFFSET, v);\n        }",
      "line_number": 213,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakPoll",
      "signature": "public E weakPoll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 3,
      "source_code": "            // local load of field to avoid repeated loads after volatile reads\n            return weakPoll(sequenceBuffer, buffer, mask);\n        }",
      "line_number": 241,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakPoll",
      "signature": "private E weakPoll(final long[] sBuffer, E[] eBuffer, final long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            long currIndex;\n            long sOffset;\n            currIndex = lpConsumerIndex();\n            sOffset = calcSequenceOffset(currIndex, mask);\n            final long delta = lvSequence(sBuffer, sOffset) - (currIndex + 1);\n\n            if (delta < 0) {\n                // nothing here, but queue might not be empty\n                return null;\n            }\n            soConsumerIndex(currIndex+1);\n            return consumeElement(sBuffer, eBuffer, mask, currIndex, sOffset);\n        }",
      "line_number": 246,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "producer.lvProducerIndex",
        "lvProducerIndex",
        "poll",
        "Queue.poll",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "            // local load of fields to avoid repeated loads after volatile reads\n            final long[] sBuffer = sequenceBuffer;\n            final long mask = this.mask;\n            final Producer<E> producer = this.producer;\n            final long currentConsumerIndex= lpConsumerIndex();\n            long sOffset;\n            while(true) {\n                sOffset = calcSequenceOffset(currentConsumerIndex, mask);\n                final long delta = lvSequence(sBuffer, sOffset) - (currentConsumerIndex + 1);\n                if(delta == 0)\n                    break;\n                if (delta < 0 && currentConsumerIndex == producer.lvProducerIndex()) {\n                    // strict empty check, this ensures [Queue.poll() == null iff isEmpty()]\n                    return null;\n                }\n            }\n            soConsumerIndex(currentConsumerIndex+1);\n            return consumeElement(sBuffer, buffer, mask, currentConsumerIndex, sOffset);\n        }",
      "line_number": 268,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lvProducerIndex",
        "producer.lvProducerIndex"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            long currConsumerIndex;\n            E e;\n            do {\n                currConsumerIndex = lvConsumerIndex();\n                // other consumers may have grabbed the element, or queue might be empty\n                e = lpElement(calcOffset(currConsumerIndex));\n                // only return null if queue is empty\n            } while (e == null && currConsumerIndex != producer.lvProducerIndex());\n            return e;\n        }",
      "line_number": 290,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "consumeElement",
      "signature": "private E consumeElement(long[] sBuffer, E[] eBuffer, long mask, long currIndex, long sOffset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "            final long eOffset = calcOffset(currIndex, mask);\n            final E e = lpElement(eOffset);\n            spElement(eBuffer, eOffset, null);\n\n            // Move sequence ahead by capacity, preparing it for next offer\n            // (seeing this value from a consumer will lead to retry 2)\n            soSequence(sBuffer, sOffset, currIndex + mask + 1);// StoreStore\n            return e;\n        }",
      "line_number": 308,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "consume",
      "signature": "public int consume(ConsumerFunction<E> consumer, int batchSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "consumer.consume",
        "consume",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "            final long[] sBuffer = this.sequenceBuffer;\n            final E[] eBuffer = this.buffer;\n            final long mask = this.mask;\n            long tDelta;\n            long currIndex;\n            long targetIndex;\n            currIndex = lvConsumerIndex();// LoadLoad\n            targetIndex = currIndex + batchSize - 1;\n            final long tsOffset = calcSequenceOffset(targetIndex, mask);\n            tDelta = lvSequence(sBuffer, tsOffset) - (targetIndex + 1);\n\n            if (tDelta == 0) {\n                // can now consume all elements\n                for (int i = 0; i < batchSize; i++) {\n                    // The 'availability' of the target slot is not indicative of the 'availability' of every slot up to\n                    // it. We have to consume all the elements now that we claimed the slots, so if they are not visible\n                    // we must block.\n                    long eDelta;\n                    long sOffset;\n                    do {\n                        sOffset = calcSequenceOffset(currIndex, mask);\n                        eDelta = lvSequence(sBuffer, sOffset) - (currIndex + 1);\n                    } while (eDelta != 0);\n                    E e = consumeElement(sBuffer, eBuffer, mask, currIndex++, sOffset);\n                    consumer.consume(e);\n                }\n                return batchSize;\n            }\n            // bugger, queue is either:\n            // (a) empty\n            // (b) has less than batchSize elements\n            // (c) slot at batch target is unavailable\n            // we take the easy way out and weakPoll through this case\n            int i = 0;\n            for (; i < batchSize; i++) {\n                final E e = weakPoll(sBuffer, eBuffer, mask);\n                if (e == null) {\n                    break;\n                }\n                consumer.consume(e);\n            }\n            return i;\n        }",
      "line_number": 320,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "weakPeek",
      "signature": "public E weakPeek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            final long currConsumerIndex = lvConsumerIndex();\n            // other consumers may have grabbed the element, or queue might be empty\n            final E e = lpElement(calcOffset(currConsumerIndex));\n            return e;\n        }",
      "line_number": 366,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "MpscArrayConcurrentQueue",
      "signature": "public MpscArrayConcurrentQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/MpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        super(Math.max(2, capacity));\n    }",
      "line_number": 406,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "MpscArrayConcurrentQueueColdFields",
      "method_type": "method"
    },
    {
      "name": "ConcurrentSequencedCircularArray",
      "signature": "public ConcurrentSequencedCircularArray(int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        super(capacity);\n        // pad data on either end with some empty slots.\n        int actualCapacity = (int)this.mask + 1;\n        sequenceBuffer = new long[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];\n        for (long i = 0; i < actualCapacity; i++) {\n            soSequenceElement(calcSequenceOffset(i), i);\n        }\n    }",
      "line_number": 22,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "constructor"
    },
    {
      "name": "calcSequenceOffset",
      "signature": "protected final long calcSequenceOffset(long index) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ARRAY_BASE + ((index & mask) << ELEMENT_SHIFT);\n    }",
      "line_number": 37,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "calcSequenceOffset",
      "signature": "protected final long calcSequenceOffset(long index, long mask) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ARRAY_BASE + ((index & mask) << ELEMENT_SHIFT);\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "spSequenceElement",
      "signature": "protected final void spSequenceElement(long offset, long e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putLong",
        "UNSAFE.putLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putLong(sequenceBuffer, offset, e);\n    }",
      "line_number": 44,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "soSequenceElement",
      "signature": "protected final void soSequenceElement(long offset, long e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(sequenceBuffer, offset, e);\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "svSequenceElement",
      "signature": "protected final void svSequenceElement(long offset, long e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "putLongVolatile",
        "UNSAFE.putLongVolatile"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        UNSAFE.putLongVolatile(sequenceBuffer, offset, e);\n    }",
      "line_number": 52,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "lpSequence",
      "signature": "protected final long lpSequence(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(sequenceBuffer, offset);\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "lvSequence",
      "signature": "protected final long lvSequence(long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(sequenceBuffer, offset);\n    }",
      "line_number": 60,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "spSequenceElement",
      "signature": "protected final void spSequenceElement(long[] buffer, long offset, long e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putLong",
        "UNSAFE.putLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putLong(buffer, offset, e);\n    }",
      "line_number": 64,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "soSequence",
      "signature": "protected final void soSequence(long[] buffer, long offset, long e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(buffer, offset, e);\n    }",
      "line_number": 68,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "svSequenceElement",
      "signature": "protected final void svSequenceElement(long[] buffer, long offset, long e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "putLongVolatile",
        "UNSAFE.putLongVolatile"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        UNSAFE.putLongVolatile(buffer, offset, e);\n    }",
      "line_number": 72,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "lpSequenceElement",
      "signature": "protected final long lpSequenceElement(long[] buffer, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getLong(buffer, offset);\n    }",
      "line_number": 76,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "lvSequence",
      "signature": "protected final long lvSequence(long[] buffer, long offset) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentSequencedCircularArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(buffer, offset);\n    }",
      "line_number": 80,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ConcurrentSequencedCircularArray",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(final E e) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        if (null == e) {\n            throw new NullPointerException(\"Null is not a valid element\");\n        }\n\n        final E[] lb = buffer;\n        final long mask = this.mask;\n        final long pIndex = producerIndex;\n        if (pIndex >= batchTail) {\n            if (null == lvElement(lb, calcOffset(pIndex + OFFER_BATCH_SIZE, mask))) {\n                batchTail = pIndex + OFFER_BATCH_SIZE;\n            } else if (null != lvElement(lb, calcOffset(pIndex, mask))) {\n                return false;\n            }\n        }\n        soElement(lb, calcOffset(pIndex, mask), e);\n        soProducerIndex(pIndex + 1);\n\n        return true;\n    }",
      "line_number": 56,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "getProducerIndexForSize",
      "signature": "long getProducerIndexForSize() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return Math.max(lvProducerIndex(), producerIndex);\n    }",
      "line_number": 77,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "lvProducerIndex",
      "signature": "private long lvProducerIndex() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(this, TAIL_OFFSET);\n    }",
      "line_number": 81,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "soProducerIndex",
      "signature": "private void soProducerIndex(long newHead) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, TAIL_OFFSET, newHead);\n    }",
      "line_number": 85,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "produce",
      "signature": "public int produce(ProducerFunction<E> p, int batchSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E",
        "p.produce",
        "produce"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final E[] lb = buffer;\n        final long mask = this.mask;\n        long pIndex = producerIndex;\n        final long tIndex = pIndex + batchSize - 1;\n\n        if (tIndex >= batchTail) {\n            if (null == lvElement(lb, calcOffset(tIndex + OFFER_BATCH_SIZE, mask))) {\n                batchTail = tIndex + OFFER_BATCH_SIZE;\n            } else {\n                for(int i=0;i<batchSize;i++) {\n                    if (null != lvElement(lb, calcOffset(pIndex, mask)))\n                        return i;\n                    soElement(lb, calcOffset(pIndex, mask), p.produce());\n                    soProducerIndex(++pIndex);\n                }\n                return batchSize;\n            }\n        }\n        soProducerIndex(pIndex + batchSize);\n        for(int i=0;i<batchSize;i++) {\n            soElement(lb, calcOffset(pIndex++, mask), p.produce());\n        }\n        return batchSize;\n    }",
      "line_number": 95,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final long head = this.head;\n        final long offset = calcOffset(head);\n        final E[] lb = buffer;\n        final E e = lvElement(lb, offset);\n        if (null == e) {\n            return null;\n        }\n        soElement(lb, offset, null);\n        soHead(head + 1);\n        return e;\n    }",
      "line_number": 155,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return lpElement(calcOffset(head));\n    }",
      "line_number": 169,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "getHeadForSize",
      "signature": "long getHeadForSize() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return Math.max(lvHead(), head);\n    }",
      "line_number": 179,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "lvHead",
      "signature": "private long lvHead() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.getLongVolatile",
        "getLongVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return UNSAFE.getLongVolatile(this, HEAD_OFFSET);\n    }",
      "line_number": 183,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "soHead",
      "signature": "private void soHead(long newHead) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putOrderedLong",
        "UNSAFE.putOrderedLong"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.putOrderedLong(this, HEAD_OFFSET, newHead);\n    }",
      "line_number": 187,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "consume",
      "signature": "public int consume(ConsumerFunction<E> c, int batch) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "c.consume",
        "consume",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        final E[] lb = buffer;\n        long currHead = head;\n        long offset = calcOffset(currHead);\n        E e = lvElement(lb, offset);\n        int i = 0;\n        for (; i < batch && null != e; i++) {\n            soElement(lb, offset, null);\n            soHead(++currHead);\n            c.consume(e); // NOTE: we've committed to consuming the batch, no check.\n            offset = calcOffset(currHead);\n            e = lvElement(lb, offset);\n        }\n        return i;\n    }",
      "line_number": 192,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "SpscArrayConcurrentQueue",
      "signature": "public SpscArrayConcurrentQueue(final int capacity) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Math.max",
        "max"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 2,
      "source_code": "        super(Math.max(capacity, 2 * OFFER_BATCH_SIZE));\n    }",
      "line_number": 252,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/SpscArrayConcurrentQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getProducerIndexForSize",
        "producer.getProducerIndexForSize",
        "consumer.getHeadForSize",
        "getHeadForSize"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        long headForSize = consumer.getHeadForSize();\n        long tailForSize = producer.getProducerIndexForSize();\n        return (int) (tailForSize - headForSize);\n    }",
      "line_number": 257,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ProducerFields",
      "method_type": "method"
    },
    {
      "name": "consume",
      "signature": "public int consume(ConsumerFunction<E> consumer, int batchSize) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-experimental/src/main/java/org/jctools/queues/alt/ConcurrentQueueFactory.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "consumer.consume",
        "consume",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "            E e;\n            int i=0;\n            for(;i<batchSize;i++) {\n                if((e = weakPoll()) == null){\n                    break;\n                }\n                consumer.consume(e);\n            }\n            return i;\n        }",
      "line_number": 63,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "ConcurrentQueueFactory",
      "method_type": "method"
    },
    {
      "name": "removePaddingFields",
      "signature": "public static void removePaddingFields(ClassOrInterfaceDeclaration node) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/util/GeneratorUtils.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "node.getFields",
        "getFields",
        "get",
        "field.getVariables",
        "startsWith",
        "node.remove",
        "fieldName.startsWith",
        "getNameAsString",
        "remove",
        "getVariables"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        // remove padding fields\n        for (FieldDeclaration field : node.getFields())\n        {\n            String fieldName = field.getVariables().get(0).getNameAsString();\n            if (fieldName.startsWith(\"b0\") || fieldName.startsWith(\"b1\")) {\n                node.remove(field);\n            }\n        }\n    }",
      "line_number": 31,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "GeneratorUtils",
      "method_type": "method"
    },
    {
      "name": "buildGenerator",
      "signature": "public static <T> T buildGenerator(Class<? extends T> generatorClass, String fileName) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/util/GeneratorUtils.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "T",
        "newInstance",
        "generatorClass.getDeclaredConstructor",
        "getDeclaredConstructor"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return generatorClass.getDeclaredConstructor(String.class).newInstance(fileName);\n    }",
      "line_number": 45,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "GeneratorUtils",
      "method_type": "method"
    },
    {
      "name": "formatMultilineJavadoc",
      "signature": "public static String formatMultilineJavadoc(int indent, String... lines) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/util/GeneratorUtils.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 4,
      "source_code": "        String indentation = \"\";\n        for (int i = 0; i < indent; i++) {\n            indentation += INDENT_LEVEL;\n        }\n\n        String out = \"\\n\";\n        for (String line : lines) {\n            out += indentation + \" * \" + line + \"\\n\";\n        }\n        out += indentation + \" \";\n        return out;\n    }",
      "line_number": 54,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "GeneratorUtils",
      "method_type": "method"
    },
    {
      "name": "runJCToolsGenerator",
      "signature": "public static void runJCToolsGenerator(Class<? extends JCToolsGenerator> generatorClass, String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/util/GeneratorUtils.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "file.getName",
        "write",
        "translateQueueName",
        "cu.toString",
        "File",
        "generator.translateQueueName",
        "FileWriter",
        "generator.cleanupComments",
        "getName",
        "generator.organiseImports",
        "IllegalArgumentException",
        "parse",
        "writer.write",
        "visit",
        "out.println",
        "cleanupComments",
        "organiseImports",
        "get",
        "generator.visit",
        "toString",
        "println",
        "getResult",
        "JavaParser",
        "replace"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "\n        if (args.length < 2) {\n            throw new IllegalArgumentException(\"Usage: outputDirectory inputSourceFiles\");\n        }\n\n        File outputDirectory = new File(args[0]);\n\n        for (int i = 1; i < args.length; i++) {\n            File file = new File(args[i]);\n            System.out.println(\"Processing \" + file);\n            CompilationUnit cu = new JavaParser().parse(file).getResult().get();\n            JCToolsGenerator generator = buildGenerator(generatorClass, file.getName());\n            generator.visit(cu, null);\n            generator.organiseImports(cu);\n            generator.cleanupComments(cu);\n\n            String outputFileName = generator.translateQueueName(file.getName().replace(\".java\", \"\")) + \".java\";\n\n            try (FileWriter writer = new FileWriter(new File(outputDirectory, outputFileName))) {\n                writer.write(cu.toString());\n            }\n\n            System.out.println(\"Saved to \" + outputFileName);\n        }\n    }",
      "line_number": 68,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "GeneratorUtils",
      "method_type": "method"
    },
    {
      "name": "outputPackage",
      "signature": "protected String outputPackage() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "producer_consumer"
      ],
      "complexity_score": 4,
      "source_code": "        return \"org.jctools.queues.atomic\";\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "producer_consumer",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "queueClassNamePrefix",
      "signature": "protected String queueClassNamePrefix() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        return \"Atomic\";\n    }",
      "line_number": 65,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(PackageDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "n.setName",
        "setName",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super.visit(n, arg);\n        // Change the package of the output\n        n.setName(outputPackage());\n    }",
      "line_number": 77,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "processSpecialNodeTypes",
      "signature": "private void processSpecialNodeTypes(Parameter node) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getNameAsString",
        "node.getNameAsString"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        processSpecialNodeTypes(node, node.getNameAsString());\n    }",
      "line_number": 97,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "processSpecialNodeTypes",
      "signature": "private void processSpecialNodeTypes(VariableDeclarator node) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getNameAsString",
        "node.getNameAsString"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        processSpecialNodeTypes(node, node.getNameAsString());\n    }",
      "line_number": 101,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "isCommentPresent",
      "signature": "protected boolean isCommentPresent(Node node, String wanted) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "wanted.equals",
        "isPresent",
        "maybeComment.get",
        "get",
        "trim",
        "node.getComment",
        "getComment",
        "getContent",
        "maybeComment.isPresent",
        "Comment",
        "comment.getContent",
        "equals"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        Optional<Comment> maybeComment = node.getComment();\n        if (maybeComment.isPresent()) {\n            Comment comment = maybeComment.get();\n            String content = comment.getContent().trim();\n            if (wanted.equals(content)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "line_number": 105,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "removeStaticFieldsAndInitialisers",
      "signature": "protected void removeStaticFieldsAndInitialisers(ClassOrInterfaceDeclaration node) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "contains",
        "getChildNodesByType",
        "staticModifier",
        "node.getFields",
        "getFields",
        "child.remove",
        "field.getModifiers",
        "Modifier.staticModifier",
        "field.remove",
        "getModifiers",
        "remove",
        "node.getChildNodesByType"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // Remove all the static initialisers\n        for (InitializerDeclaration child : node.getChildNodesByType(InitializerDeclaration.class)) {\n            child.remove();\n        }\n\n        // Remove all static fields\n        for (FieldDeclaration field : node.getFields()) {\n            if (field.getModifiers().contains(Modifier.staticModifier())) {\n                field.remove();\n            }\n        }\n    }",
      "line_number": 117,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "replaceParentClassesForAtomics",
      "signature": "protected void replaceParentClassesForAtomics(ClassOrInterfaceDeclaration n) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "parent.setName",
        "n.getExtendedTypes",
        "setName",
        "parent.getNameAsString",
        "getExtendedTypes",
        "getNameAsString"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "        for (ClassOrInterfaceType parent : n.getExtendedTypes()) {\n            String parentNameAsString = parent.getNameAsString();\n            switch (parentNameAsString) {\n                case \"AbstractQueue\":\n                    // ignore the JDK parent\n                    break;\n                case \"BaseLinkedQueue\":\n                    parent.setName(\"BaseLinked\" + queueClassNamePrefix() + \"Queue\");\n                    break;\n                case \"ConcurrentCircularArrayQueue\":\n                    parent.setName(\"AtomicReferenceArrayQueue\");\n                    break;\n                case \"ConcurrentSequencedCircularArrayQueue\":\n                    parent.setName(\"SequencedAtomicReferenceArrayQueue\");\n                    break;\n                default:\n                    // Padded super classes are to be renamed and thus so does the\n                    // class we must extend.\n                    parent.setName(translateQueueName(parentNameAsString));\n            }\n        }\n    }",
      "line_number": 194,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "atomic_operations",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "organiseImports",
      "signature": "public void organiseImports(CompilationUnit cu) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "addImport",
        "importDecls.add",
        "cu.getImports",
        "getImports",
        "add",
        "name.startsWith",
        "ImportDeclaration",
        "startsWith",
        "importDeclaration.getNameAsString",
        "cu.addImport",
        "ArrayList",
        "clear",
        "getNameAsString"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        List<ImportDeclaration> importDecls = new ArrayList<>();\n\n        // remove irrelevant imports\n        for (ImportDeclaration importDeclaration : cu.getImports()) {\n            String name = importDeclaration.getNameAsString();\n            if (name.startsWith(\"org.jctools.util.Unsafe\")) {\n                continue;\n            }\n\n            if (name.startsWith(\"org.jctools.queues.LinkedArrayQueueUtil\")) {\n                continue;\n            }\n\n            importDecls.add(importDeclaration);\n        }\n        cu.getImports().clear();\n        for (ImportDeclaration importDecl : importDecls) {\n            cu.addImport(importDecl);\n        }\n\n        cu.addImport(new ImportDeclaration(\"java.util.concurrent.atomic\", false, true));\n\n        cu.addImport(new ImportDeclaration(\"org.jctools.queues\", false, true));\n        cu.addImport(staticImportDeclaration(\"org.jctools.queues.atomic.AtomicQueueUtil\"));\n    }",
      "line_number": 224,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "fieldUpdaterLazySet",
      "signature": "protected BlockStmt fieldUpdaterLazySet(String fieldUpdaterFieldName, String newValueName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "body.addStatement",
        "ThisExpr",
        "BlockStmt",
        "ExpressionStmt",
        "addStatement",
        "NameExpr"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        BlockStmt body = new BlockStmt();\n        body.addStatement(new ExpressionStmt(\n                methodCallExpr(fieldUpdaterFieldName, \"lazySet\", new ThisExpr(), new NameExpr(newValueName))));\n        return body;\n    }",
      "line_number": 259,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "fieldAssignment",
      "signature": "protected BlockStmt fieldAssignment(String fieldName, String valueName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "body.addStatement",
        "AssignExpr",
        "BlockStmt",
        "ExpressionStmt",
        "addStatement",
        "NameExpr"
      ],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "        BlockStmt body = new BlockStmt();\n        body.addStatement(\n                new ExpressionStmt(new AssignExpr(new NameExpr(fieldName), new NameExpr(valueName), Operator.ASSIGN)));\n        return body;\n    }",
      "line_number": 289,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "synchronization",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "declareLongFieldUpdater",
      "signature": "protected FieldDeclaration declareLongFieldUpdater(String className, String variableName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "static",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        MethodCallExpr initializer = newAtomicLongFieldUpdater(className, variableName);\n\n        ClassOrInterfaceType type = simpleParametricType(\"AtomicLongFieldUpdater\", className);\n        return fieldDeclarationWithInitialiser(type, fieldUpdaterFieldName(variableName),\n                initializer, Keyword.PRIVATE, Keyword.STATIC, Keyword.FINAL);\n    }",
      "line_number": 313,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "atomic_operations",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "newAtomicLongFieldUpdater",
      "signature": "protected MethodCallExpr newAtomicLongFieldUpdater(String className, String variableName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong"
      ],
      "dependencies": [
        "ClassExpr",
        "StringLiteralExpr"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        return methodCallExpr(\"AtomicLongFieldUpdater\", \"newUpdater\", new ClassExpr(classType(className)),\n                new StringLiteralExpr(variableName));\n    }",
      "line_number": 321,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "atomic_operations",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "returnField",
      "signature": "protected BlockStmt returnField(String fieldName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "ReturnStmt",
        "body.addStatement",
        "BlockStmt",
        "addStatement"
      ],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "        BlockStmt body = new BlockStmt();\n        body.addStatement(new ReturnStmt(fieldName));\n        return body;\n    }",
      "line_number": 342,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "synchronization",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "isRefArray",
      "signature": "protected boolean isRefArray(Type in, String refClassName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "aType.getComponentType",
        "getComponentType"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (in instanceof ArrayType) {\n            ArrayType aType = (ArrayType) in;\n            return isRefType(aType.getComponentType(), refClassName);\n        }\n        return false;\n    }",
      "line_number": 348,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "data_structures",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "isRefType",
      "signature": "protected boolean isRefType(Type in, String className) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getNameAsString",
        "className.equals",
        "equals"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        // Does not check type parameters\n        if (in instanceof ClassOrInterfaceType) {\n            return (className.equals(((ClassOrInterfaceType) in).getNameAsString()));\n        }\n        return false;\n    }",
      "line_number": 356,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "buildGenerator",
      "signature": "private static <T> T buildGenerator(Class<? extends T> generatorClass, String fileName) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "T",
        "newInstance",
        "generatorClass.getDeclaredConstructor",
        "getDeclaredConstructor"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return generatorClass.getDeclaredConstructor(String.class).newInstance(fileName);\n    }",
      "line_number": 364,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "staticImportDeclaration",
      "signature": "ImportDeclaration staticImportDeclaration(String name) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "ImportDeclaration"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return new ImportDeclaration(name, true, true);\n    }",
      "line_number": 368,
      "repository": "JCTools/JCTools",
      "test_files": [
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
        "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java"
      ],
      "test_functions": [
        {
          "name": "test",
          "signature": "public static void test(OffHeapFixedMessageSizeRingBuffer rb) {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/AbstractOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        assertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n\t\t\n\t\tlong writeOffset = rb.writeAcquire();\n\t\tassertNotEquals(EOF, writeOffset);\n\t\tlong fieldOffset = writeOffset+MESSAGE_INDICATOR_SIZE;\n\t\tUNSAFE.putInt(fieldOffset,1);\n\t\tUNSAFE.putLong(fieldOffset+4,1);\n\t\t// blah blah, not writing the rest\n\t\t\n\t\trb.writeRelease(writeOffset);\n\t\tassertEquals(1, rb.size());\n\t\tassertTrue(!rb.isEmpty());\n\t\tlong readOffset = rb.readAcquire();\n\t\tfieldOffset = readOffset + MESSAGE_INDICATOR_SIZE;\n\t\tassertNotEquals(EOF, readOffset);\n\t\tassertEquals(writeOffset, readOffset);\n\t\tassertEquals(1, UNSAFE.getInt(fieldOffset));\n\t\tassertEquals(1L, UNSAFE.getLong(fieldOffset+4));\n\t\trb.readRelease(readOffset);\n\t\t\n\t\tassertEquals(0, rb.size());\n\t\tassertTrue(rb.isEmpty());\n\t\tassertEquals(EOF, rb.readAcquire());\n    }",
          "line_number": 26,
          "tested_class": "",
          "tested_methods": [
            "readAcquire",
            "readRelease",
            "getLong",
            "writeAcquire",
            "writeRelease",
            "putInt",
            "putLong",
            "getInt"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n\t\tSpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n\t\ttest(rb);\n\t}",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "test",
          "signature": "public void test() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscOffHeapFixedSizeRingBuffer rb = new MpscOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 22,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        },
        {
          "name": "testFFLamport",
          "signature": "public void testFFLamport() {",
          "file_path": "cloned_repositories/JCTools_JCTools/jctools-channels/src/test/java/org/jctools/channels/mpsc/MpscOffHeapFixedSizeRingBufferTest.java",
          "source_code": "        // TODO: Needs test for when referenceMessageSize > 0\n        MpscFFLamportOffHeapFixedSizeRingBuffer rb = new MpscFFLamportOffHeapFixedSizeRingBuffer(1024, 31, 0);\n        test(rb);\n    }",
          "line_number": 29,
          "tested_class": "",
          "tested_methods": [
            "test"
          ],
          "test_type": "unit"
        }
      ],
      "domain": "general",
      "class_name": "of",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ArrayType n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "getComponentType",
        "n.getComponentType",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ArrayType: \" + (extended ? n : n.getComponentType()));\n        super.visit(n, arg);\n    }",
      "line_number": 152,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(AssignExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "n.getValue",
        "n.getTarget",
        "getValue",
        "getTarget",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"AssignExpr: \" + (extended ? n : n.getTarget() + \" = \" + n.getValue()));\n        super.visit(n, arg);\n    }",
      "line_number": 164,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(BinaryExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "getLeft",
        "getOperator",
        "n.getLeft",
        "getRight",
        "n.getOperator",
        "n.getRight",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"BinaryExpr: \" + (extended ? n : n.getLeft() + \" \" + n.getOperator() + \" \" + n.getRight()));\n        super.visit(n, arg);\n    }",
      "line_number": 170,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(BlockComment n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "println",
        "n.getContent",
        "getContent",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        out.println(\"BlockComment: \" + (extended ? n : n.getContent()));\n        super.visit(n, arg);\n    }",
      "line_number": 176,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(BlockStmt n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "getStatements",
        "out.println",
        "size",
        "println",
        "n.getStatements",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        out.println(\"BlockStmt: \" + (extended ? n : n.getStatements().size() + \" statements\"));\n        super.visit(n, arg);\n    }",
      "line_number": 182,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(BooleanLiteralExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "n.getValue",
        "getValue",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"BooleanLiteralExpr: \" + (extended ? n : n.getValue()));\n        super.visit(n, arg);\n    }",
      "line_number": 188,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(CatchClause n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getParameter",
        "super.visit",
        "getParameter",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        out.println(\"CatchClause: \" + (extended ? n : n.getParameter()));\n        super.visit(n, arg);\n    }",
      "line_number": 206,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ClassExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "getType",
        "n.getType",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ClassExpr: \" + (extended ? n : n.getType()));\n        super.visit(n, arg);\n    }",
      "line_number": 218,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ClassOrInterfaceDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ClassOrInterfaceDeclaration: \" + (extended ? n : n.getNameAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 224,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ClassOrInterfaceType n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ClassOrInterfaceType: \" + (extended ? n : n.getNameAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 230,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ConditionalExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [
        "Condition"
      ],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "visit"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        out.println(\"ConditionalExpr: \" + (extended ? n : \"\"));\n        super.visit(n, arg);\n    }",
      "line_number": 242,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ConstructorDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "getDeclarationAsString",
        "n.getDeclarationAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ConstructorDeclaration: \" + (extended ? n : n.getDeclarationAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 248,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ExpressionStmt n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getExpression",
        "getExpression",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ExpressionStmt: \" + (extended ? n : n.getExpression()));\n        super.visit(n, arg);\n    }",
      "line_number": 302,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(FieldAccessExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"FieldAccessExpr: \" + (extended ? n : n.getNameAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 308,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ForStmt n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "map",
        "println",
        "Objects.toString",
        "getCompare",
        "getUpdate",
        "stream",
        "n.getUpdate",
        "getInitialization",
        "collect",
        "n.getCompare",
        "n.getInitialization",
        "joining",
        "Collectors.joining",
        "super.visit",
        "toString",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        // Collector<CharSequence, ?, String> joiner = Collectors.joining(\", \");\n        // out.println(\"ForStmt: \"\n        // + (extended ? n : n.getInitialization().stream().map(node ->\n        // Objects.toString(node)).collect(joiner)) + \"; \"\n        // + n.getCompare()\n        // + \"; \" + n.getUpdate().stream().map(node ->\n        // Objects.toString(node)).collect(joiner)\n        //\n        // );\n        super.visit(n, arg);\n    }",
      "line_number": 326,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(IfStmt n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [
        "Condition"
      ],
      "dependencies": [
        "getCondition",
        "out.println",
        "println",
        "super.visit",
        "n.getCondition",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        out.println(\"IfStmt: \" + (extended ? n : n.getCondition()));\n        super.visit(n, arg);\n    }",
      "line_number": 340,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ImportDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ImportDeclaration: \" + (extended ? n : n.getNameAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 346,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(InstanceOfExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "visit"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"InstanceOfExpr: \" + (extended ? n : \"\"));\n        super.visit(n, arg);\n    }",
      "line_number": 358,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(JavadocComment n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getContent",
        "getContent",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"JavadocComment: \" + (extended ? n : n.getContent()));\n        super.visit(n, arg);\n    }",
      "line_number": 376,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(LineComment n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getContent",
        "getContent",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"LineComment: \" + (extended ? n : n.getContent()));\n        super.visit(n, arg);\n    }",
      "line_number": 394,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(MarkerAnnotationExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"MarkerAnnotationExpr: \" + (extended ? n : n.getNameAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 412,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(MethodCallExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "getScope",
        "n.getNameAsString",
        "getNameAsString",
        "n.getScope",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"MethodCallExpr: \" + (extended ? n : n.getNameAsString() + \" \" + n.getScope()));\n        super.visit(n, arg);\n    }",
      "line_number": 424,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(MethodDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "getDeclarationAsString",
        "n.getDeclarationAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"MethodDeclaration: \" + (extended ? n : n.getDeclarationAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 430,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(Name n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getIdentifier",
        "getIdentifier",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        out.println(\"Name: \" + (extended ? n : n.getIdentifier()));\n        super.visit(n, arg);\n    }",
      "line_number": 478,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(NameExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"NameExpr: \" + (extended ? n : n.getNameAsString()));\n        super.visit(n, arg);\n    }",
      "line_number": 484,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(PrimitiveType n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "getType",
        "n.getType",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"PrimitiveType: \" + (extended ? n : n.getType()));\n        super.visit(n, arg);\n    }",
      "line_number": 526,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ReturnStmt n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getExpression",
        "getExpression",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ReturnStmt: \" + (extended ? n : n.getExpression()));\n        super.visit(n, arg);\n    }",
      "line_number": 532,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(SimpleName n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getIdentifier",
        "getIdentifier",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        out.println(\"SimpleName: \" + (extended ? n : n.getIdentifier()));\n        super.visit(n, arg);\n    }",
      "line_number": 538,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(SynchronizedStmt n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [
        "synchronized"
      ],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "visit"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 10,
      "source_code": "        out.println(\"SynchronizedStmt: \" + (extended ? n : \"\"));\n        super.visit(n, arg);\n    }",
      "line_number": 574,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ThrowStmt n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getExpression",
        "getExpression",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"ThrowStmt: \" + (extended ? n : n.getExpression()));\n        super.visit(n, arg);\n    }",
      "line_number": 586,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(UnaryExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "println",
        "n.getExpression",
        "getOperator",
        "getExpression",
        "n.getOperator",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"UnaryExpr: \" + (extended ? n : n.getOperator() + \" \" + n.getExpression()));\n        super.visit(n, arg);\n    }",
      "line_number": 610,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(VariableDeclarator n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "out.println",
        "super.visit",
        "println",
        "n.getInitializer",
        "orElse",
        "n.getNameAsString",
        "getNameAsString",
        "visit",
        "getType",
        "n.getType",
        "getInitializer"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        out.println(\"VariableDeclarator: \" + (extended ? n\n                : n.getNameAsString() + \" of type \" + n.getType() + \" init \" + n.getInitializer().orElse(null)));\n        super.visit(n, arg);\n\n    }",
      "line_number": 640,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/TraceVisitor.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "File",
        "TraceVisitor",
        "out.println",
        "println",
        "getResult",
        "get",
        "JavaParser",
        "parse",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        for (String file : args) {\n            System.out.println(\"Opening \" + file);\n            CompilationUnit cu = new JavaParser().parse(new File(file)).getResult().get();\n            new TraceVisitor(System.out, false).visit(cu, null);\n            System.out.println();\n            System.out.println();\n            System.out.println();\n        }\n    }",
      "line_number": 665,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TraceVisitor",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern"
      ],
      "complexity_score": 4,
      "source_code": "        runJCToolsGenerator(JavaParsingAtomicLinkedQueueGenerator.class, args);\n    }",
      "line_number": 30,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "JavaParsingAtomicLinkedQueueGenerator",
      "signature": "public JavaParsingAtomicLinkedQueueGenerator(String sourceFileName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        super(sourceFileName);\n        this.mpscLinkedQueueName = atomicQueueName();\n    }",
      "line_number": 34,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "constructor"
    },
    {
      "name": "visit",
      "signature": "public void visit(ConstructorDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "setModifier",
        "setName",
        "n.setName",
        "mpscLinkedQueueName.equals",
        "nameAsString.equals",
        "n.getNameAsString",
        "getNameAsString",
        "visit",
        "super.visit",
        "n.setModifier",
        "equals"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        super.visit(n, arg);\n        // Update the ctor to match the class name\n        String nameAsString = n.getNameAsString();\n        // Ignore internal class WeakIterator which we don't need to rename\n        if (nameAsString.equals(\"WeakIterator\"))\n            return;\n        n.setName(translateQueueName(nameAsString));\n        if (mpscLinkedQueueName.equals(nameAsString)) {\n            // Special case for MPSC because the Unsafe variant has a static factory method and a protected constructor.\n            n.setModifier(Keyword.PROTECTED, false);\n            n.setModifier(Keyword.PUBLIC, true);\n        }\n    }",
      "line_number": 40,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "atomicQueueName",
      "signature": "private String atomicQueueName() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        return \"MpscLinked\" + queueClassNamePrefix() + \"Queue\";\n    }",
      "line_number": 55,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ClassOrInterfaceDeclaration node, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "setComment",
        "node.getNameAsString",
        "node.getJavadocComment",
        "JavadocComment",
        "node.setJavadocComment",
        "getJavadocComment",
        "removeModifier",
        "getName",
        "getNameAsString",
        "node.getMethods",
        "visit",
        "equals",
        "method.remove",
        "node.removeModifier",
        "contains",
        "setJavadocComment",
        "orElse",
        "setName",
        "node.setComment",
        "mpscLinkedQueueName.equals",
        "getMethods",
        "getContent",
        "node.setName",
        "super.visit",
        "remove",
        "nameAsString.contains"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 19,
      "source_code": "        super.visit(node, arg);\n\n        replaceParentClassesForAtomics(node);\n\n        String nameAsString = node.getNameAsString();\n        if (nameAsString.contains(\"Queue\"))\n            node.setName(translateQueueName(nameAsString));\n        if (mpscLinkedQueueName.equals(nameAsString)) {\n            /*\n             * Special case for MPSC\n             */\n            node.removeModifier(Keyword.ABSTRACT);\n        }\n\n        if (isCommentPresent(node, GEN_DIRECTIVE_CLASS_CONTAINS_ORDERED_FIELD_ACCESSORS)) {\n            node.setComment(null);\n            removeStaticFieldsAndInitialisers(node);\n            patchAtomicFieldUpdaterAccessorMethods(node);\n        }\n\n        for (MethodDeclaration method : node.getMethods()) {\n            if (isCommentPresent(method, GEN_DIRECTIVE_METHOD_IGNORE)) {\n                method.remove();\n            }\n        }\n\n        node.setJavadocComment(formatMultilineJavadoc(0,\n                \"NOTE: This class was automatically generated by \"\n                        + getClass().getName(),\n                \"which can found in the jctools-build module. The original source file is \" + sourceFileName + \".\")\n                + node.getJavadocComment().orElse(new JavadocComment(\"\")).getContent());\n    }",
      "line_number": 60,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(CastExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "super.visit",
        "n.setType",
        "setType",
        "getType",
        "n.getType",
        "visit"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        super.visit(n, arg);\n\n        if (isRefArray(n.getType(), \"E\")) {\n            n.setType(atomicRefArrayType((ArrayType) n.getType()));\n        }\n    }",
      "line_number": 95,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(MethodDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getNameAsString",
        "super.visit",
        "n.getNameAsString",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super.visit(n, arg);\n        // Replace the return type of a method with altered types\n        processSpecialNodeTypes(n, n.getNameAsString());\n    }",
      "line_number": 104,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ObjectCreationExpr n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "super.visit",
        "n.setType",
        "setType",
        "getType",
        "n.getType",
        "visit"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        super.visit(n, arg);\n        Type type = n.getType();\n        if (isRefType(type, \"LinkedQueueNode\")) {\n            n.setType(simpleParametricType(\"LinkedQueueAtomicNode\", \"E\"));\n        }\n    }",
      "line_number": 111,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "processSpecialNodeTypes",
      "signature": "void processSpecialNodeTypes(NodeWithType<?, Type> node, String name) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longType",
        "node.getType",
        "node.setType",
        "setType",
        "PrimitiveType.longType",
        "getType",
        "PrimitiveType.intType",
        "intType",
        "equals"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        Type type = node.getType();\n        if (node instanceof MethodDeclaration && (\"newBufferAndOffset\".equals(name) || \"nextArrayOffset\".equals(name))) {\n            node.setType(PrimitiveType.intType());\n        } else if (PrimitiveType.longType().equals(type)) {\n            switch(name) {\n            case \"offset\":\n            case \"offsetInNew\":\n            case \"offsetInOld\":\n            case \"lookAheadElementOffset\":\n                node.setType(PrimitiveType.intType());\n            }\n        } else if (isRefType(type, \"LinkedQueueNode\")) {\n            node.setType(simpleParametricType(\"LinkedQueueAtomicNode\", \"E\"));\n        } else if (isRefArray(type, \"E\")) {\n            node.setType(atomicRefArrayType((ArrayType) type));\n        }\n    }",
      "line_number": 141,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "patchAtomicFieldUpdaterAccessorMethods",
      "signature": "private void patchAtomicFieldUpdaterAccessorMethods(ClassOrInterfaceDeclaration n) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "static",
        "final",
        "getAndSet"
      ],
      "dependencies": [
        "longType",
        "n.getNameAsString",
        "method.setBody",
        "add",
        "getFields",
        "setType",
        "n.getMethods",
        "PrimitiveType.longType",
        "getModifiers",
        "getNameAsString",
        "n.addMethod",
        "field.getVariables",
        "equals",
        "addMethod",
        "getMembers",
        "n.getFields",
        "field.addModifier",
        "n.getMembers",
        "Modifier.staticModifier",
        "field.getModifiers",
        "setBody",
        "method.addParameter",
        "getType",
        "method.setType",
        "addModifier",
        "contains",
        "staticModifier",
        "getMethods",
        "variable.getNameAsString",
        "addParameter",
        "variable.getType",
        "getVariables"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 36,
      "source_code": "        String className = n.getNameAsString();\n\n        for (FieldDeclaration field : n.getFields()) {\n            if (field.getModifiers().contains(Modifier.staticModifier())) {\n                // Ignore statics\n                continue;\n            }\n\n            boolean usesFieldUpdater = false;\n            for (VariableDeclarator variable : field.getVariables()) {\n                String variableName = variable.getNameAsString();\n                String methodNameSuffix = capitalise(variableName);\n\n                for (MethodDeclaration method : n.getMethods()) {\n                    usesFieldUpdater |= patchAtomicFieldUpdaterAccessorMethod(variableName, method, methodNameSuffix);\n                }\n\n                if (\"producerNode\".equals(variableName)) {\n                    usesFieldUpdater = true;\n                    String fieldUpdaterFieldName = fieldUpdaterFieldName(variableName);\n\n                    MethodDeclaration method = n.addMethod(\"xchgProducerNode\", Keyword.PROTECTED, Keyword.FINAL);\n                    method.setType(simpleParametricType(\"LinkedQueueAtomicNode\", \"E\"));\n                    method.addParameter(simpleParametricType(\"LinkedQueueAtomicNode\", \"E\"), \"newValue\");\n                    method.setBody(fieldUpdaterGetAndSet(fieldUpdaterFieldName, \"newValue\"));\n                }\n\n                if (usesFieldUpdater) {\n                    if (PrimitiveType.longType().equals(variable.getType())) {\n                        n.getMembers().add(0, declareLongFieldUpdater(className, variableName));\n                    } else {\n                        n.getMembers().add(0, declareRefFieldUpdater(className, variableName));\n                    }\n                }\n            }\n\n            if (usesFieldUpdater) {\n                field.addModifier(Keyword.VOLATILE);\n            }\n        }\n    }",
      "line_number": 169,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "fieldUpdaterGetAndSet",
      "signature": "private BlockStmt fieldUpdaterGetAndSet(String fieldUpdaterFieldName, String newValueName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "getAndSet"
      ],
      "dependencies": [
        "body.addStatement",
        "ThisExpr",
        "BlockStmt",
        "ReturnStmt",
        "addStatement",
        "NameExpr"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        BlockStmt body = new BlockStmt();\n        body.addStatement(new ReturnStmt(\n                methodCallExpr(fieldUpdaterFieldName, \"getAndSet\", new ThisExpr(), new NameExpr(newValueName))));\n        return body;\n    }",
      "line_number": 216,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "declareRefFieldUpdater",
      "signature": "private FieldDeclaration declareRefFieldUpdater(String className, String variableName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "AtomicReference",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        MethodCallExpr initializer = newAtomicRefFieldUpdater(className, variableName);\n\n        ClassOrInterfaceType type = simpleParametricType(\"AtomicReferenceFieldUpdater\", className,\n                \"LinkedQueueAtomicNode\");\n        return fieldDeclarationWithInitialiser(type, fieldUpdaterFieldName(variableName),\n                initializer, Keyword.PRIVATE, Keyword.STATIC, Keyword.FINAL);\n    }",
      "line_number": 227,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "newAtomicRefFieldUpdater",
      "signature": "private MethodCallExpr newAtomicRefFieldUpdater(String className, String variableName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReference"
      ],
      "dependencies": [
        "ClassExpr",
        "StringLiteralExpr"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 12,
      "source_code": "        return methodCallExpr(\"AtomicReferenceFieldUpdater\", \"newUpdater\", new ClassExpr(classType(className)),\n                new ClassExpr(classType(\"LinkedQueueAtomicNode\")), new StringLiteralExpr(variableName));\n    }",
      "line_number": 236,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "atomicRefArrayType",
      "signature": "private ClassOrInterfaceType atomicRefArrayType(ArrayType in) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "in.getComponentType",
        "setTypeArguments",
        "getComponentType",
        "ClassOrInterfaceType",
        "out.setTypeArguments"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        ClassOrInterfaceType out = new ClassOrInterfaceType(null, \"AtomicReferenceArray\");\n        out.setTypeArguments(in.getComponentType());\n        return out;\n    }",
      "line_number": 241,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern"
      ],
      "complexity_score": 4,
      "source_code": "        runJCToolsGenerator(JavaParsingAtomicArrayQueueGenerator.class, args);\n    }",
      "line_number": 30,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "JavaParsingAtomicArrayQueueGenerator",
      "signature": "public JavaParsingAtomicArrayQueueGenerator(String sourceFileName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(sourceFileName);\n    }",
      "line_number": 34,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "constructor"
    },
    {
      "name": "visit",
      "signature": "public void visit(ConstructorDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "setName",
        "n.setName",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super.visit(n, arg);\n        // Update the ctor to match the class name\n        n.setName(translateQueueName(n.getNameAsString()));\n    }",
      "line_number": 39,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ClassOrInterfaceDeclaration node, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "setComment",
        "isEmpty",
        "node.getNameAsString",
        "node.getJavadocComment",
        "JavadocComment",
        "intType",
        "PrimitiveType.intType",
        "node.setJavadocComment",
        "getMethodsByName",
        "getJavadocComment",
        "node.getMethodsByName",
        "node.addMethod",
        "getName",
        "getNameAsString",
        "node.getMethods",
        "visit",
        "addMethod",
        "method.remove",
        "Parameter",
        "setJavadocComment",
        "orElse",
        "setName",
        "node.setComment",
        "getMethods",
        "getContent",
        "node.setName",
        "super.visit",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        super.visit(node, arg);\n\n        replaceParentClassesForAtomics(node);\n\n        node.setName(translateQueueName(node.getNameAsString()));\n\n        if (isCommentPresent(node, GEN_DIRECTIVE_CLASS_CONTAINS_ORDERED_FIELD_ACCESSORS)) {\n            node.setComment(null);\n            removeStaticFieldsAndInitialisers(node);\n            patchAtomicFieldUpdaterAccessorMethods(node);\n        }\n\n        for (MethodDeclaration method : node.getMethods()) {\n            if (isCommentPresent(method, GEN_DIRECTIVE_METHOD_IGNORE)) {\n                method.remove();\n            }\n        }\n\n        if (!node.getMethodsByName(\"failFastOffer\").isEmpty()) {\n            MethodDeclaration deprecatedMethodRedirect = node.addMethod(\"weakOffer\", Keyword.PUBLIC);\n            patchMethodAsDeprecatedRedirector(deprecatedMethodRedirect, \"failFastOffer\", PrimitiveType.intType(),\n                    new Parameter(classType(\"E\"), \"e\"));\n        }\n\n        node.setJavadocComment(formatMultilineJavadoc(0,\n                \"NOTE: This class was automatically generated by \"\n                        + getClass().getName(),\n                \"which can found in the jctools-build module. The original source file is \" + sourceFileName + \".\")\n                + node.getJavadocComment().orElse(new JavadocComment(\"\")).getContent());\n    }",
      "line_number": 46,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "processSpecialNodeTypes",
      "signature": "void processSpecialNodeTypes(NodeWithType<?, Type> node, String name) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "longType",
        "node.getType",
        "node.setType",
        "setType",
        "PrimitiveType.longType",
        "getType",
        "PrimitiveType.intType",
        "intType",
        "equals"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        Type type = node.getType();\n        if (\"buffer\".equals(name) && isRefArray(type, \"E\")) {\n            node.setType(atomicRefArrayType((ArrayType) type));\n        } else if (\"sBuffer\".equals(name) && isLongArray(type)) {\n            node.setType(atomicLongArrayType());\n        } else if (PrimitiveType.longType().equals(type)) {\n            switch(name) {\n            case \"mask\":\n            case \"offset\":\n            case \"seqOffset\":\n            case \"lookAheadSeqOffset\":\n            case \"lookAheadElementOffset\":\n                node.setType(PrimitiveType.intType());\n            }\n        }\n    }",
      "line_number": 96,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "patchAtomicFieldUpdaterAccessorMethods",
      "signature": "private void patchAtomicFieldUpdaterAccessorMethods(ClassOrInterfaceDeclaration n) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "static"
      ],
      "dependencies": [
        "n.getNameAsString",
        "add",
        "getFields",
        "n.getMethods",
        "getModifiers",
        "getNameAsString",
        "field.getVariables",
        "getMembers",
        "n.getFields",
        "field.addModifier",
        "n.getMembers",
        "Modifier.staticModifier",
        "field.getModifiers",
        "addModifier",
        "contains",
        "staticModifier",
        "getMethods",
        "variable.getNameAsString",
        "getVariables"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "singleton_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "        String className = n.getNameAsString();\n\n        for (FieldDeclaration field : n.getFields()) {\n            if (field.getModifiers().contains(Modifier.staticModifier())) {\n                // Ignore statics\n                continue;\n            }\n\n            boolean usesFieldUpdater = false;\n            for (VariableDeclarator variable : field.getVariables()) {\n                String variableName = variable.getNameAsString();\n                String methodNameSuffix = capitalise(variableName);\n\n                for (MethodDeclaration method : n.getMethods()) {\n                    usesFieldUpdater |= patchAtomicFieldUpdaterAccessorMethod(variableName, method, methodNameSuffix);\n                }\n\n                if (usesFieldUpdater) {\n                    n.getMembers().add(0, declareLongFieldUpdater(className, variableName));\n                }\n            }\n\n            if (usesFieldUpdater) {\n                field.addModifier(Keyword.VOLATILE);\n            }\n        }\n    }",
      "line_number": 151,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "isLongArray",
      "signature": "private boolean isLongArray(Type in) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "longType",
        "aType.getComponentType",
        "getComponentType",
        "PrimitiveType.longType",
        "equals"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (in instanceof ArrayType) {\n            ArrayType aType = (ArrayType) in;\n            return PrimitiveType.longType().equals(aType.getComponentType());\n        }\n        return false;\n    }",
      "line_number": 180,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "atomicRefArrayType",
      "signature": "private ClassOrInterfaceType atomicRefArrayType(ArrayType in) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "in.getComponentType",
        "setTypeArguments",
        "getComponentType",
        "ClassOrInterfaceType",
        "out.setTypeArguments"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        ClassOrInterfaceType out = new ClassOrInterfaceType(null, \"AtomicReferenceArray\");\n        out.setTypeArguments(in.getComponentType());\n        return out;\n    }",
      "line_number": 188,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "atomicLongArrayType",
      "signature": "private ClassOrInterfaceType atomicLongArrayType() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "ClassOrInterfaceType"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        return new ClassOrInterfaceType(null, \"AtomicLongArray\");\n    }",
      "line_number": 194,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/unpadded/JavaParsingUnpaddedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        runJCToolsGenerator(JavaParsingUnpaddedQueueGenerator.class, args);\n    }",
      "line_number": 27,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingUnpaddedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(PackageDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/unpadded/JavaParsingUnpaddedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "n.setName",
        "setName",
        "super.visit",
        "visit"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super.visit(n, arg);\n        // Change the package of the output\n        n.setName(\"org.jctools.queues.unpadded\");\n    }",
      "line_number": 61,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingUnpaddedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ClassOrInterfaceDeclaration node, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/unpadded/JavaParsingUnpaddedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "node.setJavadocComment",
        "this.getClass",
        "contains",
        "setJavadocComment",
        "getJavadocComment",
        "orElse",
        "nameAsString.contains",
        "setName",
        "getName",
        "JavadocComment",
        "node.setName",
        "getContent",
        "node.getNameAsString",
        "node.getJavadocComment",
        "getNameAsString",
        "super.visit",
        "getClass",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        super.visit(node, arg);\n        String nameAsString = node.getNameAsString();\n        if (!nameAsString.contains(\"Queue\"))\n            return;\n        // fixup inheritance\n        replaceParentClasses(node);\n        // fixup name\n        node.setName(translateQueueName(nameAsString));\n\n        node.setJavadocComment(formatMultilineJavadoc(0,\n            \"NOTE: This class was automatically generated by \"\n                + this.getClass().getName(),\n            \"which can found in the jctools-build module. The original source file is \" + sourceFileName + \".\")\n            + node.getJavadocComment().orElse(new JavadocComment(\"\")).getContent());\n\n        removePaddingFields(node);\n    }",
      "line_number": 68,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingUnpaddedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "visit",
      "signature": "public void visit(ConstructorDeclaration n, Void arg) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/unpadded/JavaParsingUnpaddedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "setName",
        "n.setName",
        "n.getNameAsString",
        "getNameAsString",
        "super.visit",
        "nameAsString.contains",
        "visit"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        super.visit(n, arg);\n        // Update the ctor to match the class name\n        String nameAsString = n.getNameAsString();\n        if (nameAsString.contains(\"Queue\"))\n            n.setName(translateQueueName(nameAsString));\n    }",
      "line_number": 106,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingUnpaddedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "replaceParentClasses",
      "signature": "protected void replaceParentClasses(ClassOrInterfaceDeclaration n) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/unpadded/JavaParsingUnpaddedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "parent.setName",
        "n.getExtendedTypes",
        "setName",
        "parent.getNameAsString",
        "getExtendedTypes",
        "getNameAsString"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        for (ClassOrInterfaceType parent : n.getExtendedTypes()) {\n            String parentNameAsString = parent.getNameAsString();\n            switch (parentNameAsString) {\n                case \"AbstractQueue\":\n                    // ignore the JDK parent\n                    break;\n                default:\n                    // Padded super classes are to be renamed and thus so does the\n                    // class we must extend.\n                    parent.setName(translateQueueName(parentNameAsString));\n            }\n        }\n    }",
      "line_number": 119,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingUnpaddedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern"
      ],
      "complexity_score": 4,
      "source_code": "        runJCToolsGenerator(JavaParsingAtomicUnpaddedLinkedQueueGenerator.class, args);\n    }",
      "line_number": 13,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "JavaParsingAtomicUnpaddedLinkedQueueGenerator",
      "signature": "public JavaParsingAtomicUnpaddedLinkedQueueGenerator(String sourceFileName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(sourceFileName);\n    }",
      "line_number": 17,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedLinkedQueueGenerator",
      "method_type": "constructor"
    },
    {
      "name": "organiseImports",
      "signature": "public void organiseImports(CompilationUnit cu) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "addImport",
        "ImportDeclaration",
        "organiseImports",
        "cu.addImport",
        "super.organiseImports"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        super.organiseImports(cu);\n        cu.addImport(new ImportDeclaration(\"org.jctools.queues.atomic.LinkedQueueAtomicNode\",\n                false, false));\n    }",
      "line_number": 28,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "outputPackage",
      "signature": "protected String outputPackage() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "producer_consumer"
      ],
      "complexity_score": 4,
      "source_code": "        return \"org.jctools.queues.atomic.unpadded\";\n    }",
      "line_number": 41,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "JavaParsingAtomicUnpaddedLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "queueClassNamePrefix",
      "signature": "protected String queueClassNamePrefix() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedLinkedQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        return \"AtomicUnpadded\";\n    }",
      "line_number": 46,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedLinkedQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) throws Exception {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern"
      ],
      "complexity_score": 4,
      "source_code": "        runJCToolsGenerator(JavaParsingAtomicUnpaddedArrayQueueGenerator.class, args);\n    }",
      "line_number": 13,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "JavaParsingAtomicUnpaddedArrayQueueGenerator",
      "signature": "public JavaParsingAtomicUnpaddedArrayQueueGenerator(String sourceFileName) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        super(sourceFileName);\n    }",
      "line_number": 17,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedArrayQueueGenerator",
      "method_type": "constructor"
    },
    {
      "name": "organiseImports",
      "signature": "public void organiseImports(CompilationUnit cu) {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "AtomicReference"
      ],
      "dependencies": [
        "addImport",
        "ImportDeclaration",
        "organiseImports",
        "cu.addImport",
        "super.organiseImports"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 16,
      "source_code": "        super.organiseImports(cu);\n        cu.addImport(new ImportDeclaration(\"org.jctools.queues.atomic.AtomicReferenceArrayQueue\",\n                    false, false));\n        cu.addImport(new ImportDeclaration(\"org.jctools.queues.atomic.SequencedAtomicReferenceArrayQueue\",\n                    false, false));\n    }",
      "line_number": 28,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "outputPackage",
      "signature": "protected String outputPackage() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "producer_consumer"
      ],
      "complexity_score": 4,
      "source_code": "        return \"org.jctools.queues.atomic.unpadded\";\n    }",
      "line_number": 43,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "JavaParsingAtomicUnpaddedArrayQueueGenerator",
      "method_type": "method"
    },
    {
      "name": "queueClassNamePrefix",
      "signature": "protected String queueClassNamePrefix() {",
      "file_path": "cloned_repositories/JCTools_JCTools/jctools-build/src/main/java/org/jctools/queues/atomic/unpadded/JavaParsingAtomicUnpaddedArrayQueueGenerator.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        return \"AtomicUnpadded\";\n    }",
      "line_number": 48,
      "repository": "JCTools/JCTools",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "JavaParsingAtomicUnpaddedArrayQueueGenerator",
      "method_type": "method"
    }
  ]
}