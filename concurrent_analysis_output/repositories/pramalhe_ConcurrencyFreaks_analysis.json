{
  "repository": "pramalhe/ConcurrencyFreaks",
  "analysis_date": "2025-06-09",
  "total_functions": 737,
  "functions_with_tests": 0,
  "test_coverage_percentage": 0.0,
  "total_test_functions": 0,
  "functions_by_domain": {
    "data_structures": 291,
    "synchronization": 191,
    "atomic_operations": 129,
    "general": 79,
    "thread_management": 28,
    "producer_consumer": 13,
    "memory_management": 6
  },
  "functions_by_complexity": {
    "low": 480,
    "medium": 148,
    "high": 69,
    "very_high": 40
  },
  "functions_by_type": {
    "method": 686,
    "constructor": 51
  },
  "test_type_distribution": {},
  "top_sync_primitives": {
    "final": 247,
    "Lock": 231,
    "lock": 231,
    "Thread": 151,
    "unlock": 83,
    "StampedLock": 73,
    "compareAndSet": 49,
    "tryLock": 45,
    "AtomicInteger": 44,
    "wait": 44
  },
  "concurrency_patterns": {
    "thread_local_storage": 447,
    "immutable_object": 247,
    "future_pattern": 229,
    "double_checked_locking": 158,
    "singleton_pattern": 129,
    "compare_and_swap": 102,
    "reader_writer_lock": 88,
    "producer_consumer": 47,
    "lock_free_algorithm": 39
  },
  "functions": [
    {
      "name": "checkedByteOffset",
      "signature": "private long checkedByteOffset(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "IndexOutOfBoundsException"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        if (i < 0 || i >= array.length)\n            throw new IndexOutOfBoundsException(\"index \" + i);\n\n        return byteOffset(i);\n    }",
      "line_number": 64,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "byteOffset",
      "signature": "private static long byteOffset(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ((long) i << shift) + base;\n    }",
      "line_number": 71,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "AtomicIntegerArray",
      "signature": "public AtomicIntegerArray(int length) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "AtomicIntegerArray",
        "AtomicInteger"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "        array = new int[length];\n    }",
      "line_number": 81,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "constructor"
    },
    {
      "name": "AtomicIntegerArray",
      "signature": "public AtomicIntegerArray(int[] array) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicIntegerArray",
        "AtomicInteger"
      ],
      "dependencies": [
        "clone",
        "array.clone"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 4,
      "source_code": "        // Visibility guaranteed by final field guarantees\n        this.array = array.clone();\n    }",
      "line_number": 92,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "constructor"
    },
    {
      "name": "length",
      "signature": "public final int length() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return array.length;\n    }",
      "line_number": 102,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public final int get(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getRaw(byteOffset(i));\n    }",
      "line_number": 112,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "getRaw",
      "signature": "private int getRaw(long offset) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "getIntVolatile",
        "unsafe.getIntVolatile"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return unsafe.getIntVolatile(array, offset);\n    }",
      "line_number": 116,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "set",
      "signature": "public final void set(int i, int newValue) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "putIntVolatile",
        "unsafe.putIntVolatile"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);\n    }",
      "line_number": 126,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "lazySet",
      "signature": "public final void lazySet(int i, int newValue) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "unsafe.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);\n    }",
      "line_number": 137,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "getAndSet",
      "signature": "public final int getAndSet(int i, int newValue) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "getAndSet"
      ],
      "dependencies": [
        "unsafe.getAndSetInt",
        "getAndSetInt"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return unsafe.getAndSetInt(array, checkedByteOffset(i), newValue);\n    }",
      "line_number": 149,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "compareAndSet",
      "signature": "public final boolean compareAndSet(int i, int expect, int update) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return compareAndSetRaw(checkedByteOffset(i), expect, update);\n    }",
      "line_number": 163,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "compareAndSetRaw",
      "signature": "private boolean compareAndSetRaw(long offset, int expect, int update) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "unsafe.compareAndSwapInt",
        "compareAndSwapInt"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return unsafe.compareAndSwapInt(array, offset, expect, update);\n    }",
      "line_number": 167,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "weakCompareAndSet",
      "signature": "public final boolean weakCompareAndSet(int i, int expect, int update) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "compareAndSet",
        "weakCompareAndSet"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return compareAndSet(i, expect, update);\n    }",
      "line_number": 184,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "getAndIncrement",
      "signature": "public final int getAndIncrement(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement",
        "getAndAdd",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAdd(i, 1);\n    }",
      "line_number": 194,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "getAndDecrement",
      "signature": "public final int getAndDecrement(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd",
        "final",
        "getAndDecrement"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAdd(i, -1);\n    }",
      "line_number": 204,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "getAndAdd",
      "signature": "public final int getAndAdd(int i, int delta) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd",
        "final"
      ],
      "dependencies": [
        "getAndAddInt",
        "unsafe.getAndAddInt"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return unsafe.getAndAddInt(array, checkedByteOffset(i), delta);\n    }",
      "line_number": 215,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "incrementAndGet",
      "signature": "public final int incrementAndGet(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd",
        "incrementAndGet",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAdd(i, 1) + 1;\n    }",
      "line_number": 225,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "decrementAndGet",
      "signature": "public final int decrementAndGet(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "decrementAndGet",
        "getAndAdd",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAdd(i, -1) - 1;\n    }",
      "line_number": 235,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "addAndGet",
      "signature": "public final int addAndGet(int i, int delta) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "addAndGet",
        "getAndAdd",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getAndAdd(i, delta) + delta;\n    }",
      "line_number": 246,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "getAndUpdate",
      "signature": "public final int getAndUpdate(int i, IntUnaryOperator updateFunction) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "updateFunction.applyAsInt",
        "applyAsInt"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long offset = checkedByteOffset(i);\n        int prev, next;\n        do {\n            prev = getRaw(offset);\n            next = updateFunction.applyAsInt(prev);\n        } while (!compareAndSetRaw(offset, prev, next));\n        return prev;\n    }",
      "line_number": 262,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "updateAndGet",
      "signature": "public final int updateAndGet(int i, IntUnaryOperator updateFunction) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "updateFunction.applyAsInt",
        "applyAsInt"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long offset = checkedByteOffset(i);\n        int prev, next;\n        do {\n            prev = getRaw(offset);\n            next = updateFunction.applyAsInt(prev);\n        } while (!compareAndSetRaw(offset, prev, next));\n        return next;\n    }",
      "line_number": 283,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/AtomicIntegerArray.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "StringBuilder",
        "toString",
        "b.append",
        "append"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        int iMax = array.length - 1;\n        if (iMax == -1)\n            return \"[]\";\n\n        StringBuilder b = new StringBuilder();\n        b.append('[');\n        for (int i = 0; ; i++) {\n            b.append(getRaw(byteOffset(i)));\n            if (i == iMax)\n                return b.append(']').toString();\n            b.append(',').append(' ');\n        }\n    }",
      "line_number": 349,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AtomicIntegerArray",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public Cell add(long x) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderExt.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "a.get",
        "a.compareAndSet",
        "get",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        Cell[] as; long b, v; int m; Cell a = null;\n        if ((as = cells) != null || !casBase(b = base, b + x)) {\n            boolean uncontended = true;\n            if (as == null || (m = as.length - 1) < 0 ||\n                (a = as[getProbe() & m]) == null ||\n                !(uncontended = a.compareAndSet(v = a.get(), v + x)))\n                a = longAccumulate(x, null, uncontended);\n        }\n        return a;\n    }",
      "line_number": 84,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "decrementBase",
      "signature": "public long decrementBase(long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderExt.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getandAddBase(val);\n    }",
      "line_number": 109,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderExt.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "a.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        Cell[] as = cells; Cell a;\n        long sum = base;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null)\n                    sum += a.get();\n            }\n        }\n        return sum;\n    }",
      "line_number": 121,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "reset",
      "signature": "public void reset() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderExt.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "a.set",
        "set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        Cell[] as = cells; Cell a;\n        base = 0L;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null)\n                    a.set(0L);\n            }\n        }\n    }",
      "line_number": 140,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "sumThenReset",
      "signature": "public long sumThenReset() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderExt.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "a.set",
        "get",
        "a.get",
        "set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        Cell[] as = cells; Cell a;\n        long sum = base;\n        base = 0L;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null) {\n                    sum += a.get();\n                    a.set(0L);\n                }\n            }\n        }\n        return sum;\n    }",
      "line_number": 161,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "sumThenResetCAS",
      "signature": "public long sumThenResetCAS() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderExt.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "a.get",
        "a.compareAndSet",
        "get",
        "compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        Cell[] as = cells; Cell a;\n        long sum = 0;\n        while (true) {\n            final long tsum = base;\n            if (casBase(tsum, 0L)) {\n                sum += tsum;\n                break;\n            }\n        }\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null) {\n                    while (true) {\n                        final long tsum = a.get();\n                        if (a.compareAndSet(tsum, 0L)) {\n                            sum += tsum;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return sum;\n    }",
      "line_number": 176,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "cas",
      "signature": "final boolean cas(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64CVS.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n        }",
      "line_number": 95,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "getRelaxValue",
      "signature": "final long getRelaxValue() { return UNSAFE.getLong(this, valueOffset); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64CVS.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 98,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "casBase",
      "signature": "final boolean casBase(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64CVS.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);\n    }",
      "line_number": 145,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "casCellsBusy",
      "signature": "final boolean casCellsBusy() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64CVS.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapInt",
        "compareAndSwapInt"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapInt(this, CELLSBUSY, 0, 1);\n    }",
      "line_number": 152,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "getProbe",
      "signature": "static final int getProbe() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64CVS.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getInt",
        "getInt",
        "currentThread",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        return UNSAFE.getInt(Thread.currentThread(), PROBE);\n    }",
      "line_number": 160,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "advanceProbe",
      "signature": "static final int advanceProbe(int probe) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64CVS.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "UNSAFE.putInt",
        "putInt",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        probe ^= probe << 13;   // xorshift\n        probe ^= probe >>> 17;\n        probe ^= probe << 5;\n        UNSAFE.putInt(Thread.currentThread(), PROBE, probe);\n        return probe;\n    }",
      "line_number": 169,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public void add(long x) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderRelax.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "cas",
        "a.cas"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        Cell[] as; long b, v; int m; Cell a;\n        if ((as = cells) != null || !casBase(b = base, b + x)) {\n            boolean uncontended = true;\n            if (as == null || (m = as.length - 1) < 0 ||\n                (a = as[getProbe() & m]) == null ||\n                !(uncontended = a.cas(v = a.value, v + x)))\n                longAccumulate(x, null, uncontended);\n        }\n    }",
      "line_number": 69,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderRelax.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.loadFence",
        "loadFence"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 10,
      "source_code": "        Cell[] as = cells; Cell a;\n        long sum = base;  // 'base' is volatile, this is the starting volatile load\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null)\n                    sum += a.value;\n            }\n            UNSAFE.loadFence();\n        }\n        return sum;\n    }",
      "line_number": 103,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "reset",
      "signature": "public void reset() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderRelax.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "putLongVolatile",
        "UNSAFE.putLongVolatile"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        Cell[] as = cells; Cell a;\n        base = 0L;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null)\n                    UNSAFE.putLongVolatile(a, Cell.valueOffset, 0L);\n            }\n        }\n    }",
      "line_number": 123,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "sumThenReset",
      "signature": "public long sumThenReset() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderRelax.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        Cell[] as = cells; Cell a;\n        long sum = base;\n        base = 0L;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null) {\n                    sum += a.value;\n                    a.value = 0L;\n                }\n            }\n        }\n        return sum;\n    }",
      "line_number": 144,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "getCellsLength",
      "signature": "public int getCellsLength() { return cells == null ? 0 : cells.length; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderCVS.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 50,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public void add(long x) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderCVS.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "cas",
        "a.cas"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        Cell[] as; long b, v; int m; Cell a;\n        if ((as = cells) != null || !casBase(b = base, b + x)) {\n            boolean uncontended = true;\n            if (as == null || (m = as.length - 1) < 0 ||\n                (a = as[getProbe() & m]) == null ||\n                !(uncontended = a.cas(v = a.value, v + x)))\n                longAccumulate(x, null, uncontended);\n        }\n    }",
      "line_number": 57,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderCVS.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 4,
      "source_code": "        Cell[] as = cells; Cell a;\n        long sum = base;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null)\n                    sum += a.value;\n            }\n        }\n        return sum;\n    }",
      "line_number": 91,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "reset",
      "signature": "public void reset() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderCVS.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        Cell[] as = cells; Cell a;\n        base = 0L;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null)\n                    a.value = 0L;\n            }\n        }\n    }",
      "line_number": 110,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "sumThenReset",
      "signature": "public long sumThenReset() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/LongAdderCVS.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        Cell[] as = cells; Cell a;\n        long sum = base;\n        base = 0L;\n        if (as != null) {\n            for (int i = 0; i < as.length; ++i) {\n                if ((a = as[i]) != null) {\n                    sum += a.value;\n                    a.value = 0L;\n                }\n            }\n        }\n        return sum;\n    }",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "getRelaxedValue",
      "signature": "long getRelaxedValue() { return UNSAFE.getLong(this, VALUEOFFSET); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Ext.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getLong",
        "UNSAFE.getLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 125,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "loadFence",
      "signature": "static void loadFence() { UNSAFE.loadFence(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Ext.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "UNSAFE.loadFence",
        "loadFence"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 126,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "casBase",
      "signature": "final boolean casBase(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Ext.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);\n    }",
      "line_number": 157,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "getandAddBase",
      "signature": "public final long getandAddBase(long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Ext.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd",
        "final"
      ],
      "dependencies": [
        "getAndAddLong",
        "UNSAFE.getAndAddLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.getAndAddLong(this, BASE, val);\n    }",
      "line_number": 164,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "casCellsBusy",
      "signature": "final boolean casCellsBusy() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Ext.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapInt",
        "compareAndSwapInt"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapInt(this, CELLSBUSY, 0, 1);\n    }",
      "line_number": 171,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "getProbe",
      "signature": "static final int getProbe() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Ext.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getInt",
        "getInt",
        "currentThread",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        return UNSAFE.getInt(Thread.currentThread(), PROBE);\n    }",
      "line_number": 179,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "advanceProbe",
      "signature": "static final int advanceProbe(int probe) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Ext.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "UNSAFE.putInt",
        "putInt",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        probe ^= probe << 13;   // xorshift\n        probe ^= probe >>> 17;\n        probe ^= probe << 5;\n        UNSAFE.putInt(Thread.currentThread(), PROBE, probe);\n        return probe;\n    }",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "cas",
      "signature": "final boolean cas(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Relax.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n        }        ",
      "line_number": 95,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "casBase",
      "signature": "final boolean casBase(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Relax.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);\n    }",
      "line_number": 144,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "casCellsBusy",
      "signature": "final boolean casCellsBusy() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Relax.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "UNSAFE.compareAndSwapInt",
        "compareAndSwapInt"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapInt(this, CELLSBUSY, 0, 1);\n    }",
      "line_number": 151,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "getProbe",
      "signature": "static final int getProbe() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Relax.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "UNSAFE.getInt",
        "getInt",
        "currentThread",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        return UNSAFE.getInt(Thread.currentThread(), PROBE);\n    }",
      "line_number": 159,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "advanceProbe",
      "signature": "static final int advanceProbe(int probe) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/jdkext/Stripped64Relax.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "UNSAFE.putInt",
        "putInt",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        probe ^= probe << 13;   // xorshift\n        probe ^= probe >>> 17;\n        probe ^= probe << 5;\n        UNSAFE.putInt(Thread.currentThread(), PROBE, probe);\n        return probe;\n    }",
      "line_number": 168,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "holding",
      "method_type": "method"
    },
    {
      "name": "ReadersEntry",
      "signature": "public ReadersEntry(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "AtomicInteger"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 6,
      "source_code": "            this.state = state;         \n        }",
      "line_number": 156,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "finalize",
      "signature": "protected void finalize() throws Throwable {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "super.finalize",
        "finalize"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            removeState(state);\n            super.finalize();\n        }",
      "line_number": 160,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "InnerReadLock",
      "signature": "public InnerReadLock(ScalableStampedRWLock rwlock) { this.rwlock = rwlock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 20,
      "source_code": "",
      "line_number": 173,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { rwlock.sharedLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "sharedLock",
        "rwlock.sharedLock"
      ],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 174,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { rwlock.sharedUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "sharedUnlock",
        "rwlock.sharedUnlock"
      ],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 175,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return rwlock.sharedTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "sharedTryLock",
        "rwlock.sharedTryLock"
      ],
      "concurrency_patterns": [],
      "complexity_score": 16,
      "source_code": "",
      "line_number": 176,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "                // Not supported\n                throw new UnsupportedOperationException();                      \n            }",
      "line_number": 182,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "                // Not supported\n                throw new UnsupportedOperationException();           \n            }\t    \t    ",
      "line_number": 186,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "InnerWriteLock",
      "signature": "public InnerWriteLock(ScalableStampedRWLock rwlock) { this.rwlock = rwlock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 20,
      "source_code": "",
      "line_number": 199,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { rwlock.exclusiveLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "rwlock.exclusiveLock",
        "exclusiveLock"
      ],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 200,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { rwlock.exclusiveUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "exclusiveUnlock",
        "rwlock.exclusiveUnlock"
      ],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 201,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return rwlock.exclusiveTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "rwlock.exclusiveTryLock",
        "exclusiveTryLock"
      ],
      "concurrency_patterns": [],
      "complexity_score": 16,
      "source_code": "",
      "line_number": 202,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                     \n        }        ",
      "line_number": 208,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }               ",
      "line_number": 212,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "ScalableStampedRWLock",
      "signature": "public ScalableStampedRWLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicReference",
        "AtomicInteger",
        "Lock",
        "ConcurrentLinkedQueue",
        "Thread",
        "lock",
        "ThreadLocal"
      ],
      "dependencies": [
        "InnerWriteLock",
        "ScalableStampedRWLock.InnerWriteLock",
        "StampedLock",
        "AtomicReference",
        "AtomicInteger",
        "ReadersEntry",
        "ConcurrentLinkedQueue",
        "InnerReadLock",
        "ScalableStampedRWLock.InnerReadLock",
        "ThreadLocal"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 60,
      "source_code": "        // States of the Readers, one entry in the list per thread\n        readersStateList = new ConcurrentLinkedQueue<AtomicInteger>();\n        stampedLock = new StampedLock();        \n        entry = new ThreadLocal<ReadersEntry>();        \n        readersStateArrayRef = new AtomicReference<AtomicInteger[]>(null);\n        readerLock = new ScalableStampedRWLock.InnerReadLock(this);\n        writerLock = new ScalableStampedRWLock.InnerWriteLock(this);\n    }",
      "line_number": 222,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "constructor"
    },
    {
      "name": "readLock",
      "signature": "public Lock readLock() { return readerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 232,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public Lock writeLock() { return writerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 233,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "removeState",
      "signature": "protected void removeState(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicInteger",
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "state.set",
        "remove",
        "set",
        "readersStateList.remove"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        readersStateList.remove(state);\n        // Setting the readersStateArrayRef to null will make the Writer\n        // rebuild the array from the CLQ.\n        readersStateArrayRef.set(null);\n        \n        // Paranoia: just in case someone forgot to call sharedUnlock()\n        // and there is a Writer waiting on that state.\n        state.set(SRWL_STATE_NOT_READING);\n    }",
      "line_number": 241,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "addState",
      "signature": "private ReadersEntry addState() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicInteger"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "readersStateList.add",
        "add",
        "AtomicInteger",
        "ReadersEntry",
        "entry.set",
        "set"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        final AtomicInteger state = new AtomicInteger(SRWL_STATE_NOT_READING);\n        final ReadersEntry newEntry = new ReadersEntry(state); \n        entry.set(newEntry);\n        readersStateList.add(state);\n        // Setting the readersStateArrayRef to null will make the Writer\n        // rebuild the array from the CLQ.\n        readersStateArrayRef.set(null);\n        return newEntry;\n    }",
      "line_number": 260,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedLock",
      "signature": "public void sharedLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "readlock",
        "entry.get",
        "stampedLock.isWriteLocked",
        "get",
        "currentReadersState.set",
        "StampedLock.readlock",
        "set",
        "stampedLock.asReadLock",
        "asReadLock",
        "isWriteLocked",
        "lock"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 95,
      "source_code": "        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        \n        final AtomicInteger currentReadersState = localEntry.state;\n        // The \"optimistic\" code path uses only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.\n        while (true) {\n            currentReadersState.set(SRWL_STATE_READING);\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return;\n            } else {\n                // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer\n                currentReadersState.set(SRWL_STATE_NOT_READING);\n                // If there is a Writer, we go for the StampedLock.readlock()\n                // instead of the ScalableRWLock method\n                if (stampedLock.isWriteLocked()) {                    \n                   stampedLock.asReadLock().lock();\n                   localEntry.isStampLocked = true;\n                   return;\n                }\n            }\n        }        \n    }    ",
      "line_number": 281,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedUnlock",
      "signature": "public void sharedUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock"
      ],
      "dependencies": [
        "entry.get",
        "state.set",
        "unlock",
        "get",
        "set",
        "stampedLock.asReadLock",
        "IllegalMonitorStateException",
        "asReadLock"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 54,
      "source_code": "        final ReadersEntry localEntry = entry.get();\n        if (localEntry==null) {\n            // ERROR: Tried to unlock a non read-locked lock\n            throw new IllegalMonitorStateException();\n        } else {\n            if (localEntry.isStampLocked) {\n                localEntry.isStampLocked = false;\n                stampedLock.asReadLock().unlock();\n            } else {\n                localEntry.state.set(SRWL_STATE_NOT_READING);\n            } \n            return;\n        }\n    }",
      "line_number": 321,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveLock",
      "signature": "public void exclusiveLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "stampedLock.writeLock",
        "size",
        "compareAndSet",
        "get",
        "writeLock",
        "readersStateList.toArray",
        "readersStateList.size",
        "set",
        "Thread.yield",
        "yield",
        "toArray",
        "readersStateArrayRef.get",
        "readerState.get",
        "readersStateArrayRef.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 47,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        stampedLock.writeLock();\n        \n        // We can only do this after the stampedLock has been acquired\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            while (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                Thread.yield();\n            }\n        }\n    }",
      "line_number": 347,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveUnlock",
      "signature": "public void exclusiveUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock",
        "unlock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.isWriteLocked",
        "unlock",
        "stampedLock.asWriteLock",
        "IllegalMonitorStateException",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "singleton_pattern"
      ],
      "complexity_score": 34,
      "source_code": "        if (!stampedLock.isWriteLocked()) {\n            // ERROR: tried to unlock a non write-locked instance\n            throw new IllegalMonitorStateException();\n        }\n        stampedLock.asWriteLock().unlock();\n    }",
      "line_number": 380,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLock",
      "signature": "public boolean sharedTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "entry.get",
        "stampedLock.isWriteLocked",
        "get",
        "currentReadersState.set",
        "set",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 49,
      "source_code": "        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        \n        final AtomicInteger currentReadersState = localEntry.state;\n        // The \"optimistic\" code path takes only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.\n        currentReadersState.set(SRWL_STATE_READING);\n        if (!stampedLock.isWriteLocked()) {\n            // Acquired lock in read-only mode\n            return true;\n        } else {\n            currentReadersState.set(SRWL_STATE_NOT_READING);         \n            return false;\n        }\n    }",
      "line_number": 403,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLockNanos",
      "signature": "public boolean sharedTryLockNanos(long nanosTimeout) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "entry.get",
        "stampedLock.isWriteLocked",
        "get",
        "currentReadersState.set",
        "set",
        "Thread.yield",
        "yield",
        "isWriteLocked",
        "System.nanoTime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 77,
      "source_code": "        final long lastTime = System.nanoTime();   \n        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        \n        final AtomicInteger currentReadersState = localEntry.state;\n        // The \"optimistic\" code path takes only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.        \n        while (true) {\n            currentReadersState.set(SRWL_STATE_READING);\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return true;\n            } else {\n                // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer\n                currentReadersState.set(SRWL_STATE_NOT_READING);                            \n                if (nanosTimeout <= 0) return false;                \n                while (stampedLock.isWriteLocked()) {                    \n                    // Some (other) thread is holding the write-lock, we must wait\n                    if (System.nanoTime()-lastTime < nanosTimeout) {\n                        Thread.yield();\n                    } else { \n                        return false;\n                    }\n                }   \n            }  \n        } \n    }",
      "line_number": 446,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLock",
      "signature": "public boolean exclusiveTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "unlock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "size",
        "compareAndSet",
        "asWriteLock",
        "stampedLock.asWriteLock",
        "unlock",
        "get",
        "readersStateList.toArray",
        "readersStateList.size",
        "stampedLock.tryWriteLock",
        "set",
        "toArray",
        "readersStateArrayRef.get",
        "tryWriteLock",
        "readerState.get",
        "readersStateArrayRef.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 61,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock() == 0) {\n            return false;\n        }\n\n        // We can only do this after the stampedLock has been acquired\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            if (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                stampedLock.asWriteLock().unlock();\n                return false;\n            }\n        }\n\n        return true;\n    }",
      "line_number": 495,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLockNanos",
      "signature": "public boolean exclusiveTryLockNanos(long nanosTimeout) throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readersStateList.toArray",
        "stampedLock.tryWriteLock",
        "Thread.yield",
        "readersStateArrayRef.set",
        "compareAndSet",
        "stampedLock.asWriteLock",
        "readersStateList.size",
        "set",
        "readersStateArrayRef.compareAndSet",
        "asWriteLock",
        "get",
        "toArray",
        "readersStateArrayRef.get",
        "tryWriteLock",
        "System.nanoTime",
        "nanoTime",
        "size",
        "unlock",
        "yield",
        "readerState.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 66,
      "source_code": "        final long lastTime = System.nanoTime();\n        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock(nanosTimeout, TimeUnit.NANOSECONDS) == 0) {\n            return false;\n        }\n                        \n        // We can only do this after the stampedLock has been acquired\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            while (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                if (System.nanoTime() - lastTime < nanosTimeout) {\n                    Thread.yield();\n                } else { \n                    // Time has expired and there is still at least one Reader so give up\n                    stampedLock.asWriteLock().unlock();\n                    return false;\n                }  \n            }\n        }\n\n        return true;\n    }",
      "line_number": 558,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "tryOptimisticRead",
      "signature": "public long tryOptimisticRead() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "tryOptimisticRead",
        "stampedLock.tryOptimisticRead"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        return stampedLock.tryOptimisticRead();\n    }",
      "line_number": 599,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "validate",
      "signature": "public boolean validate(long stamp) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "validate",
        "stampedLock.validate"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        return stampedLock.validate(stamp);\n    }    ",
      "line_number": 615,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/TidexMutex.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "final",
        "Thread",
        "getAndSet",
        "lock"
      ],
      "dependencies": [
        "ingress.getAndSet",
        "currentThread",
        "getId",
        "Thread.currentThread",
        "Thread.yield",
        "yield",
        "getAndSet"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        long mytid = Thread.currentThread().getId();\n        if (egress == mytid) mytid = -mytid;\n        final long prevtid = ingress.getAndSet(mytid);\n        while (egress != prevtid) {     \n            // Spin for a while and then yield\n            for (int k = MAX_SPIN; k > 0; k--) {\n                if (egress == prevtid) {\n                    // Lock has been acquired\n                    nextEgress = mytid;\n                    return;\n                }\n            }\n            Thread.yield(); \n        }\n        // Lock has been acquired\n        nextEgress = mytid;\n    }",
      "line_number": 83,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TidexMutex",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/TidexMutex.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        egress = nextEgress;\n    }",
      "line_number": 104,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TidexMutex",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/TidexMutex.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }",
      "line_number": 110,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TidexMutex",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/TidexMutex.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "Lock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "compareAndSet",
        "Thread.currentThread",
        "get",
        "ingress.get",
        "ingress.compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        final long localEgress;\n        if ((localEgress = egress) != ingress.get()) return false;\n        long mytid = Thread.currentThread().getId();\n        if (localEgress == mytid) mytid = -mytid;\n        // localEgress is the same as current ingress\n        if (!ingress.compareAndSet(localEgress, mytid)) return false; \n        // Lock has been acquired\n        nextEgress = mytid;\n        return true;\n    }",
      "line_number": 116,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TidexMutex",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/TidexMutex.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }    ",
      "line_number": 136,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TidexMutex",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { sharedLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 97,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { sharedUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 98,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return sharedTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 99,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                      \n        }",
      "line_number": 105,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }\t    \t    ",
      "line_number": 109,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { exclusiveLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 120,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { exclusiveUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 121,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return exclusiveTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 122,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                     \n        }        ",
      "line_number": 128,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }               ",
      "line_number": 132,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "LongAdderExtRWLock",
      "signature": "public LongAdderExtRWLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "InnerWriteLock",
        "StampedLock",
        "LongAdderExtRWLock.InnerReadLock",
        "InnerReadLock",
        "LongAdderExt",
        "LongAdderExtRWLock.InnerWriteLock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 36,
      "source_code": "        readers = new LongAdderExt();\n        stampedLock = new StampedLock();        \n        readerLock = new LongAdderExtRWLock.InnerReadLock();\n        writerLock = new LongAdderExtRWLock.InnerWriteLock();\n    }",
      "line_number": 142,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "constructor"
    },
    {
      "name": "readLock",
      "signature": "public Lock readLock() { return readerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 149,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public Lock writeLock() { return writerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 150,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedLock",
      "signature": "public void sharedLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "Lock",
        "final",
        "getAndAdd",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "readers.getandAddBase",
        "stampedLock.isWriteLocked",
        "Thread.yield",
        "getandAddBase",
        "yield",
        "cell.getAndAdd",
        "increment",
        "getAndAdd",
        "isWriteLocked",
        "readers.increment"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 40,
      "source_code": "        while (true) {\n            final LongAdderExt.Cell cell = readers.increment();\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return;\n            } else {\n                // Rollback counter to avoid blocking a Writer\n                if (cell == null) {\n                    // In case the increment is not done in a Cell but on base\n                    readers.getandAddBase(-1);\n                } else {\n                    cell.getAndAdd(-1);\n                }\n                // If there is a Writer, wait until it is gone\n                while (stampedLock.isWriteLocked()) {\n                    Thread.yield();\n                }\n            }\n        }        \n    }    ",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedUnlock",
      "signature": "public void sharedUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "readers.decrement",
        "decrement"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        readers.decrement();\n    }",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveLock",
      "signature": "public void exclusiveLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "stampedLock.writeLock",
        "writeLock",
        "sum",
        "readers.sum",
        "Thread.yield",
        "yield",
        "IllegalMonitorStateException"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 25,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        stampedLock.writeLock(); \n        while (true) {\n            final long egressSum = readers.sum();\n            if (egressSum == 0) return;\n            if (egressSum < 0) throw new IllegalMonitorStateException();            \n            Thread.yield();\n        }\n    }",
      "line_number": 202,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveUnlock",
      "signature": "public void exclusiveUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock",
        "unlock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.isWriteLocked",
        "unlock",
        "stampedLock.asWriteLock",
        "IllegalMonitorStateException",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "singleton_pattern"
      ],
      "complexity_score": 34,
      "source_code": "        if (!stampedLock.isWriteLocked()) {\n            // ERROR: tried to unlock a non write-locked instance\n            throw new IllegalMonitorStateException();\n        }\n        stampedLock.asWriteLock().unlock();\n    }",
      "line_number": 223,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLock",
      "signature": "public boolean sharedTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "final",
        "getAndAdd",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readers.getandAddBase",
        "stampedLock.isWriteLocked",
        "getandAddBase",
        "cell.getAndAdd",
        "increment",
        "getAndAdd",
        "isWriteLocked",
        "readers.increment"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 26,
      "source_code": "        final LongAdderExt.Cell cell = readers.increment();\n        if (!stampedLock.isWriteLocked()) {\n            // Acquired lock in read-only mode\n            return true;\n        } else {\n            // Lock can not be acquired right now. Rollback counter\n            if (cell == null) {\n                // In case the increment is not done in a Cell but on base\n                readers.getandAddBase(-1);\n            } else {\n                cell.getAndAdd(-1);\n            }\n            return false;\n        }         \n    }",
      "line_number": 246,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLockNanos",
      "signature": "public boolean sharedTryLockNanos (long nanosTimeout) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "Lock",
        "final",
        "getAndAdd",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "readers.getandAddBase",
        "stampedLock.isWriteLocked",
        "readers.increment",
        "Thread.yield",
        "getandAddBase",
        "yield",
        "cell.getAndAdd",
        "increment",
        "getAndAdd",
        "isWriteLocked",
        "System.nanoTime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 44,
      "source_code": "        final long lastTime = System.nanoTime();\n        while (true) {\n            final LongAdderExt.Cell cell = readers.increment();\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return true;\n            } else {\n                // Rollback counter to avoid blocking a Writer\n                if (cell == null) {\n                    // In case the increment is not done in a Cell but on base\n                    readers.getandAddBase(-1);\n                } else {\n                    cell.getAndAdd(-1);\n                }\n                // If there is a Writer, we wait\n                while (stampedLock.isWriteLocked()) {      \n                    if (System.nanoTime() - lastTime < nanosTimeout) {\n                        Thread.yield();\n                    } else { \n                        // Time has expired and there is still at least one Reader so give up\n                        return false;\n                    }\n                }\n            }\n        }        \n    }",
      "line_number": 285,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLock",
      "signature": "public boolean exclusiveTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.asWriteLock",
        "unlock",
        "sum",
        "stampedLock.tryWriteLock",
        "readers.sum",
        "tryWriteLock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 37,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock() == 0) {\n            return false;\n        }\n        if (readers.sum() == 0) return true;\n        // else\n        stampedLock.asWriteLock().unlock();\n        return false;\n    }",
      "line_number": 329,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLockNanos",
      "signature": "public boolean exclusiveTryLockNanos(long nanosTimeout) throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "asWriteLock",
        "stampedLock.asWriteLock",
        "unlock",
        "sum",
        "stampedLock.tryWriteLock",
        "readers.sum",
        "yield",
        "Thread.yield",
        "tryWriteLock",
        "System.nanoTime"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 43,
      "source_code": "        final long lastTime = System.nanoTime();\n        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock(nanosTimeout, TimeUnit.NANOSECONDS) == 0) {\n            return false;\n        }\n\n        while (true) {\n            if (readers.sum() == 0) return true;\n            if (System.nanoTime() - lastTime < nanosTimeout) {\n                Thread.yield();\n            } else { \n                // Time has expired and there is still at least one Reader so give up\n                stampedLock.asWriteLock().unlock();\n                return false;\n            }  \n        }\n    }",
      "line_number": 375,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "tryOptimisticRead",
      "signature": "public long tryOptimisticRead() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "tryOptimisticRead",
        "stampedLock.tryOptimisticRead"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        return stampedLock.tryOptimisticRead();\n    }",
      "line_number": 401,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "validate",
      "signature": "public boolean validate(long stamp) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderExtRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "validate",
        "stampedLock.validate"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        return stampedLock.validate(stamp);\n    }    ",
      "line_number": 417,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderExtRWLock",
      "method_type": "method"
    },
    {
      "name": "ReadersEntry",
      "signature": "public ReadersEntry(boolean value) { isStampLocked = value; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "",
      "line_number": 128,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { sharedLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 136,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { sharedUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 137,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return sharedTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 138,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                      \n        }",
      "line_number": 144,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }\t    \t    ",
      "line_number": 148,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { exclusiveLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 159,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { exclusiveUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 160,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return exclusiveTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 161,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                     \n        }        ",
      "line_number": 167,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }               ",
      "line_number": 171,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "LongAdderStampedRWLock",
      "signature": "public LongAdderStampedRWLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "Thread",
        "lock",
        "ThreadLocal"
      ],
      "dependencies": [
        "InnerWriteLock",
        "LongAdder",
        "StampedLock",
        "ReadersEntry",
        "LongAdderStampedRWLock.InnerWriteLock",
        "InnerReadLock",
        "LongAdderStampedRWLock.InnerReadLock",
        "ThreadLocal"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 42,
      "source_code": "        readersIngress = new LongAdder();\n        readersEgress = new LongAdder();\n        stampedLock = new StampedLock();        \n        entry = new ThreadLocal<ReadersEntry>();\n        readerLock = new LongAdderStampedRWLock.InnerReadLock();\n        writerLock = new LongAdderStampedRWLock.InnerWriteLock();\n    }",
      "line_number": 181,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "constructor"
    },
    {
      "name": "readLock",
      "signature": "public Lock readLock() { return readerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 190,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public Lock writeLock() { return writerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 191,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedLock",
      "signature": "public void sharedLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "readlock",
        "entry.get",
        "stampedLock.isWriteLocked",
        "ReadersEntry",
        "get",
        "StampedLock.readlock",
        "set",
        "entry.set",
        "increment",
        "stampedLock.asReadLock",
        "asReadLock",
        "isWriteLocked",
        "readersEgress.increment",
        "lock",
        "readersIngress.increment"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 79,
      "source_code": "        while (true) {\n            readersIngress.increment();\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return;\n            } else {\n                // Rollback logical counter to avoid blocking a Writer\n                readersEgress.increment();\n                // If there is a Writer, we go for the StampedLock.readlock()\n                if (stampedLock.isWriteLocked()) {                    \n                    stampedLock.asReadLock().lock();\n                    final ReadersEntry localEntry = entry.get();\n                    if (localEntry == null) {\n                        // Yes we allocate memory, but only once per thread, \n                        // and we're stuck waiting for the Writer anyways.\n                        entry.set(new ReadersEntry(true));\n                    } else {\n                        localEntry.isStampLocked = true;\n                    }\n                    return;\n                }\n            }\n        }        \n    }    ",
      "line_number": 203,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedUnlock",
      "signature": "public void sharedUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock"
      ],
      "dependencies": [
        "entry.get",
        "unlock",
        "get",
        "increment",
        "stampedLock.asReadLock",
        "asReadLock",
        "readersEgress.increment"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 39,
      "source_code": "        final ReadersEntry localEntry = entry.get();\n        if (localEntry != null) {\n            if (localEntry.isStampLocked) {\n                localEntry.isStampLocked = false;\n                stampedLock.asReadLock().unlock();\n                return;\n            } \n        } \n        readersEgress.increment();\n        return;\n    }",
      "line_number": 233,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveLock",
      "signature": "public void exclusiveLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "stampedLock.writeLock",
        "readersEgress.sum",
        "writeLock",
        "sum",
        "Thread.yield",
        "yield",
        "readersIngress.sum"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 27,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        stampedLock.writeLock(); \n        while (true) {\n            // Order is _very_ important here\n            final long egressSum = readersEgress.sum();\n            final long ingressSum = readersIngress.sum();\n            if (egressSum == ingressSum) return;\n            // TODO: Do something smarter, like spin for a while and then yield()\n            Thread.yield();\n        }\n    }",
      "line_number": 256,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveUnlock",
      "signature": "public void exclusiveUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock",
        "unlock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.isWriteLocked",
        "unlock",
        "stampedLock.asWriteLock",
        "IllegalMonitorStateException",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "singleton_pattern"
      ],
      "complexity_score": 34,
      "source_code": "        if (!stampedLock.isWriteLocked()) {\n            // ERROR: tried to unlock a non write-locked instance\n            throw new IllegalMonitorStateException();\n        }\n        stampedLock.asWriteLock().unlock();\n    }",
      "line_number": 279,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLock",
      "signature": "public boolean sharedTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "stampedLock.isWriteLocked",
        "increment",
        "isWriteLocked",
        "readersEgress.increment",
        "readersIngress.increment"
      ],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 24,
      "source_code": "        readersIngress.increment();\n        if (!stampedLock.isWriteLocked()) {\n            // Acquired lock in read-only mode\n            return true;\n        } else {\n            // Lock can not be acquired right now. Rollback logical counter\n            readersEgress.increment();\n            return false;\n        }         \n    }",
      "line_number": 302,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLockNanos",
      "signature": "public boolean sharedTryLockNanos (long nanosTimeout) throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "final",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readlock",
        "entry.get",
        "stampedLock.isWriteLocked",
        "ReadersEntry",
        "get",
        "StampedLock.readlock",
        "set",
        "entry.set",
        "increment",
        "stampedLock.asReadLock",
        "asReadLock",
        "isWriteLocked",
        "readersEgress.increment",
        "tryLock",
        "readersIngress.increment"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 79,
      "source_code": "        readersIngress.increment();\n        if (!stampedLock.isWriteLocked()) {\n            // Acquired lock in read-only mode\n            return true;\n        } else {\n            // Rollback logical counter to avoid blocking a Writer\n            readersEgress.increment();\n            // If there is a Writer, we go for the StampedLock.readlock()\n            if (stampedLock.isWriteLocked()) {      \n                if (stampedLock.asReadLock().tryLock(nanosTimeout, TimeUnit.NANOSECONDS)) {\n                    final ReadersEntry localEntry = entry.get();\n                    if (localEntry == null) {\n                        entry.set(new ReadersEntry(true));\n                    } else {\n                        localEntry.isStampLocked = true;\n                    }\n                    return true;\n                } // else\n                return false;\n            }\n        }\n        return false;        \n    }",
      "line_number": 336,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLock",
      "signature": "public boolean exclusiveTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "asWriteLock",
        "readersEgress.sum",
        "unlock",
        "stampedLock.asWriteLock",
        "sum",
        "stampedLock.tryWriteLock",
        "tryWriteLock",
        "readersIngress.sum"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 37,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock() == 0) {\n            return false;\n        }\n        // Order is _very_ important here\n        final long egressSum = readersEgress.sum();\n        final long ingressSum = readersIngress.sum();\n        if (egressSum == ingressSum) {\n            return true;\n        } // else\n        stampedLock.asWriteLock().unlock();\n        return false;\n    }",
      "line_number": 377,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLockNanos",
      "signature": "public boolean exclusiveTryLockNanos(long nanosTimeout) throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "asWriteLock",
        "readersEgress.sum",
        "unlock",
        "stampedLock.asWriteLock",
        "sum",
        "stampedLock.tryWriteLock",
        "Thread.yield",
        "yield",
        "tryWriteLock",
        "System.nanoTime",
        "readersIngress.sum"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 43,
      "source_code": "        final long lastTime = System.nanoTime();\n        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock(nanosTimeout, TimeUnit.NANOSECONDS) == 0) {\n            return false;\n        }\n\n        while (true) {\n            // Order is _very_ important here\n            final long egressSum = readersEgress.sum();\n            final long ingressSum = readersIngress.sum();\n            if (egressSum == ingressSum) return true;\n            if (System.nanoTime() - lastTime < nanosTimeout) {\n                Thread.yield();\n            } else { \n                // Time has expired and there is still at least one Reader so give up\n                stampedLock.asWriteLock().unlock();\n                return false;\n            }  \n        }\n    }",
      "line_number": 427,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "tryOptimisticRead",
      "signature": "public long tryOptimisticRead() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "tryOptimisticRead",
        "stampedLock.tryOptimisticRead"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        return stampedLock.tryOptimisticRead();\n    }",
      "line_number": 456,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "validate",
      "signature": "public boolean validate(long stamp) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderStampedRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "validate",
        "stampedLock.validate"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        return stampedLock.validate(stamp);\n    }    ",
      "line_number": 472,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderStampedRWLock",
      "method_type": "method"
    },
    {
      "name": "ReadersEntry",
      "signature": "public ReadersEntry(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "AtomicInteger"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 6,
      "source_code": "            this.state = state;         \n        }",
      "line_number": 173,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "finalize",
      "signature": "protected void finalize() throws Throwable {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "super.finalize",
        "finalize"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            removeState(state);\n            super.finalize();\n        }",
      "line_number": 177,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { sharedLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { sharedUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 189,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return sharedTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 190,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                      \n        }",
      "line_number": 196,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }\t    \t    ",
      "line_number": 200,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { exclusiveLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 210,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { exclusiveUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 211,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return exclusiveTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 212,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                     \n        }        ",
      "line_number": 218,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }               ",
      "line_number": 222,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "ScalableStampedReentrantRWLock",
      "signature": "public ScalableStampedReentrantRWLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "StampedLock",
        "AtomicReference",
        "AtomicInteger",
        "Lock",
        "ConcurrentLinkedQueue",
        "Thread",
        "lock",
        "ThreadLocal"
      ],
      "dependencies": [
        "InnerWriteLock",
        "ScalableStampedReentrantRWLock.InnerWriteLock",
        "StampedLock",
        "ScalableStampedReentrantRWLock.InnerReadLock",
        "AtomicLong",
        "AtomicReference",
        "AtomicInteger",
        "ReadersEntry",
        "ConcurrentLinkedQueue",
        "InnerReadLock",
        "ThreadLocal"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 64,
      "source_code": "        // States of the Readers, one entry in the list per thread\n        readersStateList = new ConcurrentLinkedQueue<AtomicInteger>();        \n        stampedLock = new StampedLock();        \n        writerOwner = new AtomicLong(SRWL_INVALID_TID);\n        reentrantWriterCounter = 0;\n        entry = new ThreadLocal<ReadersEntry>();\n        readersStateArrayRef = new AtomicReference<AtomicInteger[]>(null);        \n        readerLock = new ScalableStampedReentrantRWLock.InnerReadLock();\n        writerLock = new ScalableStampedReentrantRWLock.InnerWriteLock();\n    }",
      "line_number": 232,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "constructor"
    },
    {
      "name": "readLock",
      "signature": "public Lock readLock() { return readerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 244,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public Lock writeLock() { return writerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 245,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "removeState",
      "signature": "protected void removeState(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicInteger",
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "state.set",
        "remove",
        "set",
        "readersStateList.remove"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        readersStateList.remove(state);\n        // Setting the readersStateArrayRef to null will make the Writer\n        // rebuild the array from the CLQ.\n        readersStateArrayRef.set(null);\n        \n        // Paranoia: just in case someone forgot to call sharedUnlock()\n        // and there is a Writer waiting on that state.\n        state.set(SRWL_STATE_NOT_READING);\n    }",
      "line_number": 253,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "addState",
      "signature": "private ReadersEntry addState() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicInteger"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "readersStateList.add",
        "add",
        "AtomicInteger",
        "ReadersEntry",
        "entry.set",
        "set"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        final AtomicInteger state = new AtomicInteger(SRWL_STATE_NOT_READING);\n        final ReadersEntry newEntry = new ReadersEntry(state); \n        entry.set(newEntry);\n        readersStateList.add(state);\n        // Setting the readersStateArrayRef to null will make the Writer\n        // rebuild the array from the CLQ\n        readersStateArrayRef.set(null);\n        return newEntry;\n    }",
      "line_number": 272,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedLock",
      "signature": "public void sharedLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "readlock",
        "entry.get",
        "stampedLock.isWriteLocked",
        "get",
        "currentReadersState.set",
        "StampedLock.readlock",
        "set",
        "stampedLock.asReadLock",
        "asReadLock",
        "isWriteLocked",
        "lock"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 112,
      "source_code": "        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        \n        // Already locked in read-mode, this is a reentrant lock so just \n        // increase the count and return.\n        if (localEntry.reentrantReaderCount > 0) {\n            localEntry.reentrantReaderCount++;\n            return;\n        }             \n        \n        final AtomicInteger currentReadersState = localEntry.state;\n        // The \"optimistic\" code path uses only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.\n        while (true) {\n            currentReadersState.set(SRWL_STATE_READING);\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                localEntry.reentrantReaderCount = 1;                \n                return;\n            } else {\n                // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer\n                currentReadersState.set(SRWL_STATE_NOT_READING);             \n                // If there is a Writer, we go for the StampedLock.readlock()\n                // instead of the ScalableRWLock method\n                if (stampedLock.isWriteLocked()) {                    \n                    stampedLock.asReadLock().lock();\n                    localEntry.isStampLocked = true;\n                    localEntry.reentrantReaderCount = 1;\n                    return;\n                }\n            }\n        }        \n    }    ",
      "line_number": 293,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedUnlock",
      "signature": "public void sharedUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock"
      ],
      "dependencies": [
        "entry.get",
        "state.set",
        "unlock",
        "get",
        "set",
        "stampedLock.asReadLock",
        "IllegalMonitorStateException",
        "asReadLock"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 62,
      "source_code": "        final ReadersEntry localEntry = entry.get();\n        if (localEntry==null || localEntry.reentrantReaderCount == 0) {\n            // ERROR: Tried to unlock a non read-locked lock\n            throw new IllegalMonitorStateException();\n        } else {\n            localEntry.reentrantReaderCount--;\n            if (localEntry.reentrantReaderCount == 0) {            \n                if (localEntry.isStampLocked) {\n                    localEntry.isStampLocked = false;\n                    stampedLock.asReadLock().unlock();\n                } else {\n                    localEntry.state.set(SRWL_STATE_NOT_READING);\n                }\n            }\n            return;\n        }\n    }",
      "line_number": 345,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveLock",
      "signature": "public void exclusiveLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "readersStateList.toArray",
        "Thread.yield",
        "readersStateArrayRef.set",
        "currentThread",
        "getId",
        "stampedLock.writeLock",
        "compareAndSet",
        "Thread.currentThread",
        "readersStateList.size",
        "writeLock",
        "set",
        "readersStateArrayRef.compareAndSet",
        "writerOwner.get",
        "get",
        "toArray",
        "readersStateArrayRef.get",
        "writerOwner.set",
        "size",
        "yield",
        "readerState.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 62,
      "source_code": "        // Already locked in write-mode, this is a reentrant lock so just \n        // increase the count and return.\n        if (writerOwner.get() == Thread.currentThread().getId()) {\n            reentrantWriterCounter++;\n            return;\n        }\n                \n        // Try to acquire the lock in write-mode \n        stampedLock.writeLock();\n        writerOwner.set(Thread.currentThread().getId());\n        reentrantWriterCounter++;\n                        \n        // We can only do this after writerOwner has been set to the current thread\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            while (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                Thread.yield();\n            }\n        }\n    }",
      "line_number": 380,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveUnlock",
      "signature": "public void exclusiveUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread",
        "asWriteLock",
        "stampedLock.isWriteLocked",
        "unlock",
        "get",
        "writerOwner.get",
        "stampedLock.asWriteLock",
        "set",
        "IllegalMonitorStateException",
        "isWriteLocked",
        "writerOwner.set"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 39,
      "source_code": "        final long tid_self = Thread.currentThread().getId();\n        if (!stampedLock.isWriteLocked() || \n            writerOwner.get() != tid_self || \n            reentrantWriterCounter == 0) {\n            // ERROR: tried to unlock a non write-locked instance\n            throw new IllegalMonitorStateException();\n        }\n        reentrantWriterCounter--;        \n        if (reentrantWriterCounter == 0) {\n            writerOwner.set(SRWL_INVALID_TID);\n            stampedLock.asWriteLock().unlock();\n        }\n    }",
      "line_number": 425,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLock",
      "signature": "public boolean sharedTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "entry.get",
        "Thread.currentThread",
        "stampedLock.isWriteLocked",
        "writerOwner.get",
        "get",
        "currentReadersState.set",
        "set",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 87,
      "source_code": "        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        \n        // Already locked in read-mode, this is a reentrant lock so just \n        // increase the count and return.\n        if (localEntry.reentrantReaderCount > 0) {\n            localEntry.reentrantReaderCount++;\n            return true;\n        }        \n        \n        final AtomicInteger currentReadersState = localEntry.state;\n        // The \"optimistic\" code path takes only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.\n        currentReadersState.set(SRWL_STATE_READING);\n        if (!stampedLock.isWriteLocked()) {\n            // Acquired lock in read-only mode\n            localEntry.reentrantReaderCount = 1;            \n            return true;\n        } else {\n            // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer\n            // and then check if this is a downgrade.\n            currentReadersState.set(SRWL_STATE_NOT_READING);\n            if (writerOwner.get() == Thread.currentThread().getId()) {\n                // Looks like it's the current thread that is holding the\n                // write-lock. It's safe to go ahead and acquire the read-lock\n                currentReadersState.set(SRWL_STATE_READING);\n                localEntry.reentrantReaderCount = 1;\n                return true;\n            }        \n            return false;\n        }\n    }",
      "line_number": 455,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLockNanos",
      "signature": "public boolean sharedTryLockNanos(long nanosTimeout) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "currentThread",
        "getId",
        "entry.get",
        "Thread.currentThread",
        "stampedLock.isWriteLocked",
        "writerOwner.get",
        "get",
        "currentReadersState.set",
        "set",
        "Thread.yield",
        "yield",
        "isWriteLocked",
        "System.nanoTime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 110,
      "source_code": "        final long lastTime = System.nanoTime();\n        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        \n        // Already locked in read-mode, this is a reentrant lock so just \n        // increase the count and return.\n        if (localEntry.reentrantReaderCount > 0) {\n            localEntry.reentrantReaderCount++;\n            return true;\n        } \n        \n        final AtomicInteger currentReadersState = localEntry.state;\n        // The \"optimistic\" code path takes only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.        \n        while (true) {\n            currentReadersState.set(SRWL_STATE_READING);\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                localEntry.reentrantReaderCount = 1;\n                return true;\n            } else {\n                // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer\n                currentReadersState.set(SRWL_STATE_NOT_READING);\n                if (writerOwner.get() == Thread.currentThread().getId()) {\n                    // Looks like it's the current thread that is holding the\n                    // write-lock. It's safe to go ahead and acquire the read-lock\n                    currentReadersState.set(SRWL_STATE_READING);\n                    localEntry.reentrantReaderCount = 1;\n                    return true;\n                }\n                \n                if (nanosTimeout <= 0) return false;                \n                currentReadersState.set(SRWL_STATE_READING);\n                while (stampedLock.isWriteLocked()) {                    \n                    // Some (other) thread is holding the write-lock, we must wait\n                    currentReade",
      "line_number": 515,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLock",
      "signature": "public boolean exclusiveTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readersStateList.toArray",
        "stampedLock.tryWriteLock",
        "readersStateArrayRef.set",
        "currentThread",
        "getId",
        "compareAndSet",
        "Thread.currentThread",
        "stampedLock.asWriteLock",
        "readersStateList.size",
        "set",
        "readersStateArrayRef.compareAndSet",
        "asWriteLock",
        "writerOwner.get",
        "get",
        "toArray",
        "readersStateArrayRef.get",
        "tryWriteLock",
        "writerOwner.set",
        "size",
        "unlock",
        "readerState.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 69,
      "source_code": "        final long tidSelf = Thread.currentThread().getId();\n        if (writerOwner.get() == tidSelf) {\n           // Already locked in write-mode, just increase the count and return           \n           reentrantWriterCounter++;\n           return true; \n        }\n        // Try to acquire the lock in write-mode \n        if (stampedLock.tryWriteLock() == 0) {\n            return false;\n        }\n         \n        // We can only do this after writerOwner has been set to the current thread\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            if (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                stampedLock.asWriteLock().unlock();\n                return false;\n            }\n        }\n        \n        reentrantWriterCounter = 1;\n        writerOwner.set(tidSelf);        \n        return true;\n    }",
      "line_number": 589,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLockNanos",
      "signature": "public boolean exclusiveTryLockNanos(long nanosTimeout) throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readersStateList.toArray",
        "stampedLock.tryWriteLock",
        "Thread.yield",
        "readersStateArrayRef.set",
        "currentThread",
        "getId",
        "compareAndSet",
        "Thread.currentThread",
        "stampedLock.asWriteLock",
        "readersStateList.size",
        "set",
        "readersStateArrayRef.compareAndSet",
        "asWriteLock",
        "writerOwner.get",
        "get",
        "toArray",
        "readersStateArrayRef.get",
        "tryWriteLock",
        "System.nanoTime",
        "writerOwner.set",
        "nanoTime",
        "size",
        "unlock",
        "yield",
        "readerState.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 74,
      "source_code": "        final long lastTime = System.nanoTime();\n        final long tidSelf = Thread.currentThread().getId();\n        if (writerOwner.get() == tidSelf) {\n           // Already locked in write-mode, just increase the count and return           \n           reentrantWriterCounter++;\n           return true; \n        }\n        \n        // Try to acquire the stampedLock in write-mode\n        if (stampedLock.tryWriteLock(nanosTimeout, TimeUnit.NANOSECONDS) == 0) {\n            return false;\n        }\n                        \n        // We can only do this after writerOwner has been set to the current thread\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            while (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                if (System.nanoTime() - lastTime < nanosTimeout) {\n                    Thread.yield();\n                } else { \n                    // Time has expired and there is still at least one Reader so give up\n                    stampedLock.asWriteLock().unlock();\n                    return false;\n                }            \n            }\n        }\n        \n        reentrantWriterCounter = 1;\n        writerOwner.set(tidSelf);\n        return true;\n    }",
      "line_number": 649,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "tryOptimisticRead",
      "signature": "public long tryOptimisticRead() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "tryOptimisticRead",
        "stampedLock.tryOptimisticRead"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        return stampedLock.tryOptimisticRead();\n    }",
      "line_number": 699,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "validate",
      "signature": "public boolean validate(long stamp) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableStampedReentrantRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "validate",
        "stampedLock.validate"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        return stampedLock.validate(stamp);\n    }    ",
      "line_number": 715,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableStampedReentrantRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { sharedLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 106,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { sharedUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 107,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return sharedTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 108,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                 \n        }        ",
      "line_number": 114,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();        \n        }\t    \t    ",
      "line_number": 118,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { exclusiveLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 129,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { exclusiveUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 130,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return exclusiveTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();            \n        }        ",
      "line_number": 137,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();    \n        }               ",
      "line_number": 141,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "ScalableRWLockS",
      "signature": "public ScalableRWLockS() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicInteger",
        "Lock",
        "AtomicIntegerArray",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "InnerWriteLock",
        "AtomicLong",
        "InnerReadLock",
        "AtomicIntegerArray",
        "set",
        "readersState.set",
        "ScalableRWLockS.InnerWriteLock",
        "ScalableRWLockS.InnerReadLock"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 44,
      "source_code": "        // States of the Readers, one per thread\n        readersState = new AtomicIntegerArray(MAX_NUM_THREADS*CACHE_PADD);\n        for (int i = 0; i < MAX_NUM_THREADS*CACHE_PADD; i += CACHE_PADD) {\n            readersState.set(i, SRWL_STATE_NOT_READING);\n        }\n\n        writerOwner = new AtomicLong(SRWL_INVALID_TID);     \n        readerLock = new ScalableRWLockS.InnerReadLock();\n        writerLock = new ScalableRWLockS.InnerWriteLock();\n    }",
      "line_number": 151,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "constructor"
    },
    {
      "name": "readLock",
      "signature": "public Lock readLock() { return readerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 163,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public Lock writeLock() { return writerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 164,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "threadInit",
      "signature": "public static void threadInit() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Lock",
        "unlock",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "tidx.get",
        "mutex.lock",
        "Thread.currentThread",
        "mutex.unlock",
        "unlock",
        "get",
        "highestAssigned.set",
        "set",
        "highestAssigned.get",
        "IllegalMonitorStateException",
        "lock",
        "tidx.set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 36,
      "source_code": "        if (tidx.get() != null) return;\n        \n        if (highestAssigned.get() > MAX_NUM_THREADS-1) {\n            // The user is running with more threads than MAX_NUM_THREADS, or \n            // forgot to call threadCleanup() at some point.\n            throw new IllegalMonitorStateException();\n        }\n        \n        mutex.lock();        \n        for (int i = 0; i < MAX_NUM_THREADS; i++) {\n            if (assignedThreads[i] == SRWL_INVALID_TID) { \n                assignedThreads[i] = Thread.currentThread().getId();\n                tidx.set(i*CACHE_PADD);\n                if (i+1 > highestAssigned.get()) highestAssigned.set(i+1);\n                break;\n            }\n        }\n        mutex.unlock();\n    }",
      "line_number": 173,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "threadCleanup",
      "signature": "public static void threadCleanup() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Lock",
        "unlock",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "tidx.get",
        "mutex.lock",
        "mutex.unlock",
        "unlock",
        "get",
        "highestAssigned.set",
        "set",
        "lock",
        "tidx.set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        if (tidx.get() == null) return;\n        \n        mutex.lock();\n        assignedThreads[tidx.get()/CACHE_PADD] = SRWL_INVALID_TID;\n        tidx.set(null);\n        // Search the highest non-occupied entry and set the highestAssigned to it       \n        for (int i = MAX_NUM_THREADS-1; i > 0; i--) {\n            if (assignedThreads[i] != SRWL_INVALID_TID) {\n                highestAssigned.set(i+1);      \n                break;\n            }\n        }\n        mutex.unlock();\n    }",
      "line_number": 198,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "sharedLock",
      "signature": "public void sharedLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "tidRef.intValue",
        "tidx.get",
        "intValue",
        "writerOwner.get",
        "get",
        "set",
        "Thread.yield",
        "yield",
        "readersState.set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 44,
      "source_code": "        Integer tidRef = tidx.get();\n        // Initialize the thread-id for this thread if needed        \n        if (tidRef == null || tidRef.intValue() == SRWL_INVALID_TID) {\n            threadInit();\n            tidRef = tidx.get();\n        }\n        final int localTid = tidRef.intValue();\n\n        // The \"optimistic\" code path takes only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.\n        while (true) {\n            readersState.set(localTid, SRWL_STATE_READING);\n            if (writerOwner.get() == SRWL_INVALID_TID) {\n                // Acquired lock in read-only mode\n                return;\n            } else {\n                // A Writer has acquired the lock, must reset to 0 and wait\n                readersState.set(localTid, SRWL_STATE_NOT_READING);\n                // Some (other) thread is holding the write-lock, we must wait\n                while (writerOwner.get() != SRWL_INVALID_TID) {\n                   Thread.yield();\n                }\n            }\n        }        \n    }    ",
      "line_number": 224,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "sharedUnlock",
      "signature": "public void sharedUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "tidx.get",
        "readersState.get",
        "get",
        "set",
        "readersState.set",
        "IllegalMonitorStateException"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        final int localTid = tidx.get();   \n        if (readersState.get(localTid) == SRWL_STATE_NOT_READING) {\n            // ERROR: tried to unlock a non read-locked lock\n            throw new IllegalMonitorStateException();\n        } else {\n            readersState.set(localTid, SRWL_STATE_NOT_READING);\n            return;\n        }\n    }",
      "line_number": 262,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "exclusiveLock",
      "signature": "public void exclusiveLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "compareAndSet",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "compareAndSet",
        "Thread.currentThread",
        "readersState.get",
        "get",
        "Thread.yield",
        "yield",
        "highestAssigned.get",
        "writerOwner.compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 30,
      "source_code": "        final long tidSelf = Thread.currentThread().getId();\n        \n        // Try to acquire the lock in write-mode \n        while (!writerOwner.compareAndSet(SRWL_INVALID_TID, tidSelf)) { \n            Thread.yield();\n        }\n        \n        // Write-Lock was acquired, now wait for any running Readers to finish\n        for (int i = 0; i < highestAssigned.get()*CACHE_PADD; i += CACHE_PADD) {\n            while (readersState.get(i) == SRWL_STATE_READING) {\n                Thread.yield();\n            }\n        }\n    }",
      "line_number": 284,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "exclusiveUnlock",
      "signature": "public void exclusiveUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread",
        "writerOwner.get",
        "get",
        "set",
        "IllegalMonitorStateException",
        "writerOwner.set"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        final long tidSelf = Thread.currentThread().getId();\n        if (writerOwner.get() != tidSelf) {\n            // ERROR: tried to unlock a non write-locked lock\n            throw new IllegalMonitorStateException();\n        }\n        writerOwner.set(SRWL_INVALID_TID);        \n    }",
      "line_number": 310,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "sharedTryLock",
      "signature": "public boolean sharedTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "tidRef.intValue",
        "tidx.get",
        "intValue",
        "writerOwner.get",
        "get",
        "set",
        "readersState.set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 30,
      "source_code": "        Integer tidRef = tidx.get();\n        // Initialize the thread-id for this thread if needed        \n        if (tidRef == null || tidRef.intValue() == SRWL_INVALID_TID) {\n            threadInit();\n            tidRef = tidx.get();\n        }\n        final int localTid = tidRef.intValue();\n\n        readersState.set(localTid, SRWL_STATE_READING);\n        if (writerOwner.get() == SRWL_INVALID_TID) {\n            // Acquired lock in read-only mode\n            return true;\n        } else {\n            // A Writer has acquired the lock, must reset to \"not reading\" and lock has failed\n            readersState.set(localTid, SRWL_STATE_NOT_READING);\n            return false;\n        }\n    }",
      "line_number": 333,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLock",
      "signature": "public boolean exclusiveTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLockS.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "Lock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "compareAndSet",
        "Thread.currentThread",
        "readersState.get",
        "get",
        "set",
        "highestAssigned.get",
        "writerOwner.compareAndSet",
        "writerOwner.set"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 31,
      "source_code": "        final long tidSelf = Thread.currentThread().getId();        \n        // Try to acquire the lock in write-mode and if it fails then return immediately \n        if (!writerOwner.compareAndSet(SRWL_INVALID_TID, tidSelf)) {\n            return false; \n        }\n\n        // Write-Lock was acquired, now check if there are Readers running\n        for (int i = 0; i < highestAssigned.get()*CACHE_PADD; i += CACHE_PADD) {\n            if (readersState.get(i) == SRWL_STATE_READING) {\n                // There are Readers so undo the write-lock and return false\n                writerOwner.set(SRWL_INVALID_TID);\n                return false;\n            }\n        }\n        \n        return true;\n    }",
      "line_number": 367,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLockS",
      "method_type": "method"
    },
    {
      "name": "ReadersEntry",
      "signature": "public ReadersEntry(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "AtomicInteger"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 6,
      "source_code": "            this.state = state;         \n        }",
      "line_number": 143,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "finalize",
      "signature": "protected void finalize() throws Throwable {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "super.finalize",
        "finalize"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            removeState(state);\n            super.finalize();\n        }",
      "line_number": 147,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { sharedLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 158,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { sharedUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 159,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return sharedTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 160,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                      \n        }",
      "line_number": 166,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }\t    \t    ",
      "line_number": 170,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { exclusiveLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 181,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { exclusiveUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 182,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return exclusiveTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 183,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                     \n        }        ",
      "line_number": 189,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }               ",
      "line_number": 193,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "ScalableRWLock",
      "signature": "public ScalableRWLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicReference",
        "AtomicInteger",
        "Lock",
        "ConcurrentLinkedQueue",
        "Thread",
        "lock",
        "ThreadLocal"
      ],
      "dependencies": [
        "InnerWriteLock",
        "StampedLock",
        "AtomicReference",
        "AtomicInteger",
        "ReadersEntry",
        "ConcurrentLinkedQueue",
        "InnerReadLock",
        "ScalableRWLock.InnerWriteLock",
        "ScalableRWLock.InnerReadLock",
        "ThreadLocal"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "reader_writer_lock",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 73,
      "source_code": "        // States of the Readers, one entry in the list per thread\n        readersStateList = new ConcurrentLinkedQueue<AtomicInteger>();\n        \n        stampedLock = new StampedLock();\n\n        // Default value for \"entry\" is null which is ok because, the thread \n        // calling the constructor may never attempt to read-lock this \n        // instance and, therefore, there is not point in allocating an \n        // instance of ReadersEntry for it.\n        entry = new ThreadLocal<ReadersEntry>();\n        \n        readersStateArrayRef = new AtomicReference<AtomicInteger[]>(null);\n        \n        readerLock = new ScalableRWLock.InnerReadLock();\n        writerLock = new ScalableRWLock.InnerWriteLock();\n    }",
      "line_number": 203,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "constructor"
    },
    {
      "name": "readLock",
      "signature": "public Lock readLock() { return readerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 221,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public Lock writeLock() { return writerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 222,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "removeState",
      "signature": "protected void removeState(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicInteger",
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "state.set",
        "remove",
        "set",
        "readersStateList.remove"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        readersStateList.remove(state);\n        readersStateArrayRef.set(null);\n        // Paranoia: just in case someone forgot to call sharedUnlock()\n        // and there is a Writer waiting on that state\n        state.set(SRWL_STATE_NOT_READING);\n    }",
      "line_number": 230,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "addState",
      "signature": "private ReadersEntry addState() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicInteger"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "readersStateList.add",
        "add",
        "AtomicInteger",
        "ReadersEntry",
        "entry.set",
        "set"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        final AtomicInteger state = new AtomicInteger(SRWL_STATE_NOT_READING);\n        final ReadersEntry newEntry = new ReadersEntry(state); \n        entry.set(newEntry);\n        readersStateList.add(state);\n        readersStateArrayRef.set(null);\n        return newEntry;\n    }",
      "line_number": 246,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedLock",
      "signature": "public void sharedLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "synchronized",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "entry.get",
        "stampedLock.isWriteLocked",
        "get",
        "currentReadersState.set",
        "set",
        "Thread.yield",
        "yield",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 72,
      "source_code": "        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }    \n\n        final AtomicInteger currentReadersState = localEntry.state;\n        // The \"optimistic\" code path takes only two synchronized calls:\n        // a set() on a cache line that should be held in exclusive mode \n        // by the current thread, and a get() on a cache line that is shared.\n        while (true) {\n            currentReadersState.set(SRWL_STATE_READING);\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return;\n            } else {\n                // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer\n                currentReadersState.set(SRWL_STATE_NOT_READING);\n                // Some (other) thread is holding the write-lock, we must wait\n                while (stampedLock.isWriteLocked()) {\n                   Thread.yield();\n                }\n            }\n        }        \n    }    ",
      "line_number": 265,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedUnlock",
      "signature": "public void sharedUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "state.set",
        "entry.get",
        "get",
        "set",
        "IllegalMonitorStateException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        final ReadersEntry localEntry = entry.get();\n        if (localEntry==null) {\n            // ERROR: Tried to unlock a non read-locked lock\n            throw new IllegalMonitorStateException();\n        } else {\n            localEntry.state.set(SRWL_STATE_NOT_READING);\n            return;\n        }\n    }",
      "line_number": 305,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveLock",
      "signature": "public void exclusiveLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "stampedLock.writeLock",
        "size",
        "compareAndSet",
        "get",
        "writeLock",
        "readersStateList.toArray",
        "readersStateList.size",
        "set",
        "Thread.yield",
        "yield",
        "toArray",
        "readersStateArrayRef.get",
        "readerState.get",
        "readersStateArrayRef.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 45,
      "source_code": "        // Try to acquire the lock in write-mode \n        stampedLock.writeLock();\n        \n        // We can only do this after writerOwner has been set to the current thread\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            while (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                Thread.yield();\n            }\n        }\n    }",
      "line_number": 332,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveUnlock",
      "signature": "public void exclusiveUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock",
        "unlock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.isWriteLocked",
        "unlock",
        "stampedLock.asWriteLock",
        "IllegalMonitorStateException",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "singleton_pattern"
      ],
      "complexity_score": 34,
      "source_code": "        if (!stampedLock.isWriteLocked()) {\n            // ERROR: tried to unlock a non write-locked instance\n            throw new IllegalMonitorStateException();\n        }\n           \n        stampedLock.asWriteLock().unlock();\n    }",
      "line_number": 368,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLock",
      "signature": "public boolean sharedTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "entry.get",
        "stampedLock.isWriteLocked",
        "get",
        "currentReadersState.set",
        "set",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 42,
      "source_code": "        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }       \n        \n        final AtomicInteger currentReadersState = localEntry.state;\n        currentReadersState.set(SRWL_STATE_READING);\n        if (!stampedLock.isWriteLocked()) {\n            // Acquired lock in read-only mode\n            return true;\n        } else {\n            // Go back to SRWL_STATE_NOT_READING and quit\n            currentReadersState.set(SRWL_STATE_NOT_READING);\n            return false;\n        }        \n    }",
      "line_number": 392,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLockNanos",
      "signature": "public boolean sharedTryLockNanos(long nanosTimeout) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "AtomicInteger",
        "Lock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "entry.get",
        "stampedLock.isWriteLocked",
        "get",
        "currentReadersState.set",
        "set",
        "Thread.yield",
        "yield",
        "isWriteLocked",
        "System.nanoTime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 54,
      "source_code": "        final long lastTime = System.nanoTime();   \n        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        \n        final AtomicInteger currentReadersState = localEntry.state;        \n        while (true) {\n            currentReadersState.set(SRWL_STATE_READING);\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return true;\n            } else {\n                // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer\n                // and then check if this is a downgrade.\n                currentReadersState.set(SRWL_STATE_NOT_READING); \n                           \n                if (nanosTimeout <= 0) return false;\n                if (System.nanoTime() - lastTime < nanosTimeout) {\n                    Thread.yield();\n                } else {\n                    return false;\n                }                \n            }\n        }        \n    }",
      "line_number": 433,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLock",
      "signature": "public boolean exclusiveTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "unlock",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "size",
        "compareAndSet",
        "asWriteLock",
        "stampedLock.asWriteLock",
        "unlock",
        "get",
        "readersStateList.toArray",
        "readersStateList.size",
        "stampedLock.tryWriteLock",
        "set",
        "toArray",
        "readersStateArrayRef.get",
        "tryWriteLock",
        "readerState.get",
        "readersStateArrayRef.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 59,
      "source_code": "        // Try to acquire the lock in write-mode \n        if (stampedLock.tryWriteLock() == 0) {\n            return false;\n        }\n            \n        // We can only do this after writerOwner has been set to the current thread\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            if (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                // There is at least one ongoing Reader so give up\n                stampedLock.asWriteLock().unlock();\n                return false;\n            }\n        }        \n              \n        return true;\n    }",
      "line_number": 484,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLockNanos",
      "signature": "public boolean exclusiveTryLockNanos(long nanosTimeout) throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/ScalableRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Condition",
        "compareAndSet",
        "AtomicInteger",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "readersStateList.toArray",
        "stampedLock.tryWriteLock",
        "Thread.yield",
        "readersStateArrayRef.set",
        "compareAndSet",
        "stampedLock.asWriteLock",
        "readersStateList.size",
        "set",
        "readersStateArrayRef.compareAndSet",
        "asWriteLock",
        "get",
        "toArray",
        "readersStateArrayRef.get",
        "tryWriteLock",
        "System.nanoTime",
        "nanoTime",
        "size",
        "unlock",
        "yield",
        "readerState.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "reader_writer_lock",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 64,
      "source_code": "        final long lastTime = System.nanoTime();\n        // Try to acquire the lock in write-mode \n        if (stampedLock.tryWriteLock(nanosTimeout, TimeUnit.NANOSECONDS) == 0) {\n            return false;\n        }\n        \n        // We can only do this after writerOwner has been set to the current thread\n        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }         \n        \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            while (readerState != null && readerState.get() == SRWL_STATE_READING) {\n                if (System.nanoTime() - lastTime < nanosTimeout) {\n                    Thread.yield();\n                } else { \n                    // Time has expired and there is at least one ongoing Reader so give up\n                    stampedLock.asWriteLock().unlock();\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }",
      "line_number": 546,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "ScalableRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { sharedLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 108,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { sharedUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 109,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return sharedTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 110,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                      \n        }",
      "line_number": 116,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }\t    \t    ",
      "line_number": 120,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() { exclusiveLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() { exclusiveUnlock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "",
      "line_number": 132,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() { return exclusiveTryLock(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 133,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();                     \n        }        ",
      "line_number": 139,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "            // Not supported\n            throw new UnsupportedOperationException();           \n        }               ",
      "line_number": 143,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "LongAdderRWLock",
      "signature": "public LongAdderRWLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "InnerWriteLock",
        "LongAdder",
        "StampedLock",
        "LongAdderRWLock.InnerWriteLock",
        "InnerReadLock",
        "LongAdderRWLock.InnerReadLock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 36,
      "source_code": "        readersIngress = new LongAdder();\n        readersEgress = new LongAdder();\n        stampedLock = new StampedLock();        \n        readerLock = new LongAdderRWLock.InnerReadLock();\n        writerLock = new LongAdderRWLock.InnerWriteLock();\n    }",
      "line_number": 153,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "constructor"
    },
    {
      "name": "readLock",
      "signature": "public Lock readLock() { return readerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 161,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public Lock writeLock() { return writerLock; }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 12,
      "source_code": "",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedLock",
      "signature": "public void sharedLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "Lock",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "stampedLock.isWriteLocked",
        "Thread.yield",
        "yield",
        "increment",
        "isWriteLocked",
        "readersEgress.increment",
        "readersIngress.increment"
      ],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 41,
      "source_code": "        while (true) {\n            readersIngress.increment();\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return;\n            } else {\n                // Rollback logical counter to avoid blocking a Writer\n                readersEgress.increment();\n                // If there is a Writer, wait until it is gone\n                while (stampedLock.isWriteLocked()) {\n                    // TODO: Do something smarter, like spin for a while and then yield()\n                    Thread.yield();\n                }\n            }\n        }        \n    }    ",
      "line_number": 174,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedUnlock",
      "signature": "public void sharedUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "readersEgress.increment",
        "increment"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        readersEgress.increment();\n        return;\n    }",
      "line_number": 196,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveLock",
      "signature": "public void exclusiveLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "stampedLock.writeLock",
        "readersEgress.sum",
        "writeLock",
        "sum",
        "Thread.yield",
        "yield",
        "readersIngress.sum"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 27,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        stampedLock.writeLock(); \n        while (true) {\n            // Order is _very_ important here\n            final long egressSum = readersEgress.sum();\n            final long ingressSum = readersIngress.sum();\n            if (egressSum == ingressSum) return;\n            // TODO: Do something smarter, like spin for a while and then yield()\n            Thread.yield();\n        }\n    }",
      "line_number": 211,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveUnlock",
      "signature": "public void exclusiveUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock",
        "unlock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.isWriteLocked",
        "unlock",
        "stampedLock.asWriteLock",
        "IllegalMonitorStateException",
        "isWriteLocked"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "singleton_pattern"
      ],
      "complexity_score": 34,
      "source_code": "        if (!stampedLock.isWriteLocked()) {\n            // ERROR: tried to unlock a non write-locked instance\n            throw new IllegalMonitorStateException();\n        }\n        stampedLock.asWriteLock().unlock();\n    }",
      "line_number": 234,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLock",
      "signature": "public boolean sharedTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "stampedLock.isWriteLocked",
        "increment",
        "isWriteLocked",
        "readersEgress.increment",
        "readersIngress.increment"
      ],
      "concurrency_patterns": [
        "reader_writer_lock"
      ],
      "complexity_score": 24,
      "source_code": "        readersIngress.increment();\n        if (!stampedLock.isWriteLocked()) {\n            // Acquired lock in read-only mode\n            return true;\n        } else {\n            // Lock can not be acquired right now. Rollback logical counter\n            readersEgress.increment();\n            return false;\n        }         \n    }",
      "line_number": 257,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "sharedTryLockNanos",
      "signature": "public boolean sharedTryLockNanos (long nanosTimeout) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "StampedLock",
        "Lock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "stampedLock.isWriteLocked",
        "Thread.yield",
        "yield",
        "increment",
        "isWriteLocked",
        "System.nanoTime",
        "readersEgress.increment",
        "readersIngress.increment"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 42,
      "source_code": "        final long lastTime = System.nanoTime();\n        while (true) {\n            readersIngress.increment();\n            if (!stampedLock.isWriteLocked()) {\n                // Acquired lock in read-only mode\n                return true;\n            } else {\n                // Rollback logical counter to avoid blocking a Writer\n                readersEgress.increment();\n                // If there is a Writer, we wait\n                while (stampedLock.isWriteLocked()) {      \n                    if (System.nanoTime() - lastTime < nanosTimeout) {\n                        Thread.yield();\n                    } else { \n                        // Time has expired and there is still at least one Reader so give up\n                        return false;\n                    }\n                }\n            }\n        }        \n    }",
      "line_number": 291,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLock",
      "signature": "public boolean exclusiveTryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "asWriteLock",
        "readersEgress.sum",
        "unlock",
        "stampedLock.asWriteLock",
        "sum",
        "stampedLock.tryWriteLock",
        "tryWriteLock",
        "readersIngress.sum"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 37,
      "source_code": "        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock() == 0) {\n            return false;\n        }\n        // Order is _very_ important here\n        final long egressSum = readersEgress.sum();\n        final long ingressSum = readersIngress.sum();\n        if (egressSum == ingressSum) {\n            return true;\n        } // else\n        stampedLock.asWriteLock().unlock();\n        return false;\n    }",
      "line_number": 330,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "exclusiveTryLockNanos",
      "signature": "public boolean exclusiveTryLockNanos(long nanosTimeout) throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "nanoTime",
        "asWriteLock",
        "readersEgress.sum",
        "unlock",
        "stampedLock.asWriteLock",
        "sum",
        "stampedLock.tryWriteLock",
        "Thread.yield",
        "yield",
        "tryWriteLock",
        "System.nanoTime",
        "readersIngress.sum"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object"
      ],
      "complexity_score": 43,
      "source_code": "        final long lastTime = System.nanoTime();\n        // Try to acquire the stampedLock in write-mode \n        if (stampedLock.tryWriteLock(nanosTimeout, TimeUnit.NANOSECONDS) == 0) {\n            return false;\n        }\n\n        while (true) {\n            // Order is _very_ important here\n            final long egressSum = readersEgress.sum();\n            final long ingressSum = readersIngress.sum();\n            if (egressSum == ingressSum) return true;\n            if (System.nanoTime() - lastTime < nanosTimeout) {\n                Thread.yield();\n            } else { \n                // Time has expired and there is still at least one Reader so give up\n                stampedLock.asWriteLock().unlock();\n                return false;\n            }  \n        }\n    }",
      "line_number": 380,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "tryOptimisticRead",
      "signature": "public long tryOptimisticRead() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "tryOptimisticRead",
        "stampedLock.tryOptimisticRead"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        return stampedLock.tryOptimisticRead();\n    }",
      "line_number": 409,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "validate",
      "signature": "public boolean validate(long stamp) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/LongAdderRWLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "StampedLock",
        "lock"
      ],
      "dependencies": [
        "validate",
        "stampedLock.validate"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        return stampedLock.validate(stamp);\n    }    ",
      "line_number": 425,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "LongAdderRWLock",
      "method_type": "method"
    },
    {
      "name": "LRTreeSetGT",
      "signature": "public LRTreeSetGT() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetGT.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong"
      ],
      "dependencies": [
        "AtomicLong",
        "TreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        leftTree = new TreeSet<E>();\n        rightTree = new TreeSet<E>();\n        leftRight = new AtomicLong(READS_ON_LEFT);\n    }",
      "line_number": 68,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetGT",
      "method_type": "constructor"
    },
    {
      "name": "arrive",
      "signature": "private long arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetGT.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "startEpoch.getAndIncrement",
        "getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return startEpoch.getAndIncrement();\n    }",
      "line_number": 80,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LRTreeSetGT",
      "method_type": "method"
    },
    {
      "name": "depart",
      "signature": "private void depart(final long localVI) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetGT.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement",
        "final"
      ],
      "dependencies": [
        "getAndIncrement",
        "posEndEpoch.getAndIncrement",
        "negEndEpoch.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (localVI < 0) {\n            negEndEpoch.getAndIncrement();\n        } else {\n            posEndEpoch.getAndIncrement();\n        }\n    }",
      "line_number": 91,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LRTreeSetGT",
      "method_type": "method"
    },
    {
      "name": "toggleVersionAndScan",
      "signature": "private void toggleVersionAndScan() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetGT.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "wait",
        "Thread",
        "getAndSet"
      ],
      "dependencies": [
        "startEpoch.getAndSet",
        "negEndEpoch.get",
        "posEndEpoch.set",
        "get",
        "set",
        "Thread.yield",
        "yield",
        "getAndSet",
        "posEndEpoch.get",
        "startEpoch.get",
        "negEndEpoch.set"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final long localVI = startEpoch.get();\n        if (localVI < 0) {\n            // This version is negative, so next versionIndex is positive. \n            // Reset counter\n            posEndEpoch.set(0);\n            // Toggle versionIndex and count the number of arrives()\n            final long localStartValue = startEpoch.getAndSet(0);\n            // Wait for the readers that did arrive() with a negative versionIndex to depart()\n            while (localStartValue != negEndEpoch.get()) Thread.yield();\n        } else {\n            // This version is positive, so next versionIndex is negative. \n            // Reset counter\n            negEndEpoch.set(Long.MIN_VALUE);\n            // Toggle versionIndex and count the number of arrives()\n            final long localStartValue = startEpoch.getAndSet(Long.MIN_VALUE);\n            // Wait for the readers that did arrive() with a positive versionIndex to depart()\n            while (localStartValue != posEndEpoch.get()) Thread.yield();\n        }\n    }",
      "line_number": 106,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetGT",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetGT.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "TreeSet.contains",
        "contains",
        "leftTree.contains",
        "leftRight.get",
        "get",
        "rightTree.contains"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final long localVI = arrive();\n        try {\n            // Read the up-to-date value of leftRight.\n            if (leftRight.get() == READS_ON_LEFT) {\n                return leftTree.contains(elem);\n            } else {\n                return rightTree.contains(elem);\n            }\n        } finally {\n            // In the extreme event that TreeSet.contains() throws an exception, \n            // we want to make sure that no Writer is left hanging.\n            depart(localVI);\n        }\n    }",
      "line_number": 134,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetGT",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public synchronized boolean add(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetGT.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "add",
        "leftRight.set",
        "leftRight.get",
        "get",
        "set",
        "leftTree.add",
        "rightTree.add"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        final long localLeftRight = leftRight.get();\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.add(elem);\n        } else {\n            retValue = leftTree.add(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        toggleVersionAndScan();\n\n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.add(elem);\n        } else {\n            leftTree.add(elem);\n        }\n\n        return retValue;\n    }",
      "line_number": 159,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetGT",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public synchronized boolean remove(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetGT.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "leftRight.set",
        "leftRight.get",
        "get",
        "rightTree.remove",
        "set",
        "leftTree.remove",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        final long localLeftRight = leftRight.get();\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.remove(elem);\n        } else {\n            retValue = leftTree.remove(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        toggleVersionAndScan();\n\n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.remove(elem);\n        } else {\n            leftTree.remove(elem);\n        }\n\n        return retValue;\n    }",
      "line_number": 198,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetGT",
      "method_type": "method"
    },
    {
      "name": "LRTreeSetDCNV",
      "signature": "public LRTreeSetDCNV() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetDCNV.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "TreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        leftTree = new TreeSet<E>();\n        rightTree = new TreeSet<E>();\n    }",
      "line_number": 73,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetDCNV",
      "method_type": "constructor"
    },
    {
      "name": "getLeftRight",
      "signature": "private int getLeftRight(long localLeftRightIngress) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetDCNV.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return (localLeftRightIngress >= 0) ? READS_ON_LEFT : READS_ON_RIGHT;\n    }",
      "line_number": 78,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "LRTreeSetDCNV",
      "method_type": "method"
    },
    {
      "name": "arrive",
      "signature": "private int arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetDCNV.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "getAndIncrement",
        "leftRightIngress.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return getLeftRight(leftRightIngress.getAndIncrement());\n    }",
      "line_number": 89,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LRTreeSetDCNV",
      "method_type": "method"
    },
    {
      "name": "toggleVersionAndWait",
      "signature": "private void toggleVersionAndWait() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetDCNV.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "wait",
        "Thread",
        "getAndSet"
      ],
      "dependencies": [
        "rightEgress.sum",
        "leftRightIngress.getAndSet",
        "leftRightIngress.get",
        "reset",
        "get",
        "leftEgress.sum",
        "sum",
        "Thread.yield",
        "yield",
        "getAndSet",
        "rightEgress.reset",
        "leftEgress.reset"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        final int localLeftRight = getLeftRight(leftRightIngress.get());\n        if (localLeftRight == READS_ON_LEFT) {\n            rightEgress.reset();\n            // Toggle leftRight and count the number of arrives()\n            final long lri = leftRightIngress.getAndSet(Long.MIN_VALUE);\n            // Wait for the corresponding readers that did arrive()\n            while (lri != leftEgress.sum()) Thread.yield();\n        } else {\n            leftEgress.reset();\n            final long lri = leftRightIngress.getAndSet(0);\n            while (lri+Long.MIN_VALUE != rightEgress.sum()) Thread.yield();\n        }\n    }",
      "line_number": 117,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetDCNV",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetDCNV.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "TreeSet.contains",
        "contains",
        "rightTree.contains",
        "leftTree.contains"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final int localLeftRight = arrive();\n        try {\n            if (localLeftRight == READS_ON_LEFT) {\n                return leftTree.contains(elem);\n            } else {\n                return rightTree.contains(elem);\n            }\n        } finally {\n            // In the extreme event that TreeSet.contains() throws an exception, \n            // we want to make sure that no Writer is left hanging.\n            depart(localLeftRight);\n        }\n    }",
      "line_number": 139,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetDCNV",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public synchronized boolean add(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetDCNV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "add",
        "leftRightIngress.get",
        "get",
        "leftTree.add",
        "rightTree.add"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        final int localLeftRight = getLeftRight(leftRightIngress.get());\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.add(elem);\n        } else {\n            retValue = leftTree.add(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        toggleVersionAndWait();\n\n        if (localLeftRight == READS_ON_LEFT) {\n            leftTree.add(elem);\n        } else {\n            rightTree.add(elem);\n        }\n\n        return retValue;\n    }",
      "line_number": 163,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetDCNV",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public synchronized boolean remove(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetDCNV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "leftRightIngress.get",
        "get",
        "rightTree.remove",
        "leftTree.remove",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        final int localLeftRight = getLeftRight(leftRightIngress.get());\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.remove(elem);\n        } else {\n            retValue = leftTree.remove(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        toggleVersionAndWait();\n\n        if (localLeftRight == READS_ON_LEFT) {\n            leftTree.remove(elem);\n        } else {\n            rightTree.remove(elem);\n        }\n\n        return retValue;\n    }",
      "line_number": 201,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetDCNV",
      "method_type": "method"
    },
    {
      "name": "InnerDCLC",
      "signature": "public InnerDCLC(long value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "counters.set",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            for (int idx = 0; idx < kNumCounters*COUNTER_CACHE_LINE; idx += COUNTER_CACHE_LINE) {\n                counters.set(idx, value);\n            }\n        }",
      "line_number": 80,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "tid2hash",
      "signature": "private int tid2hash() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            long x = Thread.currentThread().getId();\n            x ^= (x << 21);\n            x ^= (x >>> 35);\n            x ^= (x << 4);\n            final int idx = (int)(((kNumCounters-1) & x)*COUNTER_CACHE_LINE);\n            return idx;\n        }",
      "line_number": 86,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "getAndIncrement",
      "signature": "public long getAndIncrement() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "getAndIncrement",
        "counters.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return counters.getAndIncrement(tid2hash());\n        }",
      "line_number": 99,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "counters.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "            long sum = 0;\n            // Let's start by checking if the versionIndex is positive or negative\n            if (counters.get(0) < 0) {\n                for (int idx = 0; idx < kNumCounters*COUNTER_CACHE_LINE; idx += COUNTER_CACHE_LINE) {\n                    sum += (counters.get(idx) - Long.MIN_VALUE);\n                }\n                return Long.MIN_VALUE + sum;\n            } else {\n                for (int idx = 0; idx < kNumCounters*COUNTER_CACHE_LINE; idx += COUNTER_CACHE_LINE) {\n                    sum += counters.get(idx);\n                }\n                return sum;            \n            }\n        }",
      "line_number": 103,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "set",
      "signature": "public void set(long value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "counters.set",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "            for (int idx = 0; idx < kNumCounters*COUNTER_CACHE_LINE; idx += COUNTER_CACHE_LINE) {\n                counters.set(idx, value); \n            }\n        }    ",
      "line_number": 119,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "getAndSet",
      "signature": "public long getAndSet(long value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "getAndSet"
      ],
      "dependencies": [
        "get",
        "counters.get",
        "counters.getAndSet",
        "getAndSet"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "            long sum = 0;\n            // Let's start by checking if the versionIndex is positive or negative\n            if (counters.get(0) < 0) {\n                for (int idx = 0; idx < kNumCounters*COUNTER_CACHE_LINE; idx += COUNTER_CACHE_LINE) {\n                    sum += (counters.getAndSet(idx, value) - Long.MIN_VALUE);\n                }\n                return Long.MIN_VALUE + sum;\n            } else {\n                for (int idx = 0; idx < kNumCounters*COUNTER_CACHE_LINE; idx += COUNTER_CACHE_LINE) {\n                    sum += counters.getAndSet(idx, value);\n                }\n                return sum;            \n            }\n        }",
      "line_number": 129,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "LRTreeSetScalableGT",
      "signature": "public LRTreeSetScalableGT() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong"
      ],
      "dependencies": [
        "AtomicLong",
        "TreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        leftTree = new TreeSet<E>();\n        rightTree = new TreeSet<E>();\n        leftRight = new AtomicLong(READS_ON_LEFT);\n    }",
      "line_number": 151,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "constructor"
    },
    {
      "name": "arrive",
      "signature": "private long arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "startEpoch.getAndIncrement",
        "getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return startEpoch.getAndIncrement();\n    }",
      "line_number": 163,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "depart",
      "signature": "private void depart(final long localVI) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement",
        "final"
      ],
      "dependencies": [
        "getAndIncrement",
        "posEndEpoch.getAndIncrement",
        "negEndEpoch.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        if (localVI < 0) {\n            negEndEpoch.getAndIncrement();\n        } else {\n            posEndEpoch.getAndIncrement();\n        }\n    }",
      "line_number": 174,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "toggleVersionAndScan",
      "signature": "private void toggleVersionAndScan() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "wait",
        "Thread",
        "getAndSet"
      ],
      "dependencies": [
        "startEpoch.getAndSet",
        "posEndEpoch.set",
        "negEndEpoch.sum",
        "sum",
        "set",
        "Thread.yield",
        "yield",
        "getAndSet",
        "posEndEpoch.sum",
        "negEndEpoch.set",
        "startEpoch.sum"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final long localVI = startEpoch.sum();\n        if (localVI < 0) {\n            // This version is negative, so next versionIndex is positive. \n            // Reset counter\n            posEndEpoch.set(0);\n            // Toggle versionIndex and count the number of arrives()\n            final long localStartValue = startEpoch.getAndSet(0);\n            // Wait for the readers that did arrive() with a negative versionIndex to depart()\n            while (localStartValue != negEndEpoch.sum()) Thread.yield();\n        } else {\n            // This version is positive, so next versionIndex is negative. \n            // Reset counter\n            negEndEpoch.set(Long.MIN_VALUE);\n            // Toggle versionIndex and count the number of arrives()\n            final long localStartValue = startEpoch.getAndSet(Long.MIN_VALUE);\n            // Wait for the readers that did arrive() with a positive versionIndex to depart()\n            while (localStartValue != posEndEpoch.sum()) Thread.yield();\n        }\n    }",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "TreeSet.contains",
        "contains",
        "leftTree.contains",
        "leftRight.get",
        "get",
        "rightTree.contains"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final long localVI = arrive();\n        try {\n            // Read the up-to-date value of leftRight.\n            if (leftRight.get() == READS_ON_LEFT) {\n                return leftTree.contains(elem);\n            } else {\n                return rightTree.contains(elem);\n            }\n        } finally {\n            // In the extreme event that TreeSet.contains() throws an exception, \n            // we want to make sure that no Writer is left hanging.\n            depart(localVI);\n        }\n    }",
      "line_number": 216,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public synchronized boolean add(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "add",
        "leftRight.set",
        "leftRight.get",
        "get",
        "set",
        "leftTree.add",
        "rightTree.add"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        final long localLeftRight = leftRight.get();\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.add(elem);\n        } else {\n            retValue = leftTree.add(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        toggleVersionAndScan();\n\n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.add(elem);\n        } else {\n            leftTree.add(elem);\n        }\n\n        return retValue;\n    }",
      "line_number": 241,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public synchronized boolean remove(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/experimental/LRTreeSetScalableGT.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "leftRight.set",
        "leftRight.get",
        "get",
        "rightTree.remove",
        "set",
        "leftTree.remove",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        final long localLeftRight = leftRight.get();\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.remove(elem);\n        } else {\n            retValue = leftTree.remove(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        toggleVersionAndScan();\n\n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.remove(elem);\n        } else {\n            leftTree.remove(elem);\n        }\n\n        return retValue;\n    }    ",
      "line_number": 280,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRTreeSetScalableGT",
      "method_type": "method"
    },
    {
      "name": "RIStaticPerThread",
      "signature": "public RIStaticPerThread(int maxNumThreads) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIStaticPerThread.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "AtomicIntegerArray",
        "AtomicInteger"
      ],
      "dependencies": [
        "AtomicIntegerArray"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern"
      ],
      "complexity_score": 16,
      "source_code": "        this.maxNumThreads = maxNumThreads;\n        this.perThreadState = new AtomicIntegerArray(maxNumThreads);\n    }",
      "line_number": 39,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "RIStaticPerThread",
      "method_type": "constructor"
    },
    {
      "name": "arrive",
      "signature": "public void arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIStaticPerThread.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "perThreadState.set",
        "Thread.currentThread",
        "set"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        perThreadState.set((int)Thread.currentThread().getId(), STATE_READING);\n    }",
      "line_number": 45,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIStaticPerThread",
      "method_type": "method"
    },
    {
      "name": "depart",
      "signature": "public void depart() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIStaticPerThread.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "perThreadState.set",
        "Thread.currentThread",
        "set"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        perThreadState.set((int)Thread.currentThread().getId(), STATE_NOT_READING);\n    }",
      "line_number": 50,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIStaticPerThread",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIStaticPerThread.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "get",
        "perThreadState.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        for (int tid = 0; tid < maxNumThreads; tid++) {\n            if (perThreadState.get(tid) == STATE_READING) return false;\n        }\n        return true;\n    }",
      "line_number": 55,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "RIStaticPerThread",
      "method_type": "method"
    },
    {
      "name": "byteOffset",
      "signature": "private static long byteOffset(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIDistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ((long) i << shift) + base;\n    }",
      "line_number": 67,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIDistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "tid2hash",
      "signature": "private int tid2hash() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIDistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        long x = Thread.currentThread().getId();\n        x ^= (x << 21);\n        x ^= (x >>> 35);\n        x ^= (x << 4);\n        final int idx = (int)(((numCounters-1) & x)*CACHE_LINE);\n        return idx;\n    }",
      "line_number": 75,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIDistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "RIDistributedCacheLineCounter",
      "signature": "public RIDistributedCacheLineCounter() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIDistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Integer.highestOneBit",
        "availableProcessors",
        "Runtime.getRuntime",
        "highestOneBit",
        "getRuntime"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this.numCounters = Integer.highestOneBit(Runtime.getRuntime().availableProcessors()) << 1;\n        counters = new long[this.numCounters*CACHE_LINE];\n    }",
      "line_number": 97,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "RIDistributedCacheLineCounter",
      "method_type": "constructor"
    },
    {
      "name": "arrive",
      "signature": "public void arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIDistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [
        "getAndAddLong",
        "UNSAFE.getAndAddLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.getAndAddLong(counters, byteOffset(tid2hash()), 1);\n    }",
      "line_number": 109,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIDistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "depart",
      "signature": "public void depart() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIDistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [
        "getAndAddLong",
        "UNSAFE.getAndAddLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.getAndAddLong(counters, byteOffset(tid2hash()), -1);\n    }",
      "line_number": 119,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIDistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIDistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.loadFence",
        "loadFence"
      ],
      "concurrency_patterns": [],
      "complexity_score": 5,
      "source_code": "        long sum = aVolatileLoad;\n        for (int idx = 0; idx < numCounters*CACHE_LINE; idx += CACHE_LINE) {\n            sum += counters[idx]; \n        }\n        UNSAFE.loadFence();\n        return sum == 0;\n    }",
      "line_number": 133,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "RIDistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "arrive",
      "signature": "public void arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIThreadCLQ.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "clq.add",
        "add",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        clq.add(Thread.currentThread());\n    }",
      "line_number": 51,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "RIThreadCLQ",
      "method_type": "method"
    },
    {
      "name": "depart",
      "signature": "public void depart() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIThreadCLQ.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "clq.remove",
        "currentThread",
        "remove",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        clq.remove(Thread.currentThread());\n    }",
      "line_number": 56,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "RIThreadCLQ",
      "method_type": "method"
    },
    {
      "name": "arrive",
      "signature": "public void arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIAtomicCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "getAndIncrement",
        "counter.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        counter.getAndIncrement();\n    }",
      "line_number": 54,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "RIAtomicCounter",
      "method_type": "method"
    },
    {
      "name": "depart",
      "signature": "public void depart() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIAtomicCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndDecrement"
      ],
      "dependencies": [
        "counter.getAndDecrement",
        "getAndDecrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        counter.getAndDecrement();\n    }",
      "line_number": 59,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "RIAtomicCounter",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIAtomicCounter.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "counter.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return counter.get() == 0;\n    }",
      "line_number": 64,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "RIAtomicCounter",
      "method_type": "method"
    },
    {
      "name": "RIArrayCLQFinalizers",
      "signature": "public RIArrayCLQFinalizers() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReference",
        "AtomicInteger",
        "ConcurrentLinkedQueue",
        "final",
        "Thread",
        "ThreadLocal"
      ],
      "dependencies": [
        "AtomicReference",
        "AtomicInteger",
        "ReadersEntry",
        "ConcurrentLinkedQueue",
        "ThreadLocal"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        readersStateList = new ConcurrentLinkedQueue<AtomicInteger>();\n        entry = new ThreadLocal<ReadersEntry>();        \n        readersStateArrayRef = new AtomicReference<AtomicInteger[]>(null);\n    }",
      "line_number": 67,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "constructor"
    },
    {
      "name": "arrive",
      "signature": "public void arrive() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "get",
        "state.set",
        "entry.get",
        "set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        ReadersEntry localEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localEntry == null) {\n            localEntry = addState();      \n        }\n        localEntry.state.set(STATE_READING);\n    }",
      "line_number": 74,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "method"
    },
    {
      "name": "depart",
      "signature": "public void depart() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "state.set",
        "entry.get",
        "set"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        entry.get().state.set(STATE_NOT_READING);\n    }",
      "line_number": 84,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "compareAndSet",
        "AtomicInteger"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "size",
        "compareAndSet",
        "get",
        "readersStateList.toArray",
        "readersStateList.size",
        "set",
        "toArray",
        "readersStateArrayRef.get",
        "readerState.get",
        "readersStateArrayRef.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateList to impose\n            // a linearizability condition\n            readersStateArrayRef.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);            \n        }                 \n        // Scan the array of Reader states\n        for (AtomicInteger readerState : localReadersStateArray) {\n            while (readerState != null && readerState.get() == STATE_READING) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "line_number": 89,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "method"
    },
    {
      "name": "ReadersEntry",
      "signature": "public ReadersEntry(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [
        "AtomicInteger"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 6,
      "source_code": "            this.state = state;         \n        }",
      "line_number": 115,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "method"
    },
    {
      "name": "finalize",
      "signature": "protected void finalize() throws Throwable {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "super.finalize",
        "finalize"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            removeState(state);\n            super.finalize();\n        }",
      "line_number": 118,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "method"
    },
    {
      "name": "removeState",
      "signature": "protected void removeState(AtomicInteger state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicInteger",
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "state.set",
        "remove",
        "set",
        "readersStateList.remove"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        readersStateList.remove(state);\n        // Setting the readersStateArrayRef to null will make the Writer\n        // rebuild the array from the CLQ.\n        readersStateArrayRef.set(null);        \n        // Paranoia: just in case someone forgot to call sharedUnlock()\n        // and there is a Writer waiting on that state.\n        state.set(STATE_NOT_READING);\n    }",
      "line_number": 129,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "method"
    },
    {
      "name": "addState",
      "signature": "private ReadersEntry addState() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/readindicators/RIArrayCLQFinalizers.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicInteger"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "readersStateList.add",
        "add",
        "AtomicInteger",
        "ReadersEntry",
        "entry.set",
        "set"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "        final AtomicInteger state = new AtomicInteger(STATE_NOT_READING);\n        final ReadersEntry newEntry = new ReadersEntry(state); \n        entry.set(newEntry);\n        readersStateList.add(state);\n        // Setting the readersStateArrayRef to null will make the Writer\n        // rebuild the array from the CLQ.\n        readersStateArrayRef.set(null);\n        return newEntry;\n    }",
      "line_number": 147,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "RIArrayCLQFinalizers",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisRTTILinkedList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "HarrisRTTILinkedList",
      "method_type": "method"
    },
    {
      "name": "insert",
      "signature": "public boolean insert(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisRTTILinkedList.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "casNext",
        "NodeUnmarked",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        final NodeUnmarked<E> newNode = new NodeUnmarked<E>(key);\n        Node<E> leftNode[] = new Node[1];\n\n        while (true) {\n            final Node<E> rightNode = search(key, leftNode);\n            \n            if (rightNode != tail && rightNode.key == key) // T1\n                return false;\n            newNode.next = rightNode;\n            newNode.nodeMk.next = rightNode;\n            if (leftNode[0].casNext(rightNode, newNode)) // C2\n            {\n                return true;\n            }\n        } // B3        \n    }",
      "line_number": 133,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "HarrisRTTILinkedList",
      "method_type": "method"
    },
    {
      "name": "delete",
      "signature": "public boolean delete(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisRTTILinkedList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "casNext",
        "rightNode.casNext",
        "E"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 9,
      "source_code": "        Node<E> rightNode; \n        Node<E> rightNodeNext;\n        Node<E> leftNode[] = new Node[1];\n        while (true) {\n            rightNode = search(key, leftNode);\n            if ((rightNode == tail) || (rightNode.key != key)) { // T1\n                return false;\n            }\n            rightNodeNext = rightNode.next;\n            \n            if (rightNodeNext instanceof NodeUnmarked){\n                if (rightNode.casNext(rightNodeNext, ((NodeUnmarked<E>)rightNodeNext).nodeMk)){\n                    break;\n                }\n            }\n        } // B4\n        \n        if (!leftNode[0].casNext(rightNode, rightNodeNext)) // C4\n        {\n            rightNode = search(rightNode.key, leftNode);\n        }\n        return true;\n    }",
      "line_number": 157,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "HarrisRTTILinkedList",
      "method_type": "method"
    },
    {
      "name": "search",
      "signature": "private Node<E> search(E key, Node<E> leftNode[]) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisRTTILinkedList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareTo",
        "E",
        "casNext",
        "keyComp.compareTo"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 15,
      "source_code": "        Node<E> rightNode;\n        Node<E> leftNodeNext = null;\n        \n        searchAgain:\n        while (true) {\n            Node<E> t = head;\n            Node<E> tnext = head.next;\n            \n            @SuppressWarnings(\"unchecked\")\n            Comparable<? super E> keyComp = (Comparable<? super E>) key;         \n            // 1: find leftNode and rightNode\n            do {\n                if (tnext instanceof NodeUnmarked) {\n                    leftNode[0] = t;\n                    leftNodeNext = tnext;\n                    t = tnext;\n                } else {\n                    t = ((NodeMarked<E>)tnext).nodeUn;\n                }\n                if (t == tail) {\n                    break;\n                }\n                tnext = t.next;\n            } while ((tnext instanceof NodeMarked) || keyComp.compareTo(t.key) > 0);\n            rightNode = t;\n            \n            // 2: Check nodes are adjacent\n            if (leftNodeNext == rightNode) {\n                if (rightNode != tail && rightNode.next instanceof NodeMarked) {\n                    continue searchAgain; // G1\n                } else { \n                    return rightNode; // R1\n                }\n            }\n            \n            // 3: Remove one or more marked nodes\n            if (leftNode[0].casNext(leftNodeNext, rightNode)) // C1\n                if (rightNode != tail && rightNode.next instanceof NodeMarked) {\n                    continue searchAgain; // G2\n                } else { \n                    return rightNode; // R2\n                }\n        } // B2\n    }",
      "line_number": 196,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "HarrisRTTILinkedList",
      "method_type": "method"
    },
    {
      "name": "markRemoved",
      "signature": "boolean markRemoved() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapInt",
        "compareAndSwapInt"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapInt(this, stateOffset, INUSE, REMOVED);\n        }",
      "line_number": 155,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 175,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "CLLElectedUnlinkVolatile",
      "signature": "public CLLElectedUnlinkVolatile() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "Node",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "        unlinkGuard  = NO_GUARD;\n        unlinkNeeded = NO_NEED;\n        // Start with the head and tail having a sentinel node\n        head = tail = new Node<E>(null);\n    }",
      "line_number": 206,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "constructor"
    },
    {
      "name": "add",
      "signature": "public boolean add(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "casNext",
        "Node",
        "E",
        "localTail.casNext"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 10,
      "source_code": "        checkNotNull(item);\n        final Node<E> newNode = new Node<E>(item);\n        while (true) {\n            final Node<E> localTail = tail;\n            final Node<E> node = localTail.next;\n            if (localTail == tail) {\n                if (node == null) {\n                    // It seems this is the last node, so add the newNode here \n                    // and try to move the tail to the newNode\n                    if (localTail.casNext(null, newNode)) {\n                        casTail(localTail, newNode); // Failure is OK.\n                        return true;\n                    }\n                } else {\n                    casTail(localTail, node);\n                }\n            }\n        }\n    }",
      "line_number": 221,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "item.equals",
        "E",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "        if (item == null) return false;\n        Node<E> node = head;\n        while (node != null) {\n            if (item.equals(node.item) && node.state == INUSE) {\n                return true;\n            }\n            node = node.next;\n        }\n        return false;\n    }",
      "line_number": 252,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        checkNotNull(item);\n        if (unlinkGuard == NO_GUARD && casUnlinkGuard(NO_GUARD, GUARDED)) {\n            try {\n                // We got the hold on the guard, now figure out if unlinking is\n                // needed for other nodes or just this one.\n                if (unlinkNeeded == NEED_UNLINK) {\n                    return markOneAndUnlinkAll(item);               \n                } else {\n                    return markAndUnlinkOne(item);\n                }\n            } finally {\n                unlinkGuard = NO_GUARD;\n            }\n        } else {\n            // Didn't get the hold of the guard, so mark the node and don't\n            // do any unlinking.\n            return markNode(item);\n        }\n    }",
      "line_number": 277,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "markOneAndUnlinkAll",
      "signature": "private boolean markOneAndUnlinkAll(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "item.equals",
        "node.markRemoved",
        "markRemoved",
        "equals",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 21,
      "source_code": "        casUnlinkNeeded(NEED_UNLINK, NO_GUARD); \n        Node<E> node = head;\n        Node<E> lastInUse = head;\n        final Node<E> localTail = tail;\n        boolean doUnlinking = true; // Turns to false once the localTail has been reached\n        boolean nodeWasMarked = false;\n        \n        // Lets loop first to advance the head if needed\n        while (head.state == REMOVED) {\n            Node<E> headNext = head.next; \n            if (headNext == null) return false;\n            head = headNext;\n        }\n        node = head;\n        \n        while (node != null) {\n            // We do the order here differently and read the value of \"state\"\n            // before looking at the key.\n            if (!nodeWasMarked && node.state == INUSE && item.equals(node.item) && node.markRemoved()) {\n                // We've marked the node, but instead of returning true \n                // immediately, we continue to search the linked list for \n                // nodes that need to be unlinked.\n                nodeWasMarked = true;\n                // Unlink only if it is not the last node nor the first\n                if (lastInUse != head && node.next != null) {\n                    lastInUse.next = node.next;\n                }\n            }            \n            // Once the tail has been found, don't do any more unlinking \n            if (node == localTail) doUnlinking = false;\n            // Optimization: If the tail has been reached and the item has been \n            // found, then we can return true immediately.\n            if (!doUnlinking && nodeWasMarked) return true;\n            if (doUnlinking) {\n                if (node.state == INUSE) {\n                    lastInUse = node;\n                } else {\n                    lastInUse.next = node.next;\n                }\n            }\n            node = node.next;            \n        }            \n        return nodeWasMarked;\n    }",
      "line_number": 310,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "markAndUnlinkOne",
      "signature": "private boolean markAndUnlinkOne(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "item.equals",
        "node.markRemoved",
        "markRemoved",
        "equals",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        Node<E> node = head;\n        Node<E> prev = head;\n        while (node != null) {\n            if (item.equals(node.item) && node.state == INUSE) {\n                if (node.markRemoved()) {\n                    if (node == head && node.next != null) {\n                        // Removed node was \"head\" so try to advance it\n                        casHead(node, node.next);\n                    } else if (node.next != null) {\n                        // Unlink only if it is not the last node\n                        prev.next = node.next;\n                    } \n                    return true;\n                }\n            }\n            prev = node;\n            node = node.next;            \n        }            \n        return false;\n    }",
      "line_number": 373,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "markNode",
      "signature": "private boolean markNode(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "item.equals",
        "node.markRemoved",
        "markRemoved",
        "equals",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "        Node<E> node = head;\n        while (node != null) {\n            if (item.equals(node.item) && node.state == INUSE) {\n                if (node.markRemoved()) {\n                    unlinkNeeded = NEED_UNLINK;\n                    return true;\n                }\n            }\n            node = node.next;            \n        }\n        return false;\n    }",
      "line_number": 404,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "checkNotNull",
      "signature": "static void checkNotNull(Object v) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        if (v == null)\n            throw new NullPointerException();\n    }",
      "line_number": 424,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "casUnlinkGuard",
      "signature": "boolean casUnlinkGuard(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, guardOffset, cmp, val);\n    }",
      "line_number": 429,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "casUnlinkNeeded",
      "signature": "boolean casUnlinkNeeded(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, unlinkNeededOffset, cmp, val);\n    }",
      "line_number": 433,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 437,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlinkVolatile.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }    ",
      "line_number": 441,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlinkVolatile",
      "method_type": "method"
    },
    {
      "name": "BenchmarkListRelaxedvsVolatile",
      "signature": "public BenchmarkListRelaxedvsVolatile(int numThreads, int numMilis, CSVDatabase csvdb, int writePerMil) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/BenchmarkListRelaxedvsVolatile.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Thread",
        "ConcurrentLinkedQueue"
      ],
      "dependencies": [
        "clqrel.add",
        "out.println",
        "println",
        "ConcurrentLinkedQueueRelaxed",
        "add",
        "CLLElectedUnlink",
        "UserData",
        "lrLinkedList.add",
        "LRLinkedList",
        "ConcurrentLinkedQueue",
        "CLLElectedUnlinkVolatile",
        "clleu.add",
        "clq.add",
        "clleuvol.add"
      ],
      "concurrency_patterns": [
        "lock_free_algorithm"
      ],
      "complexity_score": 44,
      "source_code": "\n        clleu = new CLLElectedUnlink<UserData>();\n        clleuvol = new CLLElectedUnlinkVolatile<UserData>();\n        clq = new ConcurrentLinkedQueue<UserData>();\n        clqrel = new ConcurrentLinkedQueueRelaxed<UserData>();\n        //lrLinkedList = new LRLinkedList<UserData>();\n        \n        this.numMilis = numMilis;\n        this.csvdb = csvdb;\n        this.writePerMil = writePerMil;\n        udArray = new UserData[numElements];\n        for (int i = 0; i < numElements; i++) {\n            udArray[i] = new UserData();\n            udArray[i].a = i;\n            udArray[i].b = i % 7;\n        }\n                \n        System.out.println(\"Filling up data structures\");\n        for (int i = 0; i < numElements; i++) {\n            UserData ud = udArray[i];\n            clleu.add(ud);\n            clleuvol.add(ud);\n            clq.add(ud);\n            clqrel.add(ud);\n            //lrLinkedList.add(ud);\n        }\n\n        workerThreads = new WorkerThread[numThreads];\n       \n        /* Performance tests */\n        double writePercentage = writePerMil == 0 ? 0 : writePerMil/10.;\n        System.out.println(\"----- Performance tests numThreads=\" +numThreads+\"  Writes=\"+writePercentage+\"%  numElements=\"+numElements+\" -----\");        \n        \n        singleTest(numThreads, TestCase.CLLElectedUnlink);\n        singleTest(numThreads, TestCase.CLLElectedUnlinkVolatile);\n        singleTest(numThreads, TestCase.ConcurrentLinkedQueue);\n        singleTest(numThreads, TestCase.ConcurrentLinkedQueueRelaxed);\n        //singleTest(numThreads, TestCase.LRLinkedList);\n        System.out.println();\n    }",
      "line_number": 44,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkListRelaxedvsVolatile",
      "method_type": "constructor"
    },
    {
      "name": "singleTest",
      "signature": "public void singleTest(int numThreads, TestCase type) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/BenchmarkListRelaxedvsVolatile.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "addRunDedicated",
        "length",
        "Thread.sleep",
        "csvdb.addRun",
        "join",
        "out.print",
        "type.toString",
        "e.printStackTrace",
        "start",
        "printStackTrace",
        "out.println",
        "print",
        "addRun",
        "csvdb.addRunDedicated",
        "substring",
        "toString",
        "sleep",
        "println",
        "WorkerThread"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 52,
      "source_code": "        // If we see an error here just increase the number of spaces\n        String indentedName = type.toString() + \"                                  \".substring(type.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n        \n        // Create the threads and then start them all in one go\n        for (int i = 0; i < numThreads; i++) {\n            workerThreads[i] = new WorkerThread(type, i);\n        }\n        for (int i = 0; i < numThreads; i++) workerThreads[i].start();\n\n        // Sleep for 10 seconds\n        try {\n            Thread.sleep(numMilis);\n        } catch(InterruptedException e){\n            System.out.println(\"InterruptedException\");\n        }\n        for (int i = 0; i < numThreads; i++) workerThreads[i].quit = true;\n               \n        try {\n            for (int i = 0; i < numThreads; i++) workerThreads[i].join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        long numAddRemoves = 0;\n        long numContains = 0;\n        for (int i = 0; i < numThreads; i++) {\n            numAddRemoves += workerThreads[i].numAddRemoves;\n            numContains += workerThreads[i].numContains;\n        }\n        final int perSecond = numMilis/1000;\n        System.out.println(\"numAddRemoves/sec = \"+(numAddRemoves/perSecond)+\"  numContains/sec = \"+(numContains/perSecond));\n\n        if (writePerMil == -1) {\n            csvdb.addRunDedicated(type.toString(), numThreads-2, 2, numContains/perSecond, numAddRemoves/perSecond);\n        } else {\n            csvdb.addRun(type.toString(), writePerMil, numThreads, (numContains+numAddRemoves)/perSecond);\n        }\n    }",
      "line_number": 87,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkListRelaxedvsVolatile",
      "method_type": "method"
    },
    {
      "name": "randomLong",
      "signature": "public static long randomLong(long x) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/BenchmarkListRelaxedvsVolatile.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        x ^= (x << 21);\n        x ^= (x >>> 35);\n        x ^= (x << 4);\n        return x;\n    }",
      "line_number": 144,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BenchmarkListRelaxedvsVolatile",
      "method_type": "method"
    },
    {
      "name": "WorkerThread",
      "signature": "public WorkerThread(TestCase type, int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/BenchmarkListRelaxedvsVolatile.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "            this.type = type;   \n            this.tid = tid;\n        }",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkListRelaxedvsVolatile",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/BenchmarkListRelaxedvsVolatile.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Thread",
        "ConcurrentLinkedQueue"
      ],
      "dependencies": [
        "clleu.remove",
        "clleuvol.add",
        "clqrel.add",
        "add",
        "clqrel.contains",
        "lrLinkedList.add",
        "clq.remove",
        "clleu.add",
        "clq.contains",
        "clq.add",
        "clleu.contains",
        "clleuvol.contains",
        "lrLinkedList.remove",
        "System.nanoTime",
        "clqrel.remove",
        "clleuvol.remove",
        "nanoTime",
        "contains",
        "lrLinkedList.contains",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm"
      ],
      "complexity_score": 24,
      "source_code": "            long xrand = System.nanoTime();\n            long x;\n            \n            while (!quit) {\n                \n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                \n                UserData ud = udArray[(int)(x % numElements)];\n                \n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                \n                UserData ud1 = udArray[(int)(x % numElements)];\n                if ((writePerMil==-1 && (tid == 0 || tid == 1)) || \n                     (writePerMil != 0 && (x%1000) < writePerMil)) {\n                    // These two threads are doing remove/add\n                    switch (type) {\n                    case CLLElectedUnlink:\n                        clleu.add(ud);\n                        clleu.remove(ud);\n                        break;\n                    case CLLElectedUnlinkVolatile:\n                        clleuvol.add(ud);\n                        clleuvol.remove(ud);\n                        break;\n                    case ConcurrentLinkedQueue:\n                        clq.add(ud);\n                        clq.remove(ud);\n                        break;\n                    case ConcurrentLinkedQueueRelaxed:\n                        clqrel.add(ud);\n                        clqrel.remove(ud);\n                        break;\n                    //case LRLinkedList:\n                    //    lrLinkedList.add(ud);\n                    //    lrLinkedList.remove(ud);\n                    //    break;\n                    }\n                    numAddRemoves += 2;\n                } else {                   \n                    switch (type) {\n                    case CLLElectedUnlink:\n                        clleu.contains(ud);\n                        clleu.contains(ud1);\n                        break;\n                    case CLLElectedUnlinkVolatile:\n                        clleuvol.contains(ud);\n    ",
      "line_number": 168,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkListRelaxedvsVolatile",
      "method_type": "method"
    },
    {
      "name": "simpleWritePerMilTest",
      "signature": "static void simpleWritePerMilTest() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/BenchmarkListRelaxedvsVolatile.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Thread",
        "final",
        "static"
      ],
      "dependencies": [
        "asList",
        "out.println",
        "sleep",
        "println",
        "BenchmarkListRelaxedvsVolatile",
        "Integer",
        "availableProcessors",
        "csvdb.saveDB",
        "Runtime.getRuntime",
        "Arrays.asList",
        "CSVDatabase",
        "Thread.sleep",
        "saveDB",
        "LinkedList",
        "getRuntime"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 80,
      "source_code": "        //LinkedList<Integer> threadList = new LinkedList(Arrays.asList(1, 2, 3, 4, 8, 16, 32, 64, 128, 176));\n        LinkedList<Integer> threadList = new LinkedList(Arrays.asList(1, 2, 4, 8));\n        //LinkedList<Integer> threadList = new LinkedList(Arrays.asList(8));\n        \n        BenchmarkListRelaxedvsVolatile tests;\n        final CSVDatabase csvdb = new CSVDatabase();\n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n        \n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkListRelaxedvsVolatile(nThreads, 10000, csvdb, 1000);\n            tests = null;\n            Thread.sleep(1000); // sleep for 1 second to allow the GC to work a bit\n        }  // 100%\n        \n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkListRelaxedvsVolatile(nThreads, 10000, csvdb, 100);\n            tests = null;\n            Thread.sleep(1000); // sleep for 1 second to allow the GC to work a bit\n        }  // 10%\n        \n        for (Integer nThreads : threadList){\n            tests = new BenchmarkListRelaxedvsVolatile(nThreads, 10000, csvdb, 10);\n            tests = null;\n            Thread.sleep(1000); // sleep for 1 second to allow the GC to work a bit\n        }   // 1%\n        \n        for (Integer nThreads : threadList){\n            tests = new BenchmarkListRelaxedvsVolatile(nThreads, 10000, csvdb, 1);\n            tests = null;\n            Thread.sleep(1000); // sleep for 1 second to allow the GC to work a bit\n        }    // 0.1%\n            \n        for (Integer nThreads : threadList){\n            tests = new BenchmarkListRelaxedvsVolatile(nThreads, 10000, csvdb, 0);\n            tests = null;\n            Thread.sleep(1000); // sleep for 1 second to allow the GC to work a bit\n        }    // 0.0%\n        \n        csvdb.saveDB(BenchmarkListRelaxedvsVolatile.numElements);\n    }",
      "line_number": 245,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkListRelaxedvsVolatile",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args)  throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/BenchmarkListRelaxedvsVolatile.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        simpleWritePerMilTest();\n    }",
      "line_number": 291,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BenchmarkListRelaxedvsVolatile",
      "method_type": "method"
    },
    {
      "name": "markRemoved",
      "signature": "boolean markRemoved() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapInt",
        "compareAndSwapInt"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapInt(this, stateOffset, INUSE, REMOVED);\n        }",
      "line_number": 178,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 198,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "getVolatileNext",
      "signature": "Node<E> getVolatileNext() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "getObjectVolatile",
        "UNSAFE.getObjectVolatile",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "            return (Node<E>)UNSAFE.getObjectVolatile(this, nextOffset);\n        }",
      "line_number": 206,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "localTail.getVolatileNext",
        "Node",
        "localTail.casNext",
        "getVolatileNext",
        "casNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        checkNotNull(item);\n        final Node<E> newNode = new Node<E>(item);\n        while (true) {\n            final Node<E> localTail = tail;\n            final Node<E> node = localTail.getVolatileNext();\n            if (localTail == tail) {\n                if (node == null) {\n                    // It seems this is the last node, so add the newNode here \n                    // and try to move the tail to the newNode\n                    if (localTail.casNext(null, newNode)) {\n                        casTail(localTail, newNode); // Failure is OK.\n                        return true;\n                    }\n                } else {\n                    casTail(localTail, node);\n                }\n            }\n        }\n    }",
      "line_number": 254,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "item.equals",
        "node.getVolatileNext",
        "getVolatileNext",
        "equals",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        if (item == null) return false;\n        Node<E> node = head;\n        while (node != null) {\n            if (item.equals(node.item) && node.state == INUSE) {\n                return true;\n            }\n            // No need for acquire-barriers unless we see null\n            final Node<E> nnext = node.next;\n            node = (nnext == null) ? node.getVolatileNext() : nnext;\n        }\n        return false;\n    }",
      "line_number": 285,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        checkNotNull(item);\n        if (unlinkGuard == NO_GUARD && casUnlinkGuard(NO_GUARD, GUARDED)) {\n            try {\n                // We got the hold on the guard, now figure out if unlinking is\n                // needed for other nodes or just this one.\n                if (unlinkNeeded == NEED_UNLINK) {\n                    return markOneAndUnlinkAll(item);               \n                } else {\n                    return markAndUnlinkOne(item);\n                }\n            } finally {\n                unlinkGuard = NO_GUARD;\n            }\n        } else {\n            // Didn't get the hold of the guard, so mark the node and don't\n            // do any unlinking.\n            return markNode(item);\n        }\n    }",
      "line_number": 312,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "markOneAndUnlinkAll",
      "signature": "private boolean markOneAndUnlinkAll(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "item.equals",
        "E",
        "node.getVolatileNext",
        "getVolatileNext",
        "markRemoved",
        "node.markRemoved",
        "head.getVolatileNext",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 27,
      "source_code": "        casUnlinkNeeded(NEED_UNLINK, NO_GUARD); \n        Node<E> node = head;\n        Node<E> lastInUse = head;\n        final Node<E> localTail = tail;\n        boolean doUnlinking = true; // Turns to false once the localTail has been reached\n        boolean nodeWasMarked = false;\n        \n        // Lets loop first to advance the head if needed\n        while (head.state == REMOVED) {\n            Node<E> headNext = head.getVolatileNext(); \n            if (headNext == null) return false;\n            head = headNext;\n        }\n        node = head;\n        \n        while (node != null) {\n            // We do the order here differently and read the value of \"state\"\n            // before looking at the key.\n            if (!nodeWasMarked && node.state == INUSE && item.equals(node.item) && node.markRemoved()) {\n                // We've marked the node, but instead of returning true \n                // immediately, we continue to search the linked list for \n                // nodes that need to be unlinked.\n                nodeWasMarked = true;\n                // Unlink only if it is not the last node nor the first\n                if (lastInUse != head && node.next != null) {\n                    lastInUse.next = node.next;\n                }\n            }            \n            // Once the tail has been found, don't do any more unlinking \n            if (node == localTail) doUnlinking = false;\n            // Optimization: If the tail has been reached and the item has been \n            // found, then we can return true immediately.\n            if (!doUnlinking && nodeWasMarked) return true;\n            if (doUnlinking) {\n                if (node.state == INUSE) {\n                    lastInUse = node;\n                } else {\n                    lastInUse.next = node.next;\n                }\n            }\n            final Node<E> nnext = node.next;\n            node = (nnext == null) ? node.getVolatileNext() : nnext;            \n        }            \n        return nodeWasMark",
      "line_number": 345,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "markAndUnlinkOne",
      "signature": "private boolean markAndUnlinkOne(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "item.equals",
        "E",
        "node.getVolatileNext",
        "getVolatileNext",
        "markRemoved",
        "node.markRemoved",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        Node<E> node = head;\n        Node<E> prev = head;\n        while (node != null) {\n            if (item.equals(node.item) && node.state == INUSE) {\n                if (node.markRemoved()) {\n                    if (node == head && node.next != null) {\n                        // Removed node was \"head\" so try to advance it\n                        casHead(node, node.next);\n                    } else if (node.next != null) {\n                        // Unlink only if it is not the last node\n                        prev.next = node.next;\n                    } \n                    return true;\n                }\n            }\n            prev = node;\n            final Node<E> nnext = node.next;\n            node = (nnext == null) ? node.getVolatileNext() : nnext;            \n        }            \n        return false;\n    }",
      "line_number": 409,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "markNode",
      "signature": "private boolean markNode(final E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "item.equals",
        "E",
        "node.getVolatileNext",
        "getVolatileNext",
        "markRemoved",
        "node.markRemoved",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        Node<E> node = head;\n        while (node != null) {\n            if (item.equals(node.item) && node.state == INUSE) {\n                if (node.markRemoved()) {\n                    unlinkNeeded = NEED_UNLINK;\n                    return true;\n                }\n            }\n            final Node<E> nnext = node.next;\n            node = (nnext == null) ? node.getVolatileNext() : nnext;            \n        }\n        return false;\n    }",
      "line_number": 441,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "checkNotNull",
      "signature": "static void checkNotNull(Object v) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        if (v == null)\n            throw new NullPointerException();\n    }",
      "line_number": 462,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "casUnlinkGuard",
      "signature": "boolean casUnlinkGuard(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, guardOffset, cmp, val);\n    }",
      "line_number": 467,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "casUnlinkNeeded",
      "signature": "boolean casUnlinkNeeded(long cmp, long val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapLong",
        "compareAndSwapLong"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapLong(this, unlinkNeededOffset, cmp, val);\n    }",
      "line_number": 471,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 475,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/CLLElectedUnlink.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }    ",
      "line_number": 479,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CLLElectedUnlink",
      "method_type": "method"
    },
    {
      "name": "casItem",
      "signature": "boolean casItem(E cmp, E val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);\n        }",
      "line_number": 193,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "getRelaxedItem",
      "signature": "E getRelaxedItem() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "getObject",
        "UNSAFE.getObject"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "            E localitem = (E)UNSAFE.getObject(this, itemOffset);\n            // If it's null we need to re-read, this time as a volatile load\n            return localitem == null ? item : localitem;\n        }",
      "line_number": 197,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "lazySetNext",
      "signature": "void lazySetNext(Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putOrderedObject",
        "UNSAFE.putOrderedObject",
        "E"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            UNSAFE.putOrderedObject(this, nextOffset, val);\n        }",
      "line_number": 203,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 207,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "getRelaxedNext",
      "signature": "Node<E> getRelaxedNext() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getObject",
        "UNSAFE.getObject",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return (Node<E>)UNSAFE.getObject(this, nextOffset);\n        }",
      "line_number": 211,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "ConcurrentLinkedQueueRelaxed",
      "signature": "public ConcurrentLinkedQueueRelaxed() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "ConcurrentLinkedQueue"
      ],
      "dependencies": [
        "Node",
        "E"
      ],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "        head = tail = new Node<E>(null);\n    }",
      "line_number": 269,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "ConcurrentLinkedQueueRelaxed",
      "signature": "public ConcurrentLinkedQueueRelaxed(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "ConcurrentLinkedQueue"
      ],
      "dependencies": [
        "Node",
        "lazySetNext",
        "t.lazySetNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        Node<E> h = null, t = null;\n        for (E e : c) {\n            checkNotNull(e);\n            Node<E> newNode = new Node<E>(e);\n            if (h == null)\n                h = t = newNode;\n            else {\n                t.lazySetNext(newNode);\n                t = newNode;\n            }\n        }\n        if (h == null)\n            h = t = new Node<E>(null);\n        head = h;\n        tail = t;\n    }",
      "line_number": 282,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "updateHead",
      "signature": "final void updateHead(Node<E> h, Node<E> p) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lazySetNext",
        "E",
        "h.lazySetNext"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        if (h != p && casHead(h, p))\n            h.lazySetNext(h);\n    }",
      "line_number": 318,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "succ",
      "signature": "final Node<E> succ(Node<E> p) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        Node<E> next = p.next;\n        return (p == next) ? head : next;\n    }",
      "line_number": 328,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "succRelaxed",
      "signature": "final Node<E> succRelaxed(Node<E> p) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getRelaxedNext",
        "p.getRelaxedNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        Node<E> next = p.getRelaxedNext();\n        if (next == null) next = p.next;\n        return (p == next) ? head : next;\n    }",
      "line_number": 333,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(E e) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "casNext",
        "Node",
        "p.casNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 13,
      "source_code": "        checkNotNull(e);\n        final Node<E> newNode = new Node<E>(e);\n\n        for (Node<E> t = tail, p = t;;) {\n            Node<E> q = p.next;\n            if (q == null) {\n                // p is last node\n                if (p.casNext(null, newNode)) {\n                    // Successful CAS is the linearization point\n                    // for e to become an element of this queue,\n                    // and for newNode to become \"live\".\n                    if (p != t) // hop two nodes at a time\n                        casTail(t, newNode);  // Failure is OK.\n                    return true;\n                }\n                // Lost CAS race to another thread; re-read next\n            }\n            else if (p == q)\n                // We have fallen off list.  If tail is unchanged, it\n                // will also be off-list, in which case we need to\n                // jump to head, from which all live nodes are always\n                // reachable.  Else the new tail is a better bet.\n                p = (t != (t = tail)) ? t : head;\n            else\n                // Check for tail updates after two hops.\n                p = (p != t && t != (t = tail)) ? t : q;\n        }\n    }",
      "line_number": 346,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "casItem",
        "p.casItem"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 9,
      "source_code": "        restartFromHead:\n        for (;;) {\n            for (Node<E> h = head, p = h, q;;) {\n                E item = p.item;\n\n                if (item != null && p.casItem(item, null)) {\n                    // Successful CAS is the linearization point\n                    // for item to be removed from this queue.\n                    if (p != h) // hop two nodes at a time\n                        updateHead(h, ((q = p.next) != null) ? q : p);\n                    return item;\n                }\n                else if ((q = p.next) == null) {\n                    updateHead(h, p);\n                    return null;\n                }\n                else if (p == q)\n                    continue restartFromHead;\n                else\n                    p = q;\n            }\n        }\n    }",
      "line_number": 376,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 6,
      "source_code": "        restartFromHead:\n        for (;;) {\n            for (Node<E> h = head, p = h, q;;) {\n                E item = p.item;\n                if (item != null || (q = p.next) == null) {\n                    updateHead(h, p);\n                    return item;\n                }\n                else if (p == q)\n                    continue restartFromHead;\n                else\n                    p = q;\n            }\n        }\n    }",
      "line_number": 401,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "first",
      "signature": "Node<E> first() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 6,
      "source_code": "        restartFromHead:\n        for (;;) {\n            for (Node<E> h = head, p = h, q;;) {\n                boolean hasItem = (p.item != null);\n                if (hasItem || (q = p.next) == null) {\n                    updateHead(h, p);\n                    return hasItem ? p : null;\n                }\n                else if (p == q)\n                    continue restartFromHead;\n                else\n                    p = q;\n            }\n        }\n    }",
      "line_number": 426,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "size",
        "Collection.size",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "        int count = 0;\n        for (Node<E> p = first(); p != null; p = succ(p))\n            if (p.item != null)\n                // Collection.size() spec says to max out\n                if (++count == Integer.MAX_VALUE)\n                    break;\n        return count;\n    }",
      "line_number": 468,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getRelaxedItem",
        "equals",
        "o.equals",
        "p.getRelaxedItem",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        if (o == null) return false;\n        for (Node<E> p = first(); p != null; p = succRelaxed(p)) {\n            E item = p.getRelaxedItem();\n            if (item != null && o.equals(item) && p.item != null)\n                return true;\n        }\n        return false;\n    }",
      "line_number": 486,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "getRelaxedItem",
        "casItem",
        "E",
        "p.casItem",
        "o.equals",
        "casNext",
        "pred.casNext",
        "p.getRelaxedItem",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        if (o == null) return false;\n        Node<E> pred = null;\n        for (Node<E> p = first(); p != null; p = succRelaxed(p)) {\n            E item = p.getRelaxedItem();\n            if (item != null &&\n                o.equals(item) &&\n                p.casItem(item, null)) {\n                Node<E> next = succ(p);\n                if (pred != null && next != null)\n                    pred.casNext(p, next);\n                return true;\n            }\n            pred = p;\n        }\n        return false;\n    }",
      "line_number": 507,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "last.lazySetNext",
        "Node",
        "IllegalArgumentException",
        "p.casNext",
        "casNext",
        "lazySetNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "lock_free_algorithm",
        "thread_local_storage"
      ],
      "complexity_score": 25,
      "source_code": "        if (c == this)\n            // As historically specified in AbstractQueue#addAll\n            throw new IllegalArgumentException();\n\n        // Copy c into a private chain of Nodes\n        Node<E> beginningOfTheEnd = null, last = null;\n        for (E e : c) {\n            checkNotNull(e);\n            Node<E> newNode = new Node<E>(e);\n            if (beginningOfTheEnd == null)\n                beginningOfTheEnd = last = newNode;\n            else {\n                last.lazySetNext(newNode);\n                last = newNode;\n            }\n        }\n        if (beginningOfTheEnd == null)\n            return false;\n\n        // Atomically append the chain at the tail of this collection\n        for (Node<E> t = tail, p = t;;) {\n            Node<E> q = p.next;\n            if (q == null) {\n                // p is last node\n                if (p.casNext(null, beginningOfTheEnd)) {\n                    // Successful CAS is the linearization point\n                    // for all elements to be added to this queue.\n                    if (!casTail(t, last)) {\n                        // Try a little harder to update tail,\n                        // since we may be adding many elements.\n                        t = tail;\n                        if (last.next == null)\n                            casTail(t, last);\n                    }\n                    return true;\n                }\n                // Lost CAS race to another thread; re-read next\n            }\n            else if (p == q)\n                // We have fallen off list.  If tail is unchanged, it\n                // will also be off-list, in which case we need to\n                // jump to head, from which all live nodes are always\n                // reachable.  Else the new tail is a better bet.\n                p = (t != (t = tail)) ? t : head;\n            else\n                // Check for tail updates after two hops.\n                p = (p != t && t != (t = tail)) ? t : q;\n        }\n    }",
      "line_number": 537,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public Object[] toArray() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "al.add",
        "add",
        "ArrayList",
        "al.toArray",
        "toArray",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "        // Use ArrayList to deal with resizing.\n        ArrayList<E> al = new ArrayList<E>();\n        for (Node<E> p = first(); p != null; p = succ(p)) {\n            E item = p.item;\n            if (item != null)\n                al.add(item);\n        }\n        return al.toArray();\n    }",
      "line_number": 601,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(T[] a) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "al.add",
        "add",
        "ArrayList",
        "al.toArray",
        "toArray",
        "T",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 11,
      "source_code": "        // try to use sent-in array\n        int k = 0;\n        Node<E> p;\n        for (p = first(); p != null && k < a.length; p = succ(p)) {\n            E item = p.item;\n            if (item != null)\n                a[k++] = (T)item;\n        }\n        if (p == null) {\n            if (k < a.length)\n                a[k] = null;\n            return a;\n        }\n\n        // If won't fit, use ArrayList version\n        ArrayList<E> al = new ArrayList<E>();\n        for (Node<E> q = first(); q != null; q = succ(q)) {\n            E item = q.item;\n            if (item != null)\n                al.add(item);\n        }\n        return al.toArray(a);\n    }",
      "line_number": 649,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "advance",
      "signature": "private E advance() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "casNext",
        "pred.casNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 8,
      "source_code": "            lastRet = nextNode;\n            E x = nextItem;\n\n            Node<E> pred, p;\n            if (nextNode == null) {\n                p = first();\n                pred = null;\n            } else {\n                pred = nextNode;\n                p = succ(nextNode);\n            }\n\n            for (;;) {\n                if (p == null) {\n                    nextNode = null;\n                    nextItem = null;\n                    return x;\n                }\n                E item = p.item;\n                if (item != null) {\n                    nextNode = p;\n                    nextItem = item;\n                    return x;\n                } else {\n                    // skip over nulls\n                    Node<E> next = succ(p);\n                    if (pred != null && next != null)\n                        pred.casNext(p, next);\n                    p = next;\n                }\n            }\n        }",
      "line_number": 718,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "next",
      "signature": "public E next() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 1,
      "source_code": "            if (nextNode == null) throw new NoSuchElementException();\n            return advance();\n        }",
      "line_number": 756,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public void remove() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "Future"
      ],
      "dependencies": [
        "IllegalStateException",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern"
      ],
      "complexity_score": 3,
      "source_code": "            Node<E> l = lastRet;\n            if (l == null) throw new IllegalStateException();\n            // rely on a future traversal to relink.\n            l.item = null;\n            lastRet = null;\n        }",
      "line_number": 761,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "checkNotNull",
      "signature": "private static void checkNotNull(Object v) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [
        "NullPointerException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        if (v == null)\n            throw new NullPointerException();\n    }",
      "line_number": 826,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 831,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/ConcurrentLinkedQueueRelaxed.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 835,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "and",
      "method_type": "method"
    },
    {
      "name": "HarrisAMRLinkedList",
      "signature": "public HarrisAMRLinkedList() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisAMRLinkedList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Node",
        "E",
        "next.set",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        tail = new Node<E>(null);\n        head = new Node<E>(null);\n        head.next.set(tail, false);\n    }",
      "line_number": 88,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "HarrisAMRLinkedList",
      "method_type": "constructor"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisAMRLinkedList.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "E",
        "Node",
        "set",
        "next.set",
        "next.compareAndSet"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        final Node<E> newNode = new Node<E>(key);\n        while (true) {\n            final Window<E> window = find(key);\n            // On Harris paper, pred is named left_node and curr is right_node\n            final Node<E> pred = window.pred;\n            final Node<E> curr = window.curr;\n            if (curr.key == key) { \n                return false;\n            } else {\n                newNode.next.set(curr, false);\n                if (pred.next.compareAndSet(curr, newNode, false, false)) {\n                    return true;\n                }\n            }\n        }       \n    }",
      "line_number": 104,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "HarrisAMRLinkedList",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisAMRLinkedList.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "getReference",
        "compareAndSet",
        "next.compareAndSet",
        "next.getReference",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        while (true) {\n            final Window<E> window = find(key);\n            // On Harris's paper, \"pred\" is named \"left_node\" and the \"curr\"\n            // variable is named \"right_node\".            \n            final Node<E> pred = window.pred;\n            final Node<E> curr = window.curr;\n            if (curr.key != key) {\n                return false;\n            } \n            final Node<E> succ = curr.next.getReference();\n            // In \"The Art of Multiprocessor Programming - 1st edition\", \n            // the code shown has attemptMark() but we can't use it, \n            // because attemptMark() returns true if the node\n            // is already marked, which is not the desired effect, so we \n            // must use compareAndSet() instead.\n            if (!curr.next.compareAndSet(succ, succ, false, true)) {\n                continue;\n            }\n            pred.next.compareAndSet(curr, succ, false, false);\n            return true;\n        }\n    }",
      "line_number": 132,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "HarrisAMRLinkedList",
      "method_type": "method"
    },
    {
      "name": "find",
      "signature": "public Window<E> find(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisAMRLinkedList.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "Window",
        "getReference",
        "compareAndSet",
        "E",
        "get",
        "keyComp.compareTo",
        "next.compareAndSet",
        "compareTo",
        "next.getReference",
        "next.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        Node<E> pred = null;\n        Node<E> curr = null; \n        Node<E> succ = null;\n        boolean[] marked = {false};\n        @SuppressWarnings(\"unchecked\")        \n        final Comparable<? super E> keyComp = (Comparable<? super E>)key; \n        \n        // I think there is a special case for an empty list\n        if (head.next.getReference() == tail) {\n            return new Window<E>(head, tail);\n        }\n        \n        retry: \n        while (true) {\n            pred = head;\n            curr = pred.next.getReference();\n            while (true) {\n                succ = curr.next.get(marked);\n                while (marked[0]) {\n                    if (!pred.next.compareAndSet(curr, succ, false, false)) {\n                        continue retry;\n                    }\n                    curr = succ;\n                    succ = curr.next.get(marked);\n                }\n\n                if (curr == tail || keyComp.compareTo(curr.key) <= 0) {\n                    return new Window<E>(pred, curr);\n                }\n                pred = curr;\n                curr = succ;\n            }\n        }\n    }",
      "line_number": 165,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "HarrisAMRLinkedList",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/list/HarrisAMRLinkedList.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "getReference",
        "E",
        "get",
        "keyComp.compareTo",
        "compareTo",
        "next.getReference",
        "next.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        boolean[] marked = {false};\n        Node<E> curr = head.next.getReference();\n        curr.next.get(marked);\n        @SuppressWarnings(\"unchecked\")\n        final Comparable<? super E> keyComp = (Comparable<? super E>)key; \n        while (curr != tail && keyComp.compareTo(curr.key) > 0) {\n            curr = curr.next.getReference();\n            curr.next.get(marked);\n        }\n        return (curr.key == key && !marked[0]); \n    }",
      "line_number": 218,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "HarrisAMRLinkedList",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 79,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "putOrderedNext",
      "signature": "void putOrderedNext(Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putOrderedObject",
        "UNSAFE.putOrderedObject",
        "E"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            UNSAFE.putOrderedObject(this, nextOffset, val);\n        }",
      "line_number": 83,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "casItem",
      "signature": "boolean casItem(E cmp, E val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);\n        }",
      "line_number": 111,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "EncapsulatorQueue",
      "signature": "public EncapsulatorQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "        this(MAX_THREADS);\n    }",
      "line_number": 138,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "EncapsulatorQueue",
      "method_type": "constructor"
    },
    {
      "name": "EncapsulatorQueue",
      "signature": "public EncapsulatorQueue(int maxThreads) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "Thread",
        "AtomicReference"
      ],
      "dependencies": [
        "Node",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 12,
      "source_code": "        this.maxThreads = maxThreads;\n        Node<E> sentinelNode = new Node<E>(new Encap[0],0);\n        head = sentinelNode;\n        tail = sentinelNode;\n        enqueuers = new AtomicReferenceArray<Encap<E>>(maxThreads);\n    }",
      "line_number": 142,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "EncapsulatorQueue",
      "method_type": "constructor"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        enqueue(item, (int)(Thread.currentThread().getId() % maxThreads));\n    }",
      "line_number": 151,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item, final int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "lazySet",
        "enqueuers.set",
        "Node",
        "get",
        "set",
        "NullPointerException",
        "enqueuers.get",
        "Encap",
        "casNext",
        "ltail.casNext",
        "enqueuers.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (item == null) throw new NullPointerException();\n        final Encap<E> myEncap = new Encap<E>(item);\n        enqueuers.set(tid, myEncap);  // Open request\n        final Encap<E>[] lreqs = new Encap[maxThreads]; \n        for (int iter = 0; iter < 2; iter++) {\n            Node<E> ltail = tail;\n            if (ltail.next != null) { // Advance tail if needed\n                casTail(ltail, ltail.next);\n                ltail = tail;\n                if (ltail.next != null) continue;\n            }\n            int numreqs = 0;\n            for (int i = 0; i < maxThreads; i++) {\n                final Encap<E> encap = enqueuers.get(i);\n                if (encap == null) continue;\n                lreqs[numreqs++] = encap;\n            }\n            if (ltail != tail || ltail.next != null) continue;\n            if (ltail.casNext(null, new Node<E>(lreqs, numreqs))) {\n                casTail(ltail, ltail.next);\n                break;\n            }\n        }\n        enqueuers.lazySet(tid, null);\n    }",
      "line_number": 161,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        return dequeue((int)(Thread.currentThread().getId() % maxThreads));\n    }",
      "line_number": 189,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue(final int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "lhead.putOrderedNext",
        "casItem",
        "encap.casItem",
        "putOrderedNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        Node<E> lhead = head;\n        Node<E> node = lhead;\n        while (node != null) {\n            if (node.next == node) { // Handle self-linking\n                lhead = head;\n                node = lhead;\n            }\n            final int length = node.encaps.length;\n            for (int i = 0; i < length; i++) {\n                final Encap<E> encap = node.encaps[(tid + i) % length];\n                final E item = encap.item;\n                if (item == null) continue;\n                if (encap.casItem(item, null)) {\n                    if (node != lhead && lhead == head) {\n                        if (casHead(lhead, node)) {\n                            // Self-link to help the GC\n                            if (lhead != tail) lhead.putOrderedNext(lhead); \n                        }\n                    }\n                    return item;\n                }\n            }\n            node = node.next;\n        }\n        return null;\n    }",
      "line_number": 199,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 228,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/EncapsulatorQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 232,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "EncapsulatorQueue",
      "method_type": "method"
    },
    {
      "name": "Node",
      "signature": "public Node(E val, int etid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicInteger"
      ],
      "dependencies": [
        "AtomicInteger"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "            value = val;\n            next = null;\n            enqTid = etid;\n            deqTid = new AtomicInteger(-1);\n        }",
      "line_number": 33,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "public boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 40,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "KoganPetrankQueue",
      "signature": "public KoganPetrankQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "Thread",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "state.set",
        "Node",
        "length",
        "OpDesc",
        "set",
        "state.length",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final Node<E> sentinel = new Node<E>(null, -1);\n        head = sentinel;\n        tail = sentinel;\n        state = new AtomicReferenceArray<OpDesc<E>>(NUM_THREADS);\n        for (int i = 0; i < state.length(); i++) {\n            state.set(i, new OpDesc<E>(-1, false, true, null));\n        }\n    }",
      "line_number": 84,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankQueue",
      "method_type": "constructor"
    },
    {
      "name": "maxPhase",
      "signature": "private long maxPhase() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "state.length",
        "get",
        "length"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long maxPhase = -1;\n        for (int i = 0; i < state.length(); i++) {\n            long phase = state.get(i).phase;\n            if (phase > maxPhase) {\n                maxPhase = phase;\n            }\n        }\n        return maxPhase;\n    }",
      "line_number": 109,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "isStillPending",
      "signature": "private boolean isStillPending(int tid, long ph) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return state.get(tid).pending && state.get(tid).phase <= ph;\n    }",
      "line_number": 121,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "enq",
      "signature": "public void enq(E value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "state.set",
        "Thread.currentThread",
        "Node",
        "OpDesc",
        "set",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // We better have consecutive thread ids, otherwise this will blow up\n        // TODO: replace this mechanism with something more flexible\n        final int TID = (int)(Thread.currentThread().getId() % NUM_THREADS);\n        long phase = maxPhase() + 1;\n        state.set(TID, new OpDesc<E>(phase, true, true, new Node<E>(value, TID)));\n        help(phase);\n        help_finish_enq();\n    }",
      "line_number": 126,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "help_enq",
      "signature": "private void help_enq(int tid, long phase) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "last.casNext",
        "get",
        "casNext",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        while (isStillPending(tid, phase)) {\n            Node<E> last = tail;\n            Node<E> next = last.next;\n            if (last == tail) {           // If it's tail it can't be self-linked\n                if (next == null) {\n                    if (isStillPending(tid, phase)) {\n                        if (last.casNext(next, state.get(tid).node)) {\n                            help_finish_enq();\n                            return;\n                        }\n                    }\n                } else {\n                    help_finish_enq();\n                }\n            }\n        }\n    }",
      "line_number": 137,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "help_finish_enq",
      "signature": "private void help_finish_enq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final Node<E> last = tail;\n        final Node<E> next = last.next;\n        if (next != null && next != last) { // Check for self-linking\n            int tid = next.enqTid;\n            final OpDesc<E> curDesc = state.get(tid);\n            if (last == tail && state.get(tid).node == next) {\n                final OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, false, true, next);\n                state.compareAndSet(tid, curDesc, newDesc);\n                casTail(last, next);\n            }\n        }\n    }",
      "line_number": 157,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "deq",
      "signature": "public E deq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread",
        "state.set",
        "get",
        "OpDesc",
        "set",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        // We better have consecutive thread ids, otherwise this will blow up\n        // TODO: replace this mechanism with something more flexible\n        final int TID = (int)(Thread.currentThread().getId() % NUM_THREADS);\n        long phase = maxPhase() + 1;\n        state.set(TID, new OpDesc<E>(phase, true, false, null));\n        help(phase);\n        help_finish_deq();\n        final Node<E> node = state.get(TID).node;\n        if (node == null) return null; // We return null instead of throwing an exception\n        final E value = node.next.value;\n        node.next = node;              // Self-link to help the GC\n        return value;\n    }",
      "line_number": 172,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "help_deq",
      "signature": "private void help_deq(int tid, long phase) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "deqTid.compareAndSet",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        while (isStillPending(tid, phase)) {\n            Node<E> first = head;\n            Node<E> last = tail;\n            Node<E> next = first.next;\n            if (first == head) {  // If it's still head then it's not self-linked\n                if (first == last) {\n                    if (next == null) {\n                        OpDesc<E> curDesc = state.get(tid);\n                        if (last == tail && isStillPending(tid, phase)) {\n                            OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, false, false, null);\n                            state.compareAndSet(tid, curDesc, newDesc);\n                        }\n                    } else {\n                        help_finish_enq();\n                    }\n                } else {\n                    OpDesc<E> curDesc = state.get(tid);\n                    Node<E> node = curDesc.node;\n                    if (!isStillPending(tid, phase)) break;\n                    if (first == head && node != first) {\n                        OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, true, false, first);\n                        if (!state.compareAndSet(tid, curDesc, newDesc)) {\n                            continue;\n                        }\n                    }\n                    first.deqTid.compareAndSet(-1, tid);\n                    help_finish_deq();\n                }\n            }\n        }\n    }",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "help_finish_deq",
      "signature": "private void help_finish_deq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "state.get",
        "deqTid.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final Node<E> first = head;\n        final Node<E> next = first.next;\n        int tid = first.deqTid.get();\n        if (tid != -1 && next != first) {\n            final OpDesc<E> curDesc = state.get(tid);\n            if (first == head && next != null) {\n                final OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, false, false, state.get(tid).node);\n                state.compareAndSet(tid, curDesc, newDesc);\n                casHead(first, next);\n            }\n        }\n    }",
      "line_number": 222,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 237,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 241,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankQueue",
      "method_type": "method"
    },
    {
      "name": "Node",
      "signature": "public Node(E val, int etid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicInteger"
      ],
      "dependencies": [
        "AtomicInteger"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 4,
      "source_code": "            value = val;\n            next = null;\n            enqTid = etid;\n            deqTid = new AtomicInteger(-1);\n        }",
      "line_number": 33,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "public boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 40,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "KoganPetrankNoSLQueue",
      "signature": "public KoganPetrankNoSLQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "Thread",
        "AtomicReference",
        "final"
      ],
      "dependencies": [
        "state.set",
        "Node",
        "length",
        "OpDesc",
        "set",
        "state.length",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        final Node<E> sentinel = new Node<E>(null, -1);\n        head = sentinel;\n        tail = sentinel;\n        state = new AtomicReferenceArray<OpDesc<E>>(NUM_THREADS);\n        for (int i = 0; i < state.length(); i++) {\n            state.set(i, new OpDesc<E>(-1, false, true, null));\n        }\n    }",
      "line_number": 84,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "constructor"
    },
    {
      "name": "maxPhase",
      "signature": "private long maxPhase() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "state.length",
        "get",
        "length"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long maxPhase = -1;\n        for (int i = 0; i < state.length(); i++) {\n            long phase = state.get(i).phase;\n            if (phase > maxPhase) {\n                maxPhase = phase;\n            }\n        }\n        return maxPhase;\n    }",
      "line_number": 109,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "isStillPending",
      "signature": "private boolean isStillPending(int tid, long ph) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return state.get(tid).pending && state.get(tid).phase <= ph;\n    }",
      "line_number": 121,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "enq",
      "signature": "public void enq(E value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "state.set",
        "Thread.currentThread",
        "Node",
        "OpDesc",
        "set",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // We better have consecutive thread ids, otherwise this will blow up\n        // TODO: replace this mechanism with something more flexible\n        final int TID = (int)(Thread.currentThread().getId() % NUM_THREADS);\n        long phase = maxPhase() + 1;\n        state.set(TID, new OpDesc<E>(phase, true, true, new Node<E>(value, TID)));\n        help(phase);\n        help_finish_enq();\n    }",
      "line_number": 126,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "help_enq",
      "signature": "private void help_enq(int tid, long phase) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "last.casNext",
        "get",
        "casNext",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        while (isStillPending(tid, phase)) {\n            Node<E> last = tail;\n            Node<E> next = last.next;\n            if (last == tail) {           // If it's tail it can't be self-linked\n                if (next == null) {\n                    if (isStillPending(tid, phase)) {\n                        if (last.casNext(next, state.get(tid).node)) {\n                            help_finish_enq();\n                            return;\n                        }\n                    }\n                } else {\n                    help_finish_enq();\n                }\n            }\n        }\n    }",
      "line_number": 137,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "help_finish_enq",
      "signature": "private void help_finish_enq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final Node<E> last = tail;\n        final Node<E> next = last.next;\n        if (next != null) {\n            int tid = next.enqTid;\n            final OpDesc<E> curDesc = state.get(tid);\n            if (last == tail && state.get(tid).node == next) {\n                final OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, false, true, next);\n                state.compareAndSet(tid, curDesc, newDesc);\n                casTail(last, next);\n            }\n        }\n    }",
      "line_number": 157,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "deq",
      "signature": "public E deq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread",
        "state.set",
        "get",
        "OpDesc",
        "set",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        // We better have consecutive thread ids, otherwise this will blow up\n        // TODO: replace this mechanism with something more flexible\n        final int TID = (int)(Thread.currentThread().getId() % NUM_THREADS);\n        long phase = maxPhase() + 1;\n        state.set(TID, new OpDesc<E>(phase, true, false, null));\n        help(phase);\n        help_finish_deq();\n        final Node<E> node = state.get(TID).node;\n        if (node == null) return null; // We return null instead of throwing an exception\n        return node.next.value;\n    }",
      "line_number": 172,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "help_deq",
      "signature": "private void help_deq(int tid, long phase) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "deqTid.compareAndSet",
        "state.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        while (isStillPending(tid, phase)) {\n            Node<E> first = head;\n            Node<E> last = tail;\n            Node<E> next = first.next;\n            if (first == head) {  // If it's still head then it's not self-linked\n                if (first == last) {\n                    if (next == null) {\n                        OpDesc<E> curDesc = state.get(tid);\n                        if (last == tail && isStillPending(tid, phase)) {\n                            OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, false, false, null);\n                            state.compareAndSet(tid, curDesc, newDesc);\n                        }\n                    } else {\n                        help_finish_enq();\n                    }\n                } else {\n                    OpDesc<E> curDesc = state.get(tid);\n                    Node<E> node = curDesc.node;\n                    if (!isStillPending(tid, phase)) break;\n                    if (first == head && node != first) {\n                        OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, true, false, first);\n                        if (!state.compareAndSet(tid, curDesc, newDesc)) {\n                            continue;\n                        }\n                    }\n                    first.deqTid.compareAndSet(-1, tid);\n                    help_finish_deq();\n                }\n            }\n        }\n    }",
      "line_number": 186,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "help_finish_deq",
      "signature": "private void help_finish_deq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "state.get",
        "deqTid.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final Node<E> first = head;\n        final Node<E> next = first.next;\n        int tid = first.deqTid.get();\n        if (tid != -1 && next != first) {\n            final OpDesc<E> curDesc = state.get(tid);\n            if (first == head && next != null) {\n                final OpDesc<E> newDesc = new OpDesc<E>(state.get(tid).phase, false, false, state.get(tid).node);\n                state.compareAndSet(tid, curDesc, newDesc);\n                casHead(first, next);\n            }\n        }\n    }",
      "line_number": 220,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 235,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/KoganPetrankNoSLQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 239,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "KoganPetrankNoSLQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 92,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "relaxedStoreNext",
      "signature": "void relaxedStoreNext(Node<E> newNext) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "putObject",
        "UNSAFE.putObject",
        "E"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            UNSAFE.putObject(this, nextOffset, newNext);\n        }",
      "line_number": 96,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "CRSimQueue",
      "signature": "public CRSimQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "        this(MAX_THREADS);\n    }",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRSimQueue",
      "method_type": "constructor"
    },
    {
      "name": "CRSimQueue",
      "signature": "public CRSimQueue(int maxThreads) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "Thread",
        "AtomicIntegerArray",
        "AtomicInteger"
      ],
      "dependencies": [
        "Node",
        "EnqState",
        "DeqState",
        "AtomicIntegerArray",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "immutable_object"
      ],
      "complexity_score": 26,
      "source_code": "        this.maxThreads = maxThreads;\n        enqueuers = new AtomicIntegerArray(maxThreads);\n        dequeuers = new AtomicIntegerArray(maxThreads);\n        items = (E[])new Object[maxThreads];        \n        final Node<E> sentinel = new Node<E>(null);\n        enqState = new EnqState<E>(sentinel, null, sentinel, new int[maxThreads]);\n        deqState = new DeqState<E>(sentinel, 0, (E[])new Object[maxThreads], new int[maxThreads]);\n    }",
      "line_number": 167,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRSimQueue",
      "method_type": "constructor"
    },
    {
      "name": "enqueue",
      "signature": "public boolean enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        enqueue(item, (int)(Thread.currentThread().getId() % maxThreads));\n        return true;\n    }",
      "line_number": 183,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item, final int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Thread",
        "final"
      ],
      "dependencies": [
        "applied.clone",
        "enqueuers.set",
        "Node",
        "get",
        "EnqState",
        "relaxedStoreNext",
        "set",
        "NullPointerException",
        "enqueuers.get",
        "prev.relaxedStoreNext",
        "clone",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 21,
      "source_code": "        if (item == null) throw new NullPointerException();\n        // Publish enqueue request\n        items[tid] = item;\n        final int newrequest = (enqState.applied[tid]+1)%2;\n        enqueuers.set(tid, newrequest);        \n        for (int iter = 0; iter < 3; iter++) {\n            final EnqState<E> lstate = enqState;\n            // Advance the tail if needed\n            if (lstate.tail.next != lstate.nextNode) lstate.tail.next = lstate.nextNode;\n            // Check if my request has been done\n            if (lstate.applied[tid] == newrequest) return;\n            // Help other requests, starting from zero\n            Node<E> first = null, node = null;\n            int[] applied = lstate.applied.clone();\n            for (int i = 0; i < maxThreads; i++) {\n                // Check if it is an open request\n                if (enqueuers.get(i) == applied[i]) continue;\n                applied[i] = (applied[i]+1) % 2;\n                Node<E> prev = node;\n                node = new Node<E>(items[i]);\n                if (first == null) {\n                    first = node;\n                } else {\n                    prev.relaxedStoreNext(node);  // We don't want the volatile store here\n                }\n                if (lstate != enqState) break;\n            }\n            // Try to apply the new sublist\n            if (lstate == enqState) casEnqState(lstate, new EnqState<E>(lstate.nextTail, first, node, applied));\n        }\n    }",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        return dequeue((int)(Thread.currentThread().getId() % maxThreads));        \n    }",
      "line_number": 226,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue(final int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "applied.clone",
        "get",
        "DeqState",
        "set",
        "items.clone",
        "dequeuers.set",
        "dequeuers.get",
        "clone",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        DeqState<E> lstate = deqState;\n        // Start by checking if the queue is empty\n        if (lstate.head.next == null) return null;\n        // Publish dequeue request\n        final int newrequest = (lstate.applied[tid]+1) % 2;\n        dequeuers.set(tid, newrequest);\n        for (int iter = 0; iter < 2; iter++) {\n            lstate = deqState;\n            if (lstate.applied[tid] == newrequest) break;\n            // Help opened dequeue requests, starting from turn+1\n            Node<E> newHead = lstate.head;\n            int newTurn = lstate.turn;\n            E[] items = lstate.items.clone();\n            int[] applied = lstate.applied.clone();\n            Node<E> node = lstate.head;            \n            for (int j = 1; j < maxThreads+1; j++) {\n                final int i = (j + lstate.turn) % maxThreads;\n                // Check if it is an open request\n                if (dequeuers.get(i) == applied[i]) continue;\n                applied[i] = (applied[i]+1) % 2;\n                final Node<E> lnext = node.next;\n                if (lnext == null) {\n                    items[i] = null;\n                } else {\n                    node = lnext;\n                    items[i] = node.item;\n                    newHead = node;\n                    newTurn = i;\n                }\n                if (lstate != deqState) break;\n            }\n            if (lstate != deqState) continue;\n            if (casDeqState(lstate, new DeqState<E>(newHead, newTurn, items, applied))) break; \n        }\n        return deqState.items[tid];\n    }",
      "line_number": 230,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "casEnqState",
      "signature": "private boolean casEnqState(EnqState<E> cmp, EnqState<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, enqStateOffset, cmp, val);\n    }",
      "line_number": 269,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "casDeqState",
      "signature": "private boolean casDeqState(DeqState<E> cmp, DeqState<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRSimQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, deqStateOffset, cmp, val);\n    }",
      "line_number": 273,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRSimQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 66,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "casDeqTid",
      "signature": "boolean casDeqTid(int cmp, int val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "UNSAFE.compareAndSwapInt",
        "compareAndSwapInt"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapInt(this, deqTidOffset, cmp, val);\n        }",
      "line_number": 70,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "CRTurnQueue",
      "signature": "public CRTurnQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "        this(MAX_THREADS);\n    }",
      "line_number": 105,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRTurnQueue",
      "method_type": "constructor"
    },
    {
      "name": "CRTurnQueue",
      "signature": "public CRTurnQueue(int maxThreads) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "Thread",
        "AtomicReference"
      ],
      "dependencies": [
        "lazySet",
        "deqhelp.lazySet",
        "Node",
        "deqself.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        this.maxThreads = maxThreads;\n        Node<E> sentinelNode = new Node<E>(null, 0);\n        head = sentinelNode;\n        tail = sentinelNode;\n        enqueuers = new AtomicReferenceArray<Node<E>>(maxThreads);\n        deqhelp = new AtomicReferenceArray<Node<E>>(maxThreads);\n        deqself = new AtomicReferenceArray<Node<E>>(maxThreads);\n        for (int i=0; i < maxThreads; i++) {\n            // deqself[i] != deqhelp[i] means that isRequest=false\n            deqself.lazySet(i, sentinelNode);\n            deqhelp.lazySet(i, new Node<E>(null, 0));\n        }        \n    }",
      "line_number": 109,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRTurnQueue",
      "method_type": "constructor"
    },
    {
      "name": "getIndex",
      "signature": "private int getIndex() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        return (int)(Thread.currentThread().getId() % maxThreads);\n    }",
      "line_number": 124,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        enqueue(item, getIndex());\n    }",
      "line_number": 129,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item, final int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "enqueuers.compareAndSet",
        "lazySet",
        "compareAndSet",
        "enqueuers.set",
        "Node",
        "get",
        "set",
        "NullPointerException",
        "enqueuers.get",
        "casNext",
        "ltail.casNext",
        "enqueuers.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "        if (item == null) throw new NullPointerException();\n        final Node<E> myNode = new Node<E>(item, tid);\n        enqueuers.set(tid, myNode);                    // Do step 1: add node to enqueuers[]\n        for (int i = 0; i < maxThreads; i++) {\n            Node<E> ltail = tail;\n            if (enqueuers.get(ltail.enqTid) == ltail) {  // Help a thread do step 4\n                enqueuers.compareAndSet(ltail.enqTid, ltail, null);\n            }\n            if (enqueuers.get(tid) == null) return;    // Some thread helped me and did all the work, yupiii! (INV3)\n            for (int j = 1; j < maxThreads+1; j++) {     // Help a thread do step 2\n                Node<E> nodeToHelp = enqueuers.get((j + ltail.enqTid) % maxThreads);\n                if (nodeToHelp == null) continue;\n                ltail.casNext(null, nodeToHelp);\n                break;\n            }\n            Node<E> lnext = ltail.next;                  // Help a thread do step 3\n            if (lnext != null) casTail(ltail, lnext);\n        }\n        enqueuers.lazySet(tid, null);                  // Do step 4, just in case it's not done \n    }",
      "line_number": 144,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "searchNext",
      "signature": "private int searchNext(Node<E> lhead, Node<E> lnext) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "lnext.casDeqTid",
        "deqhelp.get",
        "get",
        "deqself.get",
        "casDeqTid",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        final int turn = lhead.deqTid;\n        for (int idx=turn+1; idx < turn+maxThreads+1; idx++) {\n            final int idDeq = idx%maxThreads;\n            // It's a request if the two entries are the same.\n            if (deqself.get(idDeq) != deqhelp.get(idDeq)) continue;\n            if (lnext.deqTid == IDX_NONE) lnext.casDeqTid(IDX_NONE, idDeq);\n            break;\n        }\n        return lnext.deqTid;\n    }",
      "line_number": 171,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "casDeqAndCasHead",
      "signature": "private void casDeqAndCasHead(Node<E> lhead, Node<E> lnext, int myidx) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "lazySet",
        "compareAndSet",
        "deqhelp.get",
        "deqhelp.lazySet",
        "get",
        "deqhelp.compareAndSet",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        final int ldeqTid = lnext.deqTid;\n        if (ldeqTid == myidx) {\n            deqhelp.lazySet(ldeqTid, lnext);\n        } else {\n            final Node<E> ldeqhelp = deqhelp.get(ldeqTid);\n            if (ldeqhelp != lnext && lhead == head) {\n                deqhelp.compareAndSet(ldeqTid, ldeqhelp, lnext); // Assign next to request\n            }\n        }\n        casHead(lhead, lnext);\n        lhead.next = lhead;     // Self-linking to help the GC\n    }",
      "line_number": 184,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "giveUp",
      "signature": "private void giveUp(Node<E> req, int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lnext.casDeqTid",
        "deqhelp.get",
        "get",
        "casDeqTid",
        "E"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        Node<E> lhead = head;\n        if (deqhelp.get(tid) != req) return;\n        if (lhead == tail) return;        \n        Node<E> lnext = lhead.next;\n        if (lhead != head) return;\n        // make sure Node next is assign to a request for dequeue\n        if (searchNext(lhead, lnext) == IDX_NONE) {\n            lnext.casDeqTid(IDX_NONE, tid);\n        }\n        casDeqAndCasHead(lhead, lnext, tid);\n    }",
      "line_number": 199,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return dequeue(getIndex());\n    }",
      "line_number": 214,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue(final int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "deqhelp.get",
        "get",
        "set",
        "deqself.get",
        "deqself.set",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        final Node<E> prReq = deqself.get(tid);\n        final Node<E> myReq = deqhelp.get(tid);\n        deqself.set(tid, myReq);             // isRequest=true\n        for (int i=0; i < maxThreads; i++) {\n            if (deqhelp.get(tid) != myReq) break;\n            Node<E> lhead = head;\n            if (lhead == tail) {         // Give up\n                deqself.set(tid,prReq);  // isRequest=false\n                giveUp(myReq, tid);\n                if (deqhelp.get(tid) != myReq) {\n                    deqself.set(tid, myReq);\n                    break;\n                }\n                return null;\n            }\n            Node<E> lnext = lhead.next;\n            if (lhead != head) continue;\n            if (searchNext(lhead, lnext) != IDX_NONE) casDeqAndCasHead(lhead, lnext, tid);\n        }\n        Node<E> myNode = deqhelp.get(tid);   \n        Node<E> lhead = head;\n        // Check if step 4 is needed for my node.\n        if (lhead == head && myNode == lhead.next) {\n            casHead(lhead, myNode);\n            lhead.next = lhead;      // Self-linking to help the GC\n        }\n        return myNode.item;\n    }",
      "line_number": 228,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 259,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRTurnQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 263,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRTurnQueue",
      "method_type": "method"
    },
    {
      "name": "CRDoubleLinkQueue",
      "signature": "public CRDoubleLinkQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRDoubleLinkQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Node",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final Node<E> prevSentinel = new Node<E>(null);\n        final Node<E> startSentinel = new Node<E>(null);\n        startSentinel.prev = prevSentinel;\n        prevSentinel.next = startSentinel;\n        head = startSentinel;\n        tail = startSentinel;\n    }",
      "line_number": 96,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRDoubleLinkQueue",
      "method_type": "constructor"
    },
    {
      "name": "enqueue",
      "signature": "public boolean enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRDoubleLinkQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "Node",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 6,
      "source_code": "        if (item == null) throw new NullPointerException();\n        final Node<E> newNode = new Node<E>(item);\n        while (true) {\n            final Node<E> ltail = tail;\n            final Node<E> lprev = ltail.prev;\n            // Help the previous enqueue() to complete\n            if (lprev.next == null && lprev != ltail) lprev.next = ltail;          \n            newNode.prev = ltail;\n            if (casTail(ltail, newNode)) {\n                ltail.next = newNode;        // This can be relaxed because the dequeuer helps to link the tail\n                return true;\n            }\n        }\n    }",
      "line_number": 117,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRDoubleLinkQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRDoubleLinkQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        while (true) {\n            final Node<E> lhead = head;\n            // Help the previous enqueue() to complete\n            final Node<E> ltail = tail;\n            final Node<E> lprev = ltail.prev;\n            if (lprev.next == null && lprev != ltail) lprev.next = ltail;\n            final Node<E> lnext = lhead.next; \n            if (lhead == ltail || lnext == null) return null;  // Queue is empty\n            if (lnext == lhead) continue;    // Re-read head if it's self-linked\n            if (casHead(lhead, lnext)) {\n                lnext.prev = lnext;          // Do self-linking to help the GC. This is a relaxed store\n                lhead.next = lhead;          // Can be a relaxed store\n                return lnext.item;\n            }\n        }\n    }",
      "line_number": 141,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRDoubleLinkQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRDoubleLinkQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 159,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRDoubleLinkQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/CRDoubleLinkQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 163,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "CRDoubleLinkQueue",
      "method_type": "method"
    },
    {
      "name": "tid2hash",
      "signature": "private int tid2hash() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/ResLinMonStatisticalCounter.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        long x = Thread.currentThread().getId();\n        x ^= (x << 21);\n        x ^= (x >>> 35);\n        x ^= (x << 4);\n        final int idx = (int)(((kNumCounters-1) & x)*CACHE_LINE);\n        return idx;\n    }",
      "line_number": 72,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ResLinMonStatisticalCounter",
      "method_type": "method"
    },
    {
      "name": "increment",
      "signature": "public void increment() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/ResLinMonStatisticalCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "getAndIncrement",
        "counters.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        counters.getAndIncrement(tid2hash());\n    }",
      "line_number": 92,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ResLinMonStatisticalCounter",
      "method_type": "method"
    },
    {
      "name": "decrement",
      "signature": "public void decrement() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/ResLinMonStatisticalCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndDecrement"
      ],
      "dependencies": [
        "counters.getAndDecrement",
        "getAndDecrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        counters.getAndDecrement(tid2hash());\n    }",
      "line_number": 107,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "ResLinMonStatisticalCounter",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/ResLinMonStatisticalCounter.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "get",
        "localCounters.get"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        long sum = 0;\n        final AtomicLongArray localCounters = counters;\n        for (int idx = 0; idx < kNumCounters*CACHE_LINE; idx += CACHE_LINE) {\n            sum += localCounters.get(idx); \n        }\n        return sum;\n    }",
      "line_number": 119,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ResLinMonStatisticalCounter",
      "method_type": "method"
    },
    {
      "name": "reset",
      "signature": "public void reset() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/ResLinMonStatisticalCounter.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicLongArray"
      ],
      "dependencies": [
        "AtomicLongArray"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        counters = new AtomicLongArray(kNumCounters*CACHE_LINE);\n    }    ",
      "line_number": 136,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ResLinMonStatisticalCounter",
      "method_type": "method"
    },
    {
      "name": "tid2hash",
      "signature": "private int tid2hash() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        long x = Thread.currentThread().getId();\n        x ^= (x << 21);\n        x ^= (x >>> 35);\n        x ^= (x << 4);\n        final int idx = (int)(((kNumCounters-1) & x)*CACHE_LINE);\n        return idx;\n    }",
      "line_number": 63,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "DistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "increment",
      "signature": "public void increment() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement"
      ],
      "dependencies": [
        "getAndIncrement",
        "counters.getAndIncrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        counters.getAndIncrement(tid2hash());\n    }",
      "line_number": 83,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "DistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "decrement",
      "signature": "public void decrement() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [
        "getAndDecrement"
      ],
      "dependencies": [
        "counters.getAndDecrement",
        "getAndDecrement"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        counters.getAndDecrement(tid2hash());\n    }",
      "line_number": 98,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "DistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "counters.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        long sum = 0;\n        for (int idx = 0; idx < kNumCounters*CACHE_LINE; idx += CACHE_LINE) {\n            sum += counters.get(idx); \n        }\n        return sum;\n    }",
      "line_number": 110,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "DistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void clear() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounter.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "counters.set",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 2,
      "source_code": "        for (int idx = 0; idx < kNumCounters*CACHE_LINE; idx += CACHE_LINE) {\n            counters.set(idx, 0); \n        }\n    }    ",
      "line_number": 123,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "DistributedCacheLineCounter",
      "method_type": "method"
    },
    {
      "name": "checkedByteOffset",
      "signature": "private long checkedByteOffset(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounterRelax.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "IndexOutOfBoundsException"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        if (i < 0 || i >= counters.length)\n            throw new IndexOutOfBoundsException(\"index \" + i);\n        return byteOffset(i);\n    }",
      "line_number": 82,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "DistributedCacheLineCounterRelax",
      "method_type": "method"
    },
    {
      "name": "byteOffset",
      "signature": "private static long byteOffset(int i) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounterRelax.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 1,
      "source_code": "        return ((long) i << shift) + base;\n    }",
      "line_number": 88,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "DistributedCacheLineCounterRelax",
      "method_type": "method"
    },
    {
      "name": "tid2hash",
      "signature": "private int tid2hash() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounterRelax.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        long x = Thread.currentThread().getId();\n        x ^= (x << 21);\n        x ^= (x >>> 35);\n        x ^= (x << 4);\n        final int idx = (int)(((kNumCounters-1) & x)*CACHE_LINE);\n        return idx;\n    }",
      "line_number": 96,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "DistributedCacheLineCounterRelax",
      "method_type": "method"
    },
    {
      "name": "increment",
      "signature": "public void increment() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounterRelax.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [
        "getAndAddLong",
        "UNSAFE.getAndAddLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.getAndAddLong(counters, checkedByteOffset(tid2hash()), 1);\n    }",
      "line_number": 116,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "DistributedCacheLineCounterRelax",
      "method_type": "method"
    },
    {
      "name": "decrement",
      "signature": "public void decrement() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounterRelax.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [
        "getAndAddLong",
        "UNSAFE.getAndAddLong"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        UNSAFE.getAndAddLong(counters, checkedByteOffset(tid2hash()), -1);\n    }",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "DistributedCacheLineCounterRelax",
      "method_type": "method"
    },
    {
      "name": "sum",
      "signature": "public long sum() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/DistributedCacheLineCounterRelax.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [
        "UNSAFE.loadFence",
        "loadFence"
      ],
      "concurrency_patterns": [],
      "complexity_score": 5,
      "source_code": "        long sum = aVolatileLoad;\n        for (int idx = 0; idx < kNumCounters*CACHE_LINE; idx += CACHE_LINE) {\n            sum += counters[idx]; \n        }\n        UNSAFE.loadFence();\n        return sum;\n    }",
      "line_number": 146,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "memory_management",
      "class_name": "DistributedCacheLineCounterRelax",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public long get() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/OffByXCounter.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        return counterVolatile;\n    }",
      "line_number": 68,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "OffByXCounter",
      "method_type": "method"
    },
    {
      "name": "increment",
      "signature": "public void increment() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/OffByXCounter.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 4,
      "source_code": "        counter++;\n        if ((counter & bitflag) == 0) counterVolatile = counter;\n    }",
      "line_number": 81,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "OffByXCounter",
      "method_type": "method"
    },
    {
      "name": "clear",
      "signature": "public void clear() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/counter/OffByXCounter.java",
      "language": "java",
      "sync_primitives": [
        "volatile"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 3,
      "source_code": "        counter = 0;\n        counterVolatile = 0;\n    }",
      "line_number": 90,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "OffByXCounter",
      "method_type": "method"
    },
    {
      "name": "DoubleInstanceLockGuard",
      "signature": "public DoubleInstanceLockGuard(E instance1, E instance2) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/doubleinstance/DoubleInstanceLockGuard.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "Thread",
        "ReentrantLock",
        "lock",
        "ThreadLocal"
      ],
      "dependencies": [
        "ReentrantLock",
        "LongAdderStampedRWLock",
        "ThreadLocal"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 34,
      "source_code": "        this.instance1 = instance1;\n        this.instance2 = instance2;       \n        writersMutex = new ReentrantLock();\n        rwlock1 = new LongAdderStampedRWLock();\n        rwlock2 = new LongAdderStampedRWLock();\n        heldLock = new ThreadLocal<LongAdderStampedRWLock>();\n    }",
      "line_number": 100,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "allows",
      "method_type": "method"
    },
    {
      "name": "readLock",
      "signature": "public E readLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/doubleinstance/DoubleInstanceLockGuard.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "sharedTryLock",
        "set",
        "rwlock1.sharedTryLock",
        "heldLock.set",
        "rwlock2.sharedTryLock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 46,
      "source_code": "        while (true) {\n            if (rwlock1.sharedTryLock()) {\n                heldLock.set(rwlock1);\n                return instance1;\n            }\n            if (rwlock2.sharedTryLock()) {\n                heldLock.set(rwlock2);\n                return instance2;\n            }\n        }\n    }",
      "line_number": 114,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "allows",
      "method_type": "method"
    },
    {
      "name": "readUnlock",
      "signature": "public void readUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/doubleinstance/DoubleInstanceLockGuard.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "sharedUnlock",
        "get",
        "heldLock.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        heldLock.get().sharedUnlock();\n    }",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "allows",
      "method_type": "method"
    },
    {
      "name": "writeLock",
      "signature": "public E writeLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/doubleinstance/DoubleInstanceLockGuard.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "rwlock2.exclusiveLock",
        "lock",
        "writersMutex.lock",
        "exclusiveLock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "singleton_pattern"
      ],
      "complexity_score": 16,
      "source_code": "    \twritersMutex.lock();   \t\n    \trwlock2.exclusiveLock();\n    \treturn instance1;\n    }",
      "line_number": 141,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "allows",
      "method_type": "method"
    },
    {
      "name": "writeToggle",
      "signature": "public E writeToggle() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/doubleinstance/DoubleInstanceLockGuard.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "rwlock2.exclusiveUnlock",
        "rwlock1.exclusiveLock",
        "exclusiveUnlock",
        "exclusiveLock"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 16,
      "source_code": "        rwlock2.exclusiveUnlock();\n        rwlock1.exclusiveLock();\n        return instance2;\n    }",
      "line_number": 153,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "allows",
      "method_type": "method"
    },
    {
      "name": "writeUnlock",
      "signature": "public void writeUnlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/doubleinstance/DoubleInstanceLockGuard.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock"
      ],
      "dependencies": [
        "rwlock1.exclusiveUnlock",
        "unlock",
        "exclusiveUnlock",
        "writersMutex.unlock"
      ],
      "concurrency_patterns": [],
      "complexity_score": 16,
      "source_code": "        rwlock1.exclusiveUnlock();\n        writersMutex.unlock();\n    }",
      "line_number": 163,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "allows",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet() { super(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 47,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet(CopyableTreeSet<E> tree) { super(tree); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 48,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "copyOf",
      "signature": "public Object copyOf() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return new CopyableTreeSet<E>(this);\n        }",
      "line_number": 50,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyOnWriteMQWFTreeSet",
      "signature": "public CopyOnWriteMQWFTreeSet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super(new CopyableTreeSet<E>());\n    }",
      "line_number": 55,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "constructor"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "instance.contains"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.contains(key);\n    }",
      "line_number": 62,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.add",
        "add",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, Object _o1, Object _o2, TreeSet<E> tree) -> tree.add(_key));\n    }",
      "line_number": 69,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.remove",
        "remove",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, Object _o1, Object _o2,  TreeSet<E> tree) -> tree.remove(_key));\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "tree.addAll",
        "addAll"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(null, c, null, null, null, (E _nop1, Collection<? extends E> _c, E _nop3, Object _o1, Object _o2,  TreeSet<E> tree) -> tree.addAll(_c));\n    }    ",
      "line_number": 83,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public V get(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "instance.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.get(key);\n    }",
      "line_number": 65,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQLFTreeMap",
      "method_type": "method"
    },
    {
      "name": "containsKey",
      "signature": "public boolean containsKey(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "containsKey",
        "instance.containsKey"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.containsKey(key);\n    }",
      "line_number": 69,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQLFTreeMap",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public V put(K key, V value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.put",
        "K",
        "put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, value, null, (K _key, V _value, K _nop, TreeMap<K,V> tree) -> tree.put(_key, _value));\n    }",
      "line_number": 73,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "CopyOnWriteMQLFTreeMap",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(MutationNode<P1, P2, P3, P4, P5, C> cmp, MutationNode<P1, P2, P3, P4, P5, C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 231,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "Combined",
      "signature": "public Combined(MutationNode<P1,P2,P3,P4,P5,C> head, C instance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "            this.head = head;\n            this.instance = instance;\n        }",
      "line_number": 271,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "COWMutationQWF",
      "signature": "public COWMutationQWF(C cloneableInstance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "Thread",
        "AtomicReference"
      ],
      "dependencies": [
        "state.set",
        "P1",
        "Combined",
        "length",
        "OpDesc",
        "set",
        "state.length"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // The head starts by pointing at the same node as tail\n        combinedRef = new Combined(tail, cloneableInstance);\n        state = new AtomicReferenceArray<OpDesc<P1,P2,P3,P4,P5,C>>(NUM_THREADS);\n        for (int i = 0; i < state.length(); i++) {\n            state.set(i, new OpDesc<P1,P2,P3,P4,P5,C>(-1, false, null));\n        }\n\n    }",
      "line_number": 292,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "applyMutation",
      "signature": "public <R> R applyMutation(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, HexaFunction<P1, P2, P3, P4, P5, ? super C, R> mutativeFunc) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread",
        "P1",
        "Combined",
        "copyOf",
        "MutationNode",
        "apply",
        "R",
        "mutativeFunc.apply",
        "instance.copyOf",
        "mutation.apply"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        // We better have consecutive thread ids, otherwise this will blow up\n        // TODO: replace this mechanism with something more flexible, like the CLQ+Array+Finalizers\n        final int TID = (int)(Thread.currentThread().getId() % NUM_THREADS);\n\n        final MutationNode<P1,P2,P3,P4,P5,C> myNode = new MutationNode<P1,P2,P3,P4,P5,C>(mutativeFunc, p1, p2, p3, p4, p5, TID);\n        Combined<P1, P2, P3, P4, P5, C> curComb = combinedRef;\n        // Insert our node in the queue\n        enq(myNode, TID);\n        \n        // Clone the current instance and apply all mutations up until our node is reached\n        final C mutatedInstance = (C)curComb.instance.copyOf();\n        for (MutationNode<P1,P2,P3,P4,P5,C> mn = curComb.head.next; mn != myNode; mn = mn.next) {\n            mn.mutation.apply(mn.param1, mn.param2, mn.param3, mn.param4, mn.param5, mutatedInstance);\n        }\n        // Save the return value of the last mutation (ours). We don't care about the other return values.\n        final R retValue = mutativeFunc.apply(p1, p2, p3, p4, p5, mutatedInstance);\n               \n        // Create a new Combined with all the mutations up to ours (inclusive) \n        // and try to CAS the ref to it until it has our mutation.\n        final Combined<P1,P2,P3,P4,P5,C> newComb = new Combined<P1,P2,P3,P4,P5,C>(myNode, mutatedInstance);\n        do {\n            if (curComb != combinedRef) {\n                curComb = combinedRef;\n                MutationNode<P1,P2,P3,P4,P5,C> ltail = tail;\n                // Traverse the list until we reach the end, or our own node\n                for (MutationNode<P1,P2,P3,P4,P5,C> mn = curComb.head; mn != myNode; mn = mn.next)\n                    if (mn == ltail) return retValue; // Our mutation is visible\n            }\n        } while (!casRef(curComb, newComb));\n        // Our mutation is now visible to other threads (through combinedRef)\n        \n        return retValue;\n    }",
      "line_number": 316,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "maxPhase",
      "signature": "private long maxPhase() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "state.length",
        "get",
        "length"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long maxPhase = -1;\n        for (int i = 0; i < state.length(); i++) {\n            long phase = state.get(i).phase;\n            if (phase > maxPhase) {\n                maxPhase = phase;\n            }\n        }\n        return maxPhase;\n    }",
      "line_number": 367,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "isStillPending",
      "signature": "private boolean isStillPending(int tid, long ph) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return state.get(tid).pending && state.get(tid).phase <= ph;\n    }",
      "line_number": 379,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "enq",
      "signature": "private void enq(MutationNode<P1,P2,P3,P4,P5,C> myNode, int TID) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1",
        "state.set",
        "OpDesc",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        long phase = maxPhase() + 1;\n        state.set(TID, new OpDesc<P1,P2,P3,P4,P5,C>(phase, true, myNode));\n        help(phase);\n        help_finish_enq();\n    }",
      "line_number": 384,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "help_enq",
      "signature": "private void help_enq(int tid, long phase) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1",
        "last.casNext",
        "get",
        "casNext",
        "state.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        while (isStillPending(tid, phase)) {\n            MutationNode<P1,P2,P3,P4,P5,C> last = tail;\n            MutationNode<P1,P2,P3,P4,P5,C> next = last.next;\n            if (last == tail) {\n                if (next == null) {\n                    if (isStillPending(tid, phase)) {\n                        if (last.casNext(next, state.get(tid).node)) {\n                            help_finish_enq();\n                            return;\n                        }\n                    }\n                } else {\n                    help_finish_enq();\n                }\n            }\n        }\n    }",
      "line_number": 392,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "help_finish_enq",
      "signature": "private void help_finish_enq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "P1",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "state.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final MutationNode<P1,P2,P3,P4,P5,C> last = tail;\n        final MutationNode<P1,P2,P3,P4,P5,C> next = last.next;\n        if (next != null) {\n            int tid = next.enqTid;\n            final OpDesc<P1,P2,P3,P4,P5,C> curDesc = state.get(tid);\n            if (last == tail && state.get(tid).node == next) {\n                final OpDesc<P1,P2,P3,P4,P5,C> newDesc = new OpDesc<P1,P2,P3,P4,P5,C>(state.get(tid).phase, false, next);\n                state.compareAndSet(tid, curDesc, newDesc);\n                casTail(last, next);\n            }\n        }\n    }",
      "line_number": 412,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(MutationNode<P1,P2,P3,P4,P5,C> cmp, MutationNode<P1,P2,P3,P4,P5,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 447,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casRef",
      "signature": "private boolean casRef(Combined<P1,P2,P3,P4,P5,C> cmp, Combined<P1,P2,P3,P4,P5,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, refOffset, cmp, val);\n    }    ",
      "line_number": 451,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(MutationNode<P1, P2, P3, C> cmp, MutationNode<P1, P2, P3, C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "Combined",
      "signature": "public Combined(MutationNode<P1,P2,P3,C> head, C instance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "            this.head = head;\n            this.instance = instance;\n        }",
      "line_number": 214,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "COWMutationQLF",
      "signature": "public COWMutationQLF(C cloneableInstance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Combined"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        // The head starts by pointing at the same node as tail\n        combinedRef = new Combined(tail, cloneableInstance);\n    }",
      "line_number": 230,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "applyMutation",
      "signature": "public <R> R applyMutation(P1 param1, P2 param2, P3 param3, QuadFunction<P1, P2, P3, ? super C, R> mutativeFunc) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "P1",
        "Combined",
        "copyOf",
        "MutationNode",
        "apply",
        "R",
        "mutativeFunc.apply",
        "instance.copyOf",
        "mutation.apply"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        final MutationNode<P1,P2,P3,C> myNode = new MutationNode<P1,P2,P3,C>(param1, param2, param3, mutativeFunc);\n        Combined<P1,P2,P3,C> curComb = combinedRef;\n        // Insert our node in the queue\n        addToTail(myNode);\n        \n        // Clone the current instance and apply all mutations up until our node is reached\n        final C mutatedInstance = (C)curComb.instance.copyOf();\n        for (MutationNode<P1,P2,P3,C> mn = curComb.head.next; mn != myNode; mn = mn.next) {\n            mn.mutation.apply(mn.param1, mn.param2, mn.param3, mutatedInstance);\n        }\n        // Save the return value of the last mutation (ours). We don't care about the other return values.\n        final R retValue = mutativeFunc.apply(param1, param2, param3, mutatedInstance);\n               \n        // Create a new Combined with all the mutations up to ours (inclusive) \n        // and try to CAS the ref to it until it has our mutation.\n        final Combined<P1,P2,P3,C> newComb = new Combined<P1,P2,P3,C>(myNode, mutatedInstance);\n        do {\n            if (curComb != combinedRef) {\n                curComb = combinedRef;\n                MutationNode<P1,P2,P3,C> ltail = tail;\n                // Traverse the list until we reach the end, or our own node\n                for (MutationNode<P1,P2,P3,C> mn = curComb.head; mn != myNode; mn = mn.next)\n                    if (mn == ltail) return retValue; // Our mutation is visible\n            }\n        } while (!casRef(curComb, newComb));\n        // Our mutation is now visible to other threads (through combinedRef)\n        \n        return retValue;\n    }",
      "line_number": 243,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "addToTail",
      "signature": "private void addToTail(final MutationNode<P1,P2,P3,C> myNode) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "casNext",
        "P1",
        "localTail.casNext"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        while (true) {\n            final MutationNode<P1,P2,P3,C> localTail = tail;\n            final MutationNode<P1,P2,P3,C> node = localTail.next;\n            if (localTail == tail) {\n                if (node == null) {\n                    // localTail is last node\n                    if (localTail.casNext(null, myNode)) {\n                        casTail(localTail, myNode);\n                        return;\n                    }\n                } else {\n                    casTail(localTail, node);\n                }\n            }\n        }\n    }",
      "line_number": 283,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(MutationNode<P1,P2,P3,C> cmp, MutationNode<P1,P2,P3,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 301,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casRef",
      "signature": "private boolean casRef(Combined<P1,P2,P3,C> cmp, Combined<P1,P2,P3,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, refOffset, cmp, val);\n    }",
      "line_number": 305,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "treeSet.contains",
        "contains"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return treeSet.contains(key);\n    }",
      "line_number": 58,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "TreeSet",
        "add",
        "E",
        "unlock",
        "lock.lock",
        "lock",
        "lock.unlock",
        "newTreeSet.add"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        lock.lock();\n        try {\n            final TreeSet<E> newTreeSet = new TreeSet<E>(treeSet);\n            final boolean retValue = newTreeSet.add(key);\n            treeSet = newTreeSet;\n            return retValue;\n        } finally {\n            lock.unlock();\n        }\n    }",
      "line_number": 63,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "TreeSet",
        "unlock",
        "newTreeSet.remove",
        "lock.lock",
        "lock",
        "remove",
        "lock.unlock",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        lock.lock();\n        try {\n            final TreeSet<E> newTreeSet = new TreeSet<E>(treeSet);\n            final boolean retValue = newTreeSet.remove(key);\n            treeSet = newTreeSet;\n            return retValue;\n        } finally {\n            lock.unlock();\n        }\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "TreeSet",
        "unlock",
        "newTreeSet.addAll",
        "addAll",
        "lock.lock",
        "lock",
        "lock.unlock",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        lock.lock();\n        try {\n            final TreeSet<E> newTreeSet = new TreeSet<E>(treeSet);\n            final boolean retValue = newTreeSet.addAll(c);\n            treeSet = newTreeSet;\n            return retValue;\n        } finally {\n            lock.unlock();\n        }\n    }",
      "line_number": 89,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "size",
        "instance.size"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.size(); \n    }",
      "line_number": 103,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "isEmpty",
        "instance.isEmpty"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.isEmpty();\n    }",
      "line_number": 107,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "instance.contains"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.contains(o);\n    }",
      "line_number": 111,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "indexOf",
      "signature": "public int indexOf(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "indexOf",
        "instance.indexOf"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.indexOf(o);\n    }",
      "line_number": 115,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "lastIndexOf",
      "signature": "public int lastIndexOf(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lastIndexOf",
        "instance.lastIndexOf"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.lastIndexOf(o);\n    }",
      "line_number": 119,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public Object[] toArray() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.toArray",
        "toArray"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.toArray();\n    }",
      "line_number": 123,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(T[] a) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.toArray",
        "toArray",
        "T"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.toArray(a);\n    }",
      "line_number": 127,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public E get(int index) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "instance.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.get(index);\n    }",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "set",
      "signature": "public E set(int index, E element) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "array.set",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(element, null, index, null, null, (E _element, E _e2, Integer _index, Object _o2, Object _o3, ArrayList<E> array) -> \n        array.set(_index, _element)\n        );        \n    }",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFArrayList",
      "method_type": "method"
    },
    {
      "name": "CopyableArrayList",
      "signature": "public CopyableArrayList(CopyableArrayList<E> instance) { super(instance); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 51,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "size",
        "instance.size"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.size();\n    }",
      "line_number": 62,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "isEmpty",
        "instance.isEmpty"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.isEmpty();\n    }",
      "line_number": 66,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "instance.contains"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.contains(o);\n    }",
      "line_number": 70,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "indexOf",
      "signature": "public int indexOf(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "indexOf",
        "instance.indexOf"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.indexOf(o);\n    }",
      "line_number": 74,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "lastIndexOf",
      "signature": "public int lastIndexOf(Object o) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lastIndexOf",
        "instance.lastIndexOf"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.lastIndexOf(o);\n    }",
      "line_number": 78,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public Object[] toArray() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.toArray",
        "toArray"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.toArray();\n    }",
      "line_number": 82,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(T a[]) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.toArray",
        "toArray",
        "T"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.toArray(a);\n    }",
      "line_number": 86,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public E get(int index) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "instance.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.get(index);\n    }",
      "line_number": 90,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "set",
      "signature": "public E set(int index, E element) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFArrayList.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "list.set",
        "E",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(element, null, index, (E _element, Collection<? extends E> _nop, Integer _index, ArrayList<E> list) -> list.set(_index, _element));\n    }",
      "line_number": 94,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "imilar",
      "method_type": "method"
    },
    {
      "name": "BenchmarkTreeSets",
      "signature": "public BenchmarkTreeSets(int numThreads, int numMilis, CSVDatabase csvdb, int writePerMil) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "ConcurrentLinkedQueue",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [
        "CopyOnWriteMQLFCountTreeSet",
        "ReentrantLockTreeSet",
        "mqlfKMaxTreeSet.addAll",
        "CopyOnWriteLockTreeSet",
        "mqlfMaxThreadsTreeSet.addAll",
        "mqwfTreeSet.addAll",
        "StampedLockTreeSet",
        "add",
        "CRWWPLockTreeSet",
        "casTreeSet.addAll",
        "LeftRightTreeSet",
        "ConcurrentLinkedQueue",
        "CopyOnWriteMQLFMaxThreadsTreeSet",
        "addAll",
        "CopyOnWriteMQLFTreeSet",
        "mqlfTreeSet.addAll",
        "CopyOnWriteMQWFTreeSet",
        "clq.add",
        "out.println",
        "leftRightTreeSet.addAll",
        "UserData",
        "mqlfCountTreeSet.addAll",
        "CopyOnWriteMQLFKMaxTreeSet",
        "crwwpTreeSet.addAll",
        "cowlockTreeSet.addAll",
        "println",
        "CopyOnWriteCASTreeSet",
        "mutexTreeSet.addAll",
        "stampedTreeSet.addAll"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 49,
      "source_code": "        clq = new ConcurrentLinkedQueue<UserData>();\n        //mutexTreeSet = new ReentrantLockTreeSet<UserData>();\n        //stampedTreeSet = new StampedLockTreeSet<UserData>();\n        //crwwpTreeSet = new CRWWPLockTreeSet<UserData>();\n        //leftRightTreeSet = new LeftRightTreeSet<UserData>();\n        cowlockTreeSet = new CopyOnWriteLockTreeSet<UserData>();\n        casTreeSet = new CopyOnWriteCASTreeSet<UserData>();\n        mqlfTreeSet = new CopyOnWriteMQLFTreeSet<UserData>();\n        mqwfTreeSet = new CopyOnWriteMQWFTreeSet<UserData>();\n        mqlfCountTreeSet = new CopyOnWriteMQLFCountTreeSet<UserData>();\n        mqlfKMaxTreeSet = new CopyOnWriteMQLFKMaxTreeSet<UserData>();\n        mqlfMaxThreadsTreeSet = new CopyOnWriteMQLFMaxThreadsTreeSet<UserData>();\n        \n        this.numMilis = numMilis;\n        this.csvdb = csvdb;\n        this.writePerMil = writePerMil;\n        udArray = new UserData[numElements];\n        for (int i = 0; i < numElements; i++) {\n            udArray[i] = new UserData();\n            udArray[i].a = i;\n            udArray[i].b = i % 7;\n        }\n                \n        System.out.println(\"Filling up data structures\");\n        for (int i = 0; i < numElements; i++) clq.add(udArray[i]);\n        //mutexTreeSet.addAll(clq);\n        //stampedTreeSet.addAll(clq);\n        //crwwpTreeSet.addAll(clq);\n        //leftRightTreeSet.addAll(clq);\n        cowlockTreeSet.addAll(clq);\n        casTreeSet.addAll(clq);\n        mqlfTreeSet.addAll(clq);\n        mqwfTreeSet.addAll(clq);\n        mqlfCountTreeSet.addAll(clq);\n        mqlfKMaxTreeSet.addAll(clq);\n        mqlfMaxThreadsTreeSet.addAll(clq);\n\n        workerThreads = new WorkerThread[numThreads];\n        latencyThreads = new LatencyThread[numThreads];\n    }",
      "line_number": 95,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "constructor"
    },
    {
      "name": "performanceTests",
      "signature": "public void performanceTests(int numThreads, int numRuns) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 48,
      "source_code": "        /* Performance tests */\n        double writePercentage = writePerMil == 0 ? 0 : writePerMil/10.;\n        System.out.println(\"----- numThreads=\" +numThreads+\"  Writes=\"+writePercentage+\"%  numElements=\"+numElements+\"  numRuns=\"+numRuns+\" -----\");        \n        //singleThroughputTest(numThreads, TestCase.ReentrantLockTreeSet, numRuns);\n        //singleThroughputTest(numThreads, TestCase.StampedLockTreeSet, numRuns);\n        //singleThroughputTest(numThreads, TestCase.CRWWPLockTreeSet, numRuns);\n        //singleThroughputTest(numThreads, TestCase.LeftRightTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteLockTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteCASTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteMQLFTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteMQWFTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteMQLFCountTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteMQLFKMaxTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteMQLFMaxThreadsTreeSet, numRuns);\n        System.out.println(); \n    }",
      "line_number": 142,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "singleThroughputTest",
      "signature": "public void singleThroughputTest(int numThreads, TestCase type, int numRuns) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "addRunDedicated",
        "length",
        "Thread.sleep",
        "csvdb.addRun",
        "join",
        "out.print",
        "Arrays.sort",
        "type.toString",
        "e.printStackTrace",
        "sort",
        "start",
        "printStackTrace",
        "out.println",
        "print",
        "addRun",
        "csvdb.addRunDedicated",
        "copyOf",
        "substring",
        "toString",
        "sleep",
        "println",
        "WorkerThread",
        "Arrays.copyOf"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 62,
      "source_code": "        // If we see an error here just increase the number of spaces\n        String indentedName = type.toString() + \"                                 \".substring(type.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n        long[] numAddRemoves = new long[numRuns];\n        long[] numContains = new long[numRuns];\n\n        for (int irun = 0; irun < numRuns; irun++) {\n            // Create the threads and then start them all in one go\n            for (int i = 0; i < numThreads; i++) {\n                workerThreads[i] = new WorkerThread(type, i);\n            }\n            for (int i = 0; i < numThreads; i++) workerThreads[i].start();\n    \n            // Sleep for 10 seconds\n            try {\n                Thread.sleep(numMilis);\n            } catch(InterruptedException e) {\n                System.out.println(\"InterruptedException\");\n            }\n            for (int i = 0; i < numThreads; i++) workerThreads[i].quit = true;\n                   \n            try {\n                for (int i = 0; i < numThreads; i++) workerThreads[i].join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            \n            numAddRemoves[irun] = 0;\n            numContains[irun] = 0;\n            for (int i = 0; i < numThreads; i++) {\n                numAddRemoves[irun] += workerThreads[i].numAddRemoves;\n                numContains[irun] += workerThreads[i].numContains;\n            }\n        }\n        \n        // Now compute the median\n        int medianRun = numRuns/2; // numRuns should be an odd number\n        long medianAddRemoves = 0;\n        long medianContains = 0;\n        if (numContains[0] != 0) {\n            long[] sortedCopy = Arrays.copyOf(numContains, numContains.length);\n            Arrays.sort(sortedCopy);\n            for (int irun = 0; irun < numRuns; irun++) {\n                if (sortedCopy[medianRun] == numContains[irun]) {\n                    medianAddRemoves = numAddRemoves[irun];\n ",
      "line_number": 164,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "singleLatencyTest",
      "signature": "public void singleLatencyTest(TestCase type) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "join",
        "out.print",
        "out.println",
        "sleep",
        "print",
        "println",
        "type.toString",
        "e.printStackTrace",
        "LatencyThread",
        "length",
        "Thread.sleep",
        "substring",
        "start",
        "printStackTrace",
        "toString"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 139,
      "source_code": "        \n        // If we see an error here just increase the number of spaces\n        String indentedName = type.toString() + \"                           \".substring(type.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n\n        // Create 16 threads and then start them all in one go\n        int numThreads = 16;\n        latencyThreads[0] = new LatencyThread(type, 0, true);\n        latencyThreads[1] = new LatencyThread(type, 1, true);\n        latencyThreads[2] = new LatencyThread(type, 2, true);\n        latencyThreads[3] = new LatencyThread(type, 3, true);\n        latencyThreads[4] = new LatencyThread(type, 4, true);\n        latencyThreads[5] = new LatencyThread(type, 5, true);\n        latencyThreads[6] = new LatencyThread(type, 6, true);\n        latencyThreads[7] = new LatencyThread(type, 7, true);\n        latencyThreads[8] = new LatencyThread(type, 8, false);\n        latencyThreads[9] = new LatencyThread(type, 9, false);\n        latencyThreads[10] = new LatencyThread(type, 10, false);\n        latencyThreads[11] = new LatencyThread(type, 11, false);\n        latencyThreads[12] = new LatencyThread(type, 12, false);\n        latencyThreads[13] = new LatencyThread(type, 13, false);\n        latencyThreads[14] = new LatencyThread(type, 14, false);\n        latencyThreads[15] = new LatencyThread(type, 15, false);\n        for (int i = 0; i < numThreads; i++) latencyThreads[i].start();\n\n        // Sleep for 10 seconds\n        try {\n            Thread.sleep(numMilis);\n        } catch(InterruptedException e) {\n            System.out.println(\"InterruptedException\");\n        }\n        for (int i = 0; i < numThreads; i++) latencyThreads[i].quit = true;\n               \n        try {\n            for (int i = 0; i < numThreads; i++) latencyThreads[i].join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        // Aggregate the CONTAINS histograms from all the Reader threads\n        final double[] contai",
      "line_number": 239,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "randomLong",
      "signature": "public static long randomLong(long x) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        x ^= (x << 21);\n        x ^= (x >>> 35);\n        x ^= (x << 4);\n        return x;\n    }",
      "line_number": 361,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "WorkerThread",
      "signature": "public WorkerThread(TestCase type, int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "            this.type = type;   \n            this.tid = tid;\n        }",
      "line_number": 379,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [
        "cowlockTreeSet.add",
        "mqlfMaxThreadsTreeSet.contains",
        "mqlfCountTreeSet.remove",
        "mqlfKMaxTreeSet.add",
        "mqlfMaxThreadsTreeSet.remove",
        "mqwfTreeSet.contains",
        "casTreeSet.contains",
        "mqlfCountTreeSet.add",
        "stampedTreeSet.add",
        "cowlockTreeSet.remove",
        "stampedTreeSet.contains",
        "casTreeSet.remove",
        "mqlfMaxThreadsTreeSet.add",
        "leftRightTreeSet.contains",
        "mqlfTreeSet.contains",
        "stampedTreeSet.remove",
        "mqwfTreeSet.add",
        "add",
        "mqlfKMaxTreeSet.remove",
        "mqwfTreeSet.remove",
        "crwwpTreeSet.remove",
        "mqlfCountTreeSet.contains",
        "cowlockTreeSet.contains",
        "System.nanoTime",
        "mqlfTreeSet.add",
        "mutexTreeSet.contains",
        "casTreeSet.add",
        "crwwpTreeSet.contains",
        "nanoTime",
        "contains",
        "crwwpTreeSet.add",
        "mutexTreeSet.add",
        "leftRightTreeSet.remove",
        "mqlfKMaxTreeSet.contains",
        "mqlfTreeSet.remove",
        "remove",
        "leftRightTreeSet.add",
        "mutexTreeSet.remove"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 70,
      "source_code": "            long xrand = System.nanoTime();\n            long x;\n            \n            while (!quit) {\n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                \n                UserData ud = udArray[(int)(x % numElements)];\n                \n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                \n                UserData ud1 = udArray[(int)(x % numElements)];\n                if ((writePerMil==-1 && (tid == 0 || tid == 1)) || \n                     (writePerMil != 0 && (x%1000) < writePerMil)) {\n                    // These two threads are doing remove/add\n                    switch (type) {\n                    /*\n                    case ReentrantLockTreeSet:\n                        mutexTreeSet.remove(ud);\n                        mutexTreeSet.add(ud);\n                        break;\n                    case StampedLockTreeSet:\n                        stampedTreeSet.remove(ud);\n                        stampedTreeSet.add(ud);\n                        break;\n                    case LeftRightTreeSet:\n                        leftRightTreeSet.remove(ud);\n                        leftRightTreeSet.add(ud);\n                        break;\n                    case CRWWPLockTreeSet:\n                        crwwpTreeSet.remove(ud);\n                        crwwpTreeSet.add(ud);\n                        break;\n                        */\n                    case CopyOnWriteLockTreeSet:\n                        cowlockTreeSet.remove(ud);\n                        cowlockTreeSet.add(ud);\n                        break;\n                    case CopyOnWriteCASTreeSet:\n                        casTreeSet.remove(ud);\n                        casTreeSet.add(ud);\n                        break;\n                    case CopyOnWriteMQLFTreeSet:\n                        mqlfTreeSet.remove(ud);\n                        mqlfTreeSet.add(ud);\n           ",
      "line_number": 385,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "LatencyThread",
      "signature": "public LatencyThread(TestCase type, int tid, boolean isReader) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "            this.type = type;   \n            this.tid = tid;\n            this.isReader = isReader;\n            switch (type) {\n            /*\n            case ReentrantLockTreeSet:\n                this.treeSet = mutexTreeSet;\n                break;\n            case StampedLockTreeSet:\n                this.treeSet = stampedTreeSet;\n                break;\n            case CRWWPLockTreeSet:\n                this.treeSet = crwwpTreeSet;\n                break;\n            case LeftRightTreeSet:\n                this.treeSet = leftRightTreeSet;\n                break;\n                */\n            case CopyOnWriteLockTreeSet:\n                this.treeSet = cowlockTreeSet;\n                break;\n            case CopyOnWriteCASTreeSet:\n                this.treeSet = casTreeSet;\n                break;                \n            case CopyOnWriteMQLFTreeSet:\n                this.treeSet = mqlfTreeSet;\n                break;                \n            case CopyOnWriteMQWFTreeSet:\n                this.treeSet = mqwfTreeSet;\n                break;                \n            case CopyOnWriteMQLFKMaxTreeSet:\n                this.treeSet = mqlfKMaxTreeSet;\n                break;              \n            default:\n                this.treeSet = null;\n                break;\n            } \n            for (int i = 0; i < MAX_LINEAR_HIST_BINS; i++) {\n                containsLatencyLinearHistogram[i] = 0;\n                addLatencyLinearHistogram[i] = 0;\n                removeLatencyLinearHistogram[i] = 0;\n            }\n        }",
      "line_number": 522,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "treeSet.add",
        "nanoTime",
        "contains",
        "add",
        "treeSet.remove",
        "treeSet.contains",
        "System.nanoTime",
        "remove"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "            long xrand = System.nanoTime();\n            long x; \n            \n            while (!quit) {\n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                UserData ud = udArray[(int)(x % numElements)];\n                if (!isReader) {\n                    long startBeats = 0, stopBeats = 0, numBeats;\n                    startBeats = System.nanoTime();\n                    treeSet.remove(ud);\n                    stopBeats = System.nanoTime();\n                    numBeats = stopBeats-startBeats;\n                    storeRemoveLinearLatency(numBeats);\n\n                    startBeats = System.nanoTime();\n                    treeSet.add(ud);\n                    stopBeats = System.nanoTime();\n                    numBeats = stopBeats-startBeats;\n                    storeAddLinearLatency(numBeats);\n                } else {                   \n                    long startBeats = System.nanoTime();\n                    treeSet.contains(ud);\n                    long stopBeats = System.nanoTime();\n                    final long numbeats = stopBeats-startBeats;\n                    storeContainsLinearLatency(numbeats);\n                }\n            }\n        }",
      "line_number": 567,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "throughputBenchmark",
      "signature": "static void throughputBenchmark() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "System.gc",
        "Arrays.asList",
        "Thread.sleep",
        "saveDB",
        "gc",
        "getRuntime",
        "performanceTests",
        "Integer",
        "csvdb.saveDB",
        "Runtime.getRuntime",
        "BenchmarkTreeSets",
        "asList",
        "out.println",
        "LinkedList",
        "sleep",
        "println",
        "tests.performanceTests",
        "availableProcessors",
        "CSVDatabase"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 100,
      "source_code": "        //final LinkedList<Integer> threadList = new LinkedList(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 28, 32, 36, 40, 64));\n        //final int numRuns = 5;\n        //final int durationSeconds = 20;\n        final LinkedList<Integer> threadList = new LinkedList(Arrays.asList(4));\n        final int numRuns = 1;  // On the paper it should be 5 runs\n        final int durationSeconds = 10;      // 20 seconds is the default for the paper\n        \n        final CSVDatabase csvdb = new CSVDatabase();      \n        final int sleepGCMiliSeconds = 1000; // Number of miliseconds to sleep between tests for the GC to enter \n        BenchmarkTreeSets tests;\n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n\n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1000, csvdb, 1000);\n            System.gc();\n            Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit                \n            tests.performanceTests(nThreads, numRuns);\n        }  // 50-50-0:  50% add() - 50% remove() - 0% contains() \n\n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1000, csvdb, 500);\n            System.gc();\n            Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit                \n            tests.performanceTests(nThreads, numRuns);\n        }  // 50%\n        \n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1000, csvdb, 100);\n            System.gc();\n            Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit                \n            tests.performanceTests(nThreads, numRuns);\n        }  // 10%\n\n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1",
      "line_number": 624,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "latencyBenchmark",
      "signature": "static void latencyBenchmark() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "sleep",
        "println",
        "tests.singleLatencyTest",
        "System.gc",
        "availableProcessors",
        "CSVDatabase",
        "Runtime.getRuntime",
        "Thread.sleep",
        "gc",
        "singleLatencyTest",
        "BenchmarkTreeSets",
        "getRuntime"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        final int durationSeconds = 1000;      // 1000  seconds (16 minutes) is the default for the paper\n        final CSVDatabase csvdb = new CSVDatabase();      \n        final int sleepGCMiliSeconds = 5000; // Number of miliseconds to sleep between tests for the GC to enter \n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n\n        BenchmarkTreeSets tests = new BenchmarkTreeSets(16, durationSeconds*1000, csvdb, 1000);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit\n        tests.singleLatencyTest(TestCase.CopyOnWriteCASTreeSet);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds);\n        tests.singleLatencyTest(TestCase.CopyOnWriteLockTreeSet);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds);\n        tests.singleLatencyTest(TestCase.CopyOnWriteMQLFTreeSet);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds);\n        tests.singleLatencyTest(TestCase.CopyOnWriteMQWFTreeSet);\n    }",
      "line_number": 691,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args)  throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        throughputBenchmark();\n        //latencyBenchmark();\n    }",
      "line_number": 716,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "get",
        "ref.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return ref.get().contains(key);\n    }",
      "line_number": 56,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "add",
        "TreeSet",
        "E",
        "get",
        "ref.compareAndSet",
        "ref.get",
        "newTreeSet.add"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        TreeSet<E> oldTreeSet, newTreeSet;\n        boolean retValue;\n        do {\n            oldTreeSet = ref.get();\n            newTreeSet = new TreeSet<E>(oldTreeSet);\n            retValue = newTreeSet.add(key);\n        } while (!ref.compareAndSet(oldTreeSet, newTreeSet));\n        return retValue;\n    }",
      "line_number": 61,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "TreeSet",
        "get",
        "ref.compareAndSet",
        "newTreeSet.remove",
        "ref.get",
        "remove",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        TreeSet<E> oldTreeSet, newTreeSet;\n        boolean retValue;\n        do {\n            oldTreeSet = ref.get();\n            newTreeSet = new TreeSet<E>(oldTreeSet);\n            retValue = newTreeSet.remove(key);\n        } while (!ref.compareAndSet(oldTreeSet, newTreeSet));\n        return retValue;\n    }",
      "line_number": 73,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "TreeSet",
        "get",
        "newTreeSet.addAll",
        "ref.compareAndSet",
        "addAll",
        "ref.get",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        TreeSet<E> oldTreeSet, newTreeSet;\n        boolean retValue;\n        do {\n            oldTreeSet = ref.get();\n            newTreeSet = new TreeSet<E>(oldTreeSet);\n            retValue = newTreeSet.addAll(c);\n        } while (!ref.compareAndSet(oldTreeSet, newTreeSet));\n        return retValue;\n    }",
      "line_number": 85,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet() { super(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 47,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet(CopyableTreeSet<E> tree) { super(tree); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 48,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "copyOf",
      "signature": "public Object copyOf() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return new CopyableTreeSet<E>(this);\n        }",
      "line_number": 50,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyOnWriteMQLFTreeSet",
      "signature": "public CopyOnWriteMQLFTreeSet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super(new CopyableTreeSet<E>());\n    }",
      "line_number": 55,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "constructor"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "instance.contains"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.contains(key);\n    }",
      "line_number": 62,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.add",
        "add",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.add(_key));\n    }",
      "line_number": 69,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.remove",
        "remove",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.remove(_key));\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "tree.addAll",
        "addAll"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(null, c, null, (E _nop, Collection<? extends E> _c, E _nop2, TreeSet<E> tree) -> tree.addAll(_c));\n    }",
      "line_number": 83,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "size",
        "instance.size"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.size(); \n    }",
      "line_number": 108,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "containsKey",
      "signature": "public boolean containsKey(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "containsKey",
        "instance.containsKey"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.containsKey(key); \n    }",
      "line_number": 112,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "containsValue",
      "signature": "public boolean containsValue(Object value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.containsValue",
        "containsValue"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.containsValue(value);\n    }",
      "line_number": 116,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "get",
      "signature": "public V get(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "instance.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.get(key);\n    }",
      "line_number": 120,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "comparator",
      "signature": "public Comparator<? super K> comparator() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.comparator",
        "comparator"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.comparator();\n    }",
      "line_number": 124,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "firstKey",
      "signature": "public K firstKey() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.firstKey",
        "firstKey"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.firstKey();\n    }",
      "line_number": 128,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "lastKey",
      "signature": "public K lastKey() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lastKey",
        "instance.lastKey"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.lastKey();\n    }    ",
      "line_number": 132,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "getEntry",
      "signature": "//final Entry<K,V> getEntry(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "entrySet",
        "instance.floorEntry",
        "instance.floorKey",
        "instance.descendingKeySet",
        "V",
        "instance.headMap",
        "remove",
        "tree.replaceAll",
        "pollFirstEntry",
        "tree.remove",
        "containsKey",
        "instance.higherEntry",
        "tree.put",
        "instance.navigableKeySet",
        "instance.lowerKey",
        "lowerEntry",
        "headMap",
        "instance.tailMap",
        "instance.lastEntry",
        "values",
        "replaceAll",
        "tree.containsKey",
        "instance.size",
        "subMap",
        "instance.firstEntry",
        "descendingKeySet",
        "firstEntry",
        "instance.values",
        "tree.pollFirstEntry",
        "ceilingEntry",
        "tree.replace",
        "put",
        "tree.putAll",
        "lowerKey",
        "tree.forEach",
        "navigableKeySet",
        "instance.ceilingEntry",
        "keySet",
        "instance.ceilingKey",
        "tailMap",
        "instance.entrySet",
        "instance.clone",
        "floorEntry",
        "size",
        "lastEntry",
        "higherEntry",
        "forEach",
        "tree.clear",
        "instance.descendingMap",
        "instance.keySet",
        "instance.lowerEntry",
        "tree.pollLastEntry",
        "descendingMap",
        "NullPointerException",
        "K",
        "putAll",
        "clear",
        "pollLastEntry",
        "replace",
        "ceilingKey",
        "clone",
        "floorKey",
        "instance.subMap"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 108,
      "source_code": "    //final Entry<K,V> getEntryUsingComparator(Object key) {\n    //final Entry<K,V> getCeilingEntry(K key) {\n    //final Entry<K,V> getFloorEntry(K key) {\n    //final Entry<K,V> getHigherEntry(K key) {\n    //final Entry<K,V> getLowerEntry(K key) {\n    \n    public Object clone() {\n        return combinedRef.instance.clone();        \n    }\n\n    public Map.Entry<K,V> firstEntry() {\n        return combinedRef.instance.firstEntry();\n    }\n    \n    public Map.Entry<K,V> lastEntry() {\n        return combinedRef.instance.lastEntry();\n    }\n\n    public Map.Entry<K,V> lowerEntry(K key) {\n        return combinedRef.instance.lowerEntry(key);\n    }\n    \n    public K lowerKey(K key) {\n        return combinedRef.instance.lowerKey(key);\n    }\n    \n    public Map.Entry<K,V> floorEntry(K key) {\n        return combinedRef.instance.floorEntry(key);\n    }\n    \n    public K floorKey(K key) {\n        return combinedRef.instance.floorKey(key);\n    }\n    \n    public Map.Entry<K,V> ceilingEntry(K key) {\n        return combinedRef.instance.ceilingEntry(key);\n    }\n    \n    public K ceilingKey(K key) {\n        return combinedRef.instance.ceilingKey(key);\n    }\n\n    public Map.Entry<K,V> higherEntry(K key) {\n        return combinedRef.instance.higherEntry(key);\n    }\n    \n    public Set<K> keySet() {\n        return combinedRef.instance.keySet();\n    }\n    \n    public NavigableSet<K> navigableKeySet() {\n        return combinedRef.instance.navigableKeySet();\n    }\n    \n    public NavigableSet<K> descendingKeySet() {\n        return combinedRef.instance.descendingKeySet();\n    }\n    \n    public Collection<V> values() {\n        return combinedRef.instance.values();\n    }\n    \n    public Set<Map.Entry<K,V>> entrySet() {\n        return combinedRef.instance.entrySet();\n    }\n    \n    public NavigableMap<K, V> descendingMap() {\n        return combinedRef.instance.descendingMap();\n    }\n    \n    public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,\n                                    K toKey,",
      "line_number": 136,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "getEntryUsingComparator",
      "signature": "//final Entry<K,V> getEntryUsingComparator(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "entrySet",
        "instance.floorEntry",
        "instance.floorKey",
        "instance.descendingKeySet",
        "V",
        "instance.headMap",
        "remove",
        "tree.replaceAll",
        "pollFirstEntry",
        "tree.remove",
        "containsKey",
        "instance.higherEntry",
        "tree.put",
        "instance.navigableKeySet",
        "instance.lowerKey",
        "lowerEntry",
        "headMap",
        "instance.tailMap",
        "instance.lastEntry",
        "values",
        "replaceAll",
        "tree.containsKey",
        "instance.size",
        "subMap",
        "instance.firstEntry",
        "descendingKeySet",
        "firstEntry",
        "instance.values",
        "tree.pollFirstEntry",
        "ceilingEntry",
        "tree.replace",
        "put",
        "tree.putAll",
        "lowerKey",
        "tree.forEach",
        "navigableKeySet",
        "instance.ceilingEntry",
        "keySet",
        "instance.ceilingKey",
        "tailMap",
        "instance.entrySet",
        "instance.clone",
        "floorEntry",
        "size",
        "lastEntry",
        "higherEntry",
        "forEach",
        "tree.clear",
        "instance.descendingMap",
        "instance.keySet",
        "instance.lowerEntry",
        "tree.pollLastEntry",
        "descendingMap",
        "NullPointerException",
        "K",
        "putAll",
        "clear",
        "pollLastEntry",
        "replace",
        "ceilingKey",
        "clone",
        "floorKey",
        "instance.subMap"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 104,
      "source_code": "    //final Entry<K,V> getCeilingEntry(K key) {\n    //final Entry<K,V> getFloorEntry(K key) {\n    //final Entry<K,V> getHigherEntry(K key) {\n    //final Entry<K,V> getLowerEntry(K key) {\n    \n    public Object clone() {\n        return combinedRef.instance.clone();        \n    }\n\n    public Map.Entry<K,V> firstEntry() {\n        return combinedRef.instance.firstEntry();\n    }\n    \n    public Map.Entry<K,V> lastEntry() {\n        return combinedRef.instance.lastEntry();\n    }\n\n    public Map.Entry<K,V> lowerEntry(K key) {\n        return combinedRef.instance.lowerEntry(key);\n    }\n    \n    public K lowerKey(K key) {\n        return combinedRef.instance.lowerKey(key);\n    }\n    \n    public Map.Entry<K,V> floorEntry(K key) {\n        return combinedRef.instance.floorEntry(key);\n    }\n    \n    public K floorKey(K key) {\n        return combinedRef.instance.floorKey(key);\n    }\n    \n    public Map.Entry<K,V> ceilingEntry(K key) {\n        return combinedRef.instance.ceilingEntry(key);\n    }\n    \n    public K ceilingKey(K key) {\n        return combinedRef.instance.ceilingKey(key);\n    }\n\n    public Map.Entry<K,V> higherEntry(K key) {\n        return combinedRef.instance.higherEntry(key);\n    }\n    \n    public Set<K> keySet() {\n        return combinedRef.instance.keySet();\n    }\n    \n    public NavigableSet<K> navigableKeySet() {\n        return combinedRef.instance.navigableKeySet();\n    }\n    \n    public NavigableSet<K> descendingKeySet() {\n        return combinedRef.instance.descendingKeySet();\n    }\n    \n    public Collection<V> values() {\n        return combinedRef.instance.values();\n    }\n    \n    public Set<Map.Entry<K,V>> entrySet() {\n        return combinedRef.instance.entrySet();\n    }\n    \n    public NavigableMap<K, V> descendingMap() {\n        return combinedRef.instance.descendingMap();\n    }\n    \n    public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,\n                                    K toKey,   boolean toInclusive) {\n        return combinedRef.instance",
      "line_number": 137,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "getCeilingEntry",
      "signature": "//final Entry<K,V> getCeilingEntry(K key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "entrySet",
        "instance.floorEntry",
        "instance.floorKey",
        "instance.descendingKeySet",
        "V",
        "instance.headMap",
        "remove",
        "tree.replaceAll",
        "pollFirstEntry",
        "tree.remove",
        "containsKey",
        "instance.higherEntry",
        "tree.put",
        "instance.navigableKeySet",
        "instance.lowerKey",
        "lowerEntry",
        "headMap",
        "instance.tailMap",
        "instance.lastEntry",
        "values",
        "replaceAll",
        "tree.containsKey",
        "instance.size",
        "subMap",
        "instance.firstEntry",
        "descendingKeySet",
        "firstEntry",
        "instance.values",
        "tree.pollFirstEntry",
        "ceilingEntry",
        "tree.replace",
        "put",
        "tree.putAll",
        "lowerKey",
        "tree.forEach",
        "navigableKeySet",
        "instance.ceilingEntry",
        "keySet",
        "instance.ceilingKey",
        "tailMap",
        "instance.entrySet",
        "instance.clone",
        "floorEntry",
        "size",
        "lastEntry",
        "higherEntry",
        "forEach",
        "tree.clear",
        "instance.descendingMap",
        "instance.keySet",
        "instance.lowerEntry",
        "tree.pollLastEntry",
        "descendingMap",
        "NullPointerException",
        "K",
        "putAll",
        "clear",
        "pollLastEntry",
        "replace",
        "ceilingKey",
        "clone",
        "floorKey",
        "instance.subMap"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 99,
      "source_code": "    //final Entry<K,V> getFloorEntry(K key) {\n    //final Entry<K,V> getHigherEntry(K key) {\n    //final Entry<K,V> getLowerEntry(K key) {\n    \n    public Object clone() {\n        return combinedRef.instance.clone();        \n    }\n\n    public Map.Entry<K,V> firstEntry() {\n        return combinedRef.instance.firstEntry();\n    }\n    \n    public Map.Entry<K,V> lastEntry() {\n        return combinedRef.instance.lastEntry();\n    }\n\n    public Map.Entry<K,V> lowerEntry(K key) {\n        return combinedRef.instance.lowerEntry(key);\n    }\n    \n    public K lowerKey(K key) {\n        return combinedRef.instance.lowerKey(key);\n    }\n    \n    public Map.Entry<K,V> floorEntry(K key) {\n        return combinedRef.instance.floorEntry(key);\n    }\n    \n    public K floorKey(K key) {\n        return combinedRef.instance.floorKey(key);\n    }\n    \n    public Map.Entry<K,V> ceilingEntry(K key) {\n        return combinedRef.instance.ceilingEntry(key);\n    }\n    \n    public K ceilingKey(K key) {\n        return combinedRef.instance.ceilingKey(key);\n    }\n\n    public Map.Entry<K,V> higherEntry(K key) {\n        return combinedRef.instance.higherEntry(key);\n    }\n    \n    public Set<K> keySet() {\n        return combinedRef.instance.keySet();\n    }\n    \n    public NavigableSet<K> navigableKeySet() {\n        return combinedRef.instance.navigableKeySet();\n    }\n    \n    public NavigableSet<K> descendingKeySet() {\n        return combinedRef.instance.descendingKeySet();\n    }\n    \n    public Collection<V> values() {\n        return combinedRef.instance.values();\n    }\n    \n    public Set<Map.Entry<K,V>> entrySet() {\n        return combinedRef.instance.entrySet();\n    }\n    \n    public NavigableMap<K, V> descendingMap() {\n        return combinedRef.instance.descendingMap();\n    }\n    \n    public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,\n                                    K toKey,   boolean toInclusive) {\n        return combinedRef.instance.subMap(fromKey, fromInclusive, toKey, toInclusi",
      "line_number": 138,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "getFloorEntry",
      "signature": "//final Entry<K,V> getFloorEntry(K key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "entrySet",
        "instance.floorEntry",
        "instance.floorKey",
        "instance.descendingKeySet",
        "V",
        "instance.headMap",
        "remove",
        "tree.replaceAll",
        "pollFirstEntry",
        "tree.remove",
        "containsKey",
        "instance.higherEntry",
        "tree.put",
        "instance.navigableKeySet",
        "instance.lowerKey",
        "lowerEntry",
        "headMap",
        "instance.tailMap",
        "instance.lastEntry",
        "values",
        "replaceAll",
        "tree.containsKey",
        "instance.size",
        "subMap",
        "instance.firstEntry",
        "descendingKeySet",
        "firstEntry",
        "instance.values",
        "tree.pollFirstEntry",
        "ceilingEntry",
        "tree.replace",
        "put",
        "tree.putAll",
        "lowerKey",
        "tree.forEach",
        "navigableKeySet",
        "instance.ceilingEntry",
        "keySet",
        "instance.ceilingKey",
        "tailMap",
        "instance.entrySet",
        "instance.clone",
        "floorEntry",
        "size",
        "lastEntry",
        "higherEntry",
        "forEach",
        "tree.clear",
        "instance.descendingMap",
        "instance.keySet",
        "instance.lowerEntry",
        "tree.pollLastEntry",
        "descendingMap",
        "NullPointerException",
        "K",
        "putAll",
        "clear",
        "pollLastEntry",
        "replace",
        "ceilingKey",
        "clone",
        "floorKey",
        "instance.subMap"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 95,
      "source_code": "    //final Entry<K,V> getHigherEntry(K key) {\n    //final Entry<K,V> getLowerEntry(K key) {\n    \n    public Object clone() {\n        return combinedRef.instance.clone();        \n    }\n\n    public Map.Entry<K,V> firstEntry() {\n        return combinedRef.instance.firstEntry();\n    }\n    \n    public Map.Entry<K,V> lastEntry() {\n        return combinedRef.instance.lastEntry();\n    }\n\n    public Map.Entry<K,V> lowerEntry(K key) {\n        return combinedRef.instance.lowerEntry(key);\n    }\n    \n    public K lowerKey(K key) {\n        return combinedRef.instance.lowerKey(key);\n    }\n    \n    public Map.Entry<K,V> floorEntry(K key) {\n        return combinedRef.instance.floorEntry(key);\n    }\n    \n    public K floorKey(K key) {\n        return combinedRef.instance.floorKey(key);\n    }\n    \n    public Map.Entry<K,V> ceilingEntry(K key) {\n        return combinedRef.instance.ceilingEntry(key);\n    }\n    \n    public K ceilingKey(K key) {\n        return combinedRef.instance.ceilingKey(key);\n    }\n\n    public Map.Entry<K,V> higherEntry(K key) {\n        return combinedRef.instance.higherEntry(key);\n    }\n    \n    public Set<K> keySet() {\n        return combinedRef.instance.keySet();\n    }\n    \n    public NavigableSet<K> navigableKeySet() {\n        return combinedRef.instance.navigableKeySet();\n    }\n    \n    public NavigableSet<K> descendingKeySet() {\n        return combinedRef.instance.descendingKeySet();\n    }\n    \n    public Collection<V> values() {\n        return combinedRef.instance.values();\n    }\n    \n    public Set<Map.Entry<K,V>> entrySet() {\n        return combinedRef.instance.entrySet();\n    }\n    \n    public NavigableMap<K, V> descendingMap() {\n        return combinedRef.instance.descendingMap();\n    }\n    \n    public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,\n                                    K toKey,   boolean toInclusive) {\n        return combinedRef.instance.subMap(fromKey, fromInclusive, toKey, toInclusive);\n    }\n    \n    public NavigableMap<K,V> h",
      "line_number": 139,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "getHigherEntry",
      "signature": "//final Entry<K,V> getHigherEntry(K key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "entrySet",
        "instance.floorEntry",
        "instance.floorKey",
        "instance.descendingKeySet",
        "V",
        "instance.headMap",
        "remove",
        "tree.replaceAll",
        "pollFirstEntry",
        "tree.remove",
        "containsKey",
        "instance.higherEntry",
        "tree.put",
        "instance.navigableKeySet",
        "instance.lowerKey",
        "lowerEntry",
        "headMap",
        "instance.tailMap",
        "instance.lastEntry",
        "values",
        "replaceAll",
        "tree.containsKey",
        "instance.size",
        "subMap",
        "instance.firstEntry",
        "descendingKeySet",
        "firstEntry",
        "instance.values",
        "tree.pollFirstEntry",
        "ceilingEntry",
        "tree.replace",
        "put",
        "tree.putAll",
        "lowerKey",
        "tree.forEach",
        "navigableKeySet",
        "instance.ceilingEntry",
        "keySet",
        "instance.ceilingKey",
        "tailMap",
        "instance.entrySet",
        "instance.clone",
        "floorEntry",
        "size",
        "lastEntry",
        "higherEntry",
        "forEach",
        "tree.clear",
        "instance.descendingMap",
        "instance.keySet",
        "instance.lowerEntry",
        "tree.pollLastEntry",
        "descendingMap",
        "NullPointerException",
        "K",
        "putAll",
        "clear",
        "pollLastEntry",
        "replace",
        "ceilingKey",
        "clone",
        "floorKey",
        "instance.subMap"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 90,
      "source_code": "    //final Entry<K,V> getLowerEntry(K key) {\n    \n    public Object clone() {\n        return combinedRef.instance.clone();        \n    }\n\n    public Map.Entry<K,V> firstEntry() {\n        return combinedRef.instance.firstEntry();\n    }\n    \n    public Map.Entry<K,V> lastEntry() {\n        return combinedRef.instance.lastEntry();\n    }\n\n    public Map.Entry<K,V> lowerEntry(K key) {\n        return combinedRef.instance.lowerEntry(key);\n    }\n    \n    public K lowerKey(K key) {\n        return combinedRef.instance.lowerKey(key);\n    }\n    \n    public Map.Entry<K,V> floorEntry(K key) {\n        return combinedRef.instance.floorEntry(key);\n    }\n    \n    public K floorKey(K key) {\n        return combinedRef.instance.floorKey(key);\n    }\n    \n    public Map.Entry<K,V> ceilingEntry(K key) {\n        return combinedRef.instance.ceilingEntry(key);\n    }\n    \n    public K ceilingKey(K key) {\n        return combinedRef.instance.ceilingKey(key);\n    }\n\n    public Map.Entry<K,V> higherEntry(K key) {\n        return combinedRef.instance.higherEntry(key);\n    }\n    \n    public Set<K> keySet() {\n        return combinedRef.instance.keySet();\n    }\n    \n    public NavigableSet<K> navigableKeySet() {\n        return combinedRef.instance.navigableKeySet();\n    }\n    \n    public NavigableSet<K> descendingKeySet() {\n        return combinedRef.instance.descendingKeySet();\n    }\n    \n    public Collection<V> values() {\n        return combinedRef.instance.values();\n    }\n    \n    public Set<Map.Entry<K,V>> entrySet() {\n        return combinedRef.instance.entrySet();\n    }\n    \n    public NavigableMap<K, V> descendingMap() {\n        return combinedRef.instance.descendingMap();\n    }\n    \n    public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,\n                                    K toKey,   boolean toInclusive) {\n        return combinedRef.instance.subMap(fromKey, fromInclusive, toKey, toInclusive);\n    }\n    \n    public NavigableMap<K,V> headMap(K toKey, boolean inclusive) {\n        re",
      "line_number": 140,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "getLowerEntry",
      "signature": "//final Entry<K,V> getLowerEntry(K key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "entrySet",
        "instance.floorEntry",
        "instance.floorKey",
        "instance.descendingKeySet",
        "V",
        "instance.headMap",
        "remove",
        "tree.replaceAll",
        "pollFirstEntry",
        "tree.remove",
        "containsKey",
        "instance.higherEntry",
        "tree.put",
        "instance.navigableKeySet",
        "instance.lowerKey",
        "lowerEntry",
        "headMap",
        "instance.tailMap",
        "instance.lastEntry",
        "values",
        "replaceAll",
        "tree.containsKey",
        "instance.size",
        "subMap",
        "instance.firstEntry",
        "descendingKeySet",
        "firstEntry",
        "instance.values",
        "tree.pollFirstEntry",
        "ceilingEntry",
        "tree.replace",
        "put",
        "tree.putAll",
        "lowerKey",
        "tree.forEach",
        "navigableKeySet",
        "instance.ceilingEntry",
        "keySet",
        "instance.ceilingKey",
        "tailMap",
        "instance.entrySet",
        "instance.clone",
        "floorEntry",
        "size",
        "lastEntry",
        "higherEntry",
        "forEach",
        "tree.clear",
        "instance.descendingMap",
        "instance.keySet",
        "instance.lowerEntry",
        "tree.pollLastEntry",
        "descendingMap",
        "NullPointerException",
        "K",
        "putAll",
        "clear",
        "pollLastEntry",
        "replace",
        "ceilingKey",
        "clone",
        "floorKey",
        "instance.subMap"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 86,
      "source_code": "    \n    public Object clone() {\n        return combinedRef.instance.clone();        \n    }\n\n    public Map.Entry<K,V> firstEntry() {\n        return combinedRef.instance.firstEntry();\n    }\n    \n    public Map.Entry<K,V> lastEntry() {\n        return combinedRef.instance.lastEntry();\n    }\n\n    public Map.Entry<K,V> lowerEntry(K key) {\n        return combinedRef.instance.lowerEntry(key);\n    }\n    \n    public K lowerKey(K key) {\n        return combinedRef.instance.lowerKey(key);\n    }\n    \n    public Map.Entry<K,V> floorEntry(K key) {\n        return combinedRef.instance.floorEntry(key);\n    }\n    \n    public K floorKey(K key) {\n        return combinedRef.instance.floorKey(key);\n    }\n    \n    public Map.Entry<K,V> ceilingEntry(K key) {\n        return combinedRef.instance.ceilingEntry(key);\n    }\n    \n    public K ceilingKey(K key) {\n        return combinedRef.instance.ceilingKey(key);\n    }\n\n    public Map.Entry<K,V> higherEntry(K key) {\n        return combinedRef.instance.higherEntry(key);\n    }\n    \n    public Set<K> keySet() {\n        return combinedRef.instance.keySet();\n    }\n    \n    public NavigableSet<K> navigableKeySet() {\n        return combinedRef.instance.navigableKeySet();\n    }\n    \n    public NavigableSet<K> descendingKeySet() {\n        return combinedRef.instance.descendingKeySet();\n    }\n    \n    public Collection<V> values() {\n        return combinedRef.instance.values();\n    }\n    \n    public Set<Map.Entry<K,V>> entrySet() {\n        return combinedRef.instance.entrySet();\n    }\n    \n    public NavigableMap<K, V> descendingMap() {\n        return combinedRef.instance.descendingMap();\n    }\n    \n    public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,\n                                    K toKey,   boolean toInclusive) {\n        return combinedRef.instance.subMap(fromKey, fromInclusive, toKey, toInclusive);\n    }\n    \n    public NavigableMap<K,V> headMap(K toKey, boolean inclusive) {\n        return combinedRef.instance.headMap(toKey, inclu",
      "line_number": 141,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "clone",
      "signature": "public Object clone() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.clone",
        "clone"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.clone();        \n    }",
      "line_number": 143,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "lowerKey",
      "signature": "public K lowerKey(K key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "lowerKey",
        "instance.lowerKey"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.lowerKey(key);\n    }",
      "line_number": 159,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "floorKey",
      "signature": "public K floorKey(K key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "instance.floorKey",
        "floorKey"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.floorKey(key);\n    }",
      "line_number": 167,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "ceilingKey",
      "signature": "public K ceilingKey(K key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "ceilingKey",
        "instance.ceilingKey"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.ceilingKey(key);\n    }",
      "line_number": 175,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "keySet",
      "signature": "public Set<K> keySet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "keySet",
        "instance.keySet"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.keySet();\n    }",
      "line_number": 183,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "navigableKeySet",
      "signature": "public NavigableSet<K> navigableKeySet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "instance.navigableKeySet",
        "navigableKeySet"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.navigableKeySet();\n    }",
      "line_number": 187,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "descendingKeySet",
      "signature": "public NavigableSet<K> descendingKeySet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "descendingKeySet",
        "K",
        "instance.descendingKeySet"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.descendingKeySet();\n    }",
      "line_number": 191,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "values",
      "signature": "public Collection<V> values() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "values",
        "instance.values",
        "V"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.values();\n    }",
      "line_number": 195,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "descendingMap",
      "signature": "public NavigableMap<K, V> descendingMap() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "descendingMap",
        "instance.descendingMap",
        "K"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.descendingMap();\n    }",
      "line_number": 203,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "headMap",
      "signature": "public NavigableMap<K,V> headMap(K toKey, boolean inclusive) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "instance.headMap",
        "headMap"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.headMap(toKey, inclusive);\n    }",
      "line_number": 212,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "tailMap",
      "signature": "public NavigableMap<K,V> tailMap(K fromKey, boolean inclusive) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "tailMap",
        "instance.tailMap"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.tailMap(fromKey, inclusive);\n    }",
      "line_number": 216,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "subMap",
      "signature": "public SortedMap<K,V> subMap(K fromKey, K toKey) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "subMap",
        "instance.subMap"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.subMap(fromKey, toKey);\n    }",
      "line_number": 220,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "headMap",
      "signature": "public SortedMap<K,V> headMap(K toKey) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "instance.headMap",
        "headMap"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.headMap(toKey);\n    }",
      "line_number": 224,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "tailMap",
      "signature": "public SortedMap<K,V> tailMap(K fromKey) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "tailMap",
        "instance.tailMap"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.tailMap(fromKey);\n    }",
      "line_number": 228,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "size",
        "instance.size"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return (combinedRef.instance.size() == 0);    \n    }",
      "line_number": 232,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "putAll",
      "signature": "public void putAll(Map<? extends K, ? extends V> map) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "K",
        "putAll",
        "tree.putAll"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 1,
      "source_code": "        applyMutation(null, null, null, map, null, (K _key, V _value, V _v2, Object _map, Object _o2, TreeMap<K,V> tree) -> {\n        tree.putAll((Map<? extends K, ? extends V>)_map); \n        return 0;\n        });\n    }",
      "line_number": 243,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public V put(K key, V value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.put",
        "K",
        "put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, value, null, null, null, (K _key, V _value, V _v2, Object _o1, Object _o2, TreeMap<K,V> tree) -> \n        tree.put(_key, _value)); \n    }",
      "line_number": 250,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "replaceAll",
      "signature": "public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.replaceAll",
        "K",
        "replaceAll"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 3,
      "source_code": "        applyMutation(null, null, null, function, null, (K _key, V _v1, V _v2, Object _function, Object _o2, TreeMap<K,V> tree) -> { \n        tree.replaceAll((BiFunction<? super K, ? super V, ? extends V>)_function);\n        return 0;\n        });                        \n    }",
      "line_number": 294,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "putIfAbsent",
      "signature": "public V putIfAbsent(K key, V value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "put",
        "K",
        "tree.containsKey",
        "containsKey",
        "tree.put"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 3,
      "source_code": "        return applyMutation(key, value, null, null, null, (K _key, V _value, V _v2, Object _o1, Object _o2, TreeMap<K,V> tree) -> {\n            if (tree.containsKey(_key)) return null;\n            return tree.put(_key, _value);\n        });                        \n    }",
      "line_number": 302,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object key, Object value) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/cow/CopyOnWriteMQWFTreeMap.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.put",
        "NullPointerException",
        "put",
        "K"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer"
      ],
      "complexity_score": 2,
      "source_code": "        Boolean b = applyMutation(key, value, null, null, null, (K _key, V _value, V _v2, Object _o1, Object _o2, TreeMap<K,V> tree) -> {\n        if (_key == null)\n            throw new NullPointerException();\n        //return _value != null && (tree.put(_key, _value) != null);\n        return Boolean.TRUE;        \n        });                        \n    }",
      "line_number": 311,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeMap",
      "method_type": "method"
    },
    {
      "name": "TicketAWNEndsEgressLock",
      "signature": "public TicketAWNEndsEgressLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNEndsEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicReference",
        "Lock",
        "AtomicReferenceArray",
        "lock"
      ],
      "dependencies": [
        "AtomicReferenceArray",
        "WaitingNode"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        maxArrayWaiters = NCPU+2;\n        waitersArray = new AtomicReferenceArray<WaitingNode>(maxArrayWaiters);\n    }",
      "line_number": 127,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNEndsEgressLock",
      "method_type": "constructor"
    },
    {
      "name": "TicketAWNEndsEgressLock",
      "signature": "public TicketAWNEndsEgressLock(int maxArrayWaiters) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNEndsEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicReference",
        "Lock",
        "AtomicReferenceArray",
        "lock"
      ],
      "dependencies": [
        "AtomicReferenceArray",
        "WaitingNode"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        this.maxArrayWaiters = maxArrayWaiters;\n        waitersArray = new AtomicReferenceArray<WaitingNode>(maxArrayWaiters);\n    }",
      "line_number": 132,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNEndsEgressLock",
      "method_type": "constructor"
    },
    {
      "name": "lock",
      "signature": "public void lock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNEndsEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "lock",
        "Lock",
        "final",
        "Thread",
        "getAndIncrement"
      ],
      "dependencies": [
        "waitersArray.set",
        "get",
        "WaitingNode",
        "tlNode.get",
        "set",
        "Thread.yield",
        "yield",
        "ingress.getAndIncrement",
        "tlNode.set",
        "getAndIncrement"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 46,
      "source_code": "        final long ticket = ingress.getAndIncrement();\n        while (egress >= ticket-1) { if (egress == ticket) return; Thread.yield(); }\n        // If there is no slot to wait, spin until there is\n        while (ticket-egress >= maxArrayWaiters) Thread.yield();\n        \n        if (egress < ticket-1) {\n            // There is a spot for us on the array, so place our node there\n            WaitingNode wnode = tlNode.get();\n            if (wnode == null) tlNode.set(wnode = new WaitingNode());\n            wnode.lockIsMine = false; // Reset from previous usages\n            waitersArray.set((int)(ticket % maxArrayWaiters), wnode);            \n            if (egress < ticket-1) {            \n                // Spin on lockIsMine\n                while (!wnode.lockIsMine) Thread.yield();\n            }\n            // Clear up our entry in the array since it's not needed anymore. Should be a relaxed store.\n            waitersArray.set((int)(ticket % maxArrayWaiters), null);\n        }\n        // Spin on egress\n        while (egress != ticket) Thread.yield();\n        // Lock acquired\n    }",
      "line_number": 139,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNEndsEgressLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNEndsEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "get",
        "waitersArray.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        long ticket = egress;\n        final WaitingNode wnode = waitersArray.get((int)((ticket+1) % maxArrayWaiters));\n        if (wnode != null) {\n            // We saw the node in waitersArray\n            wnode.lockIsMine = true; // This can be a relaxed store\n            // If we use Park/Unpark, then here is the place to call unpark(wnode.thread)\n        } \n        egress = ticket+1; // Lock released\n    }",
      "line_number": 165,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNEndsEgressLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNEndsEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }",
      "line_number": 178,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNEndsEgressLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNEndsEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }",
      "line_number": 184,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNEndsEgressLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNEndsEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }    ",
      "line_number": 197,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNEndsEgressLock",
      "method_type": "method"
    },
    {
      "name": "TicketAWNNegativeEgressLock",
      "signature": "public TicketAWNNegativeEgressLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicReference",
        "Lock",
        "AtomicReferenceArray",
        "lock"
      ],
      "dependencies": [
        "AtomicReferenceArray",
        "WaitingNode"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        maxArrayWaiters = NCPU+2;\n        waitersArray = new AtomicReferenceArray<WaitingNode>(maxArrayWaiters);\n    }",
      "line_number": 144,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "constructor"
    },
    {
      "name": "TicketAWNNegativeEgressLock",
      "signature": "public TicketAWNNegativeEgressLock(int maxArrayWaiters) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicReference",
        "Lock",
        "AtomicReferenceArray",
        "lock"
      ],
      "dependencies": [
        "AtomicReferenceArray",
        "WaitingNode"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        this.maxArrayWaiters = maxArrayWaiters;\n        waitersArray = new AtomicReferenceArray<WaitingNode>(maxArrayWaiters);\n    }",
      "line_number": 149,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "constructor"
    },
    {
      "name": "getPosEgress",
      "signature": "private final long getPosEgress() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        long localEgress = egress;\n        return localEgress > 0 ? localEgress : -localEgress;\n    }",
      "line_number": 155,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "method"
    },
    {
      "name": "lock",
      "signature": "public void lock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "lock",
        "Lock",
        "final",
        "Thread",
        "getAndIncrement"
      ],
      "dependencies": [
        "waitersArray.set",
        "get",
        "WaitingNode",
        "tlNode.get",
        "set",
        "Thread.yield",
        "yield",
        "ingress.getAndIncrement",
        "tlNode.set",
        "getAndIncrement"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 54,
      "source_code": "        final long ticket = ingress.getAndIncrement();\n        if (egress == ticket) return;\n        while (getPosEgress() >= ticket-1) { if (getPosEgress() == ticket) return; Thread.yield(); }\n        // If there is no slot to wait, spin until there is\n        while (ticket-getPosEgress() >= maxArrayWaiters) Thread.yield();\n\n        // There is a spot for us on the array, so place our node there\n        WaitingNode wnode = tlNode.get();\n        if (wnode == null) tlNode.set(wnode = new WaitingNode());\n        wnode.lockIsMine = false; // Reset from previous usages\n        waitersArray.set((int)(ticket % maxArrayWaiters), wnode);\n\n        // If there is only one left before egress becomes our ticket, wait for it\n        while (true) {\n            final long localEgress = egress;\n            if (getPosEgress() < ticket-1 || -localEgress == ticket) break; // go spin on lockIsMine\n            if (localEgress == ticket) return; // egress was positive and matches. Lock acquired\n            Thread.yield(); \n        }\n        // Spin on our own cache line waiting for the lock\n        while (!wnode.lockIsMine) {\n            Thread.yield();\n            // If we wanted to, we could call park() here\n        }\n    }",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "waitersArray.set",
        "get",
        "waitersArray.get",
        "set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 26,
      "source_code": "        long ticket = getPosEgress();\n        // Clear up our entry in the array before releasing the lock. Should be a relaxed store.\n        waitersArray.set((int)(ticket % maxArrayWaiters), null);\n        final WaitingNode wnode = waitersArray.get((int)((ticket+1) % maxArrayWaiters));\n        if (wnode != null) {\n            // We saw the node in waitersArray, so tell the thread to spin on lockIsMine by setting a negative egress\n            egress = -(ticket+1); // This can be a relaxed store\n            wnode.lockIsMine = true;\n            // If we use Park/Unpark, then here is the place to call unpark(wnode.thread)\n        } else {\n            // No node was seen, so set a positive egress\n            egress = ticket+1;\n        }\n    }",
      "line_number": 191,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }",
      "line_number": 209,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }",
      "line_number": 215,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNNegativeEgressLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }    ",
      "line_number": 228,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNNegativeEgressLock",
      "method_type": "method"
    },
    {
      "name": "TicketAWNSpinsBothLock",
      "signature": "public TicketAWNSpinsBothLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNSpinsBothLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicReference",
        "Lock",
        "AtomicReferenceArray",
        "lock"
      ],
      "dependencies": [
        "AtomicReferenceArray",
        "WaitingNode"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        maxArrayWaiters = NCPU+2;\n        waitersArray = new AtomicReferenceArray<WaitingNode>(maxArrayWaiters);\n    }",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNSpinsBothLock",
      "method_type": "constructor"
    },
    {
      "name": "TicketAWNSpinsBothLock",
      "signature": "public TicketAWNSpinsBothLock(int maxArrayWaiters) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNSpinsBothLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "AtomicReference",
        "Lock",
        "AtomicReferenceArray",
        "lock"
      ],
      "dependencies": [
        "AtomicReferenceArray",
        "WaitingNode"
      ],
      "concurrency_patterns": [
        "compare_and_swap"
      ],
      "complexity_score": 8,
      "source_code": "        this.maxArrayWaiters = maxArrayWaiters;\n        waitersArray = new AtomicReferenceArray<WaitingNode>(maxArrayWaiters);\n    }",
      "line_number": 136,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNSpinsBothLock",
      "method_type": "constructor"
    },
    {
      "name": "lock",
      "signature": "public void lock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNSpinsBothLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "lock",
        "Lock",
        "final",
        "Thread",
        "getAndIncrement"
      ],
      "dependencies": [
        "waitersArray.set",
        "get",
        "WaitingNode",
        "tlNode.get",
        "set",
        "Thread.yield",
        "yield",
        "ingress.getAndIncrement",
        "tlNode.set",
        "getAndIncrement"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 47,
      "source_code": "        final long ticket = ingress.getAndIncrement();\n        if (egress == ticket) return;\n        while (ticket-egress >= maxArrayWaiters) Thread.yield();\n\n        // There is a spot for us on the array, so place our node there\n        WaitingNode wnode = tlNode.get();\n        if (wnode == null) tlNode.set(wnode = new WaitingNode());\n        wnode.lockIsMine = false; // Reset from previous usages\n        waitersArray.set((int)(ticket % maxArrayWaiters), wnode);\n        \n        if (egress < ticket-1){\n            // Spin on lockIsMine\n            while (!wnode.lockIsMine) Thread.yield();\n            egress = ticket; // This can be a relaxed store\n        } else {\n            // Spin on both lockIsMine and egress\n            while (egress != ticket) {\n                if (wnode.lockIsMine){\n                    egress = ticket; // This can be a relaxed store\n                    return;\n                }\n                Thread.yield();\n            }\n        }\n        // lock acquired\n    }",
      "line_number": 144,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNSpinsBothLock",
      "method_type": "method"
    },
    {
      "name": "unlock",
      "signature": "public void unlock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNSpinsBothLock.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Lock",
        "unlock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "waitersArray.set",
        "get",
        "waitersArray.get",
        "set"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        long ticket = egress;\n        // Clear up our entry in the array before releasing the lock. Should be a relaxed store.\n        waitersArray.set((int)(ticket % maxArrayWaiters), null);\n        final WaitingNode wnode = waitersArray.get((int)((ticket+1) % maxArrayWaiters));\n        if (wnode != null) {\n            // We saw the node in waitersArray\n            wnode.lockIsMine = true;\n            // If we use Park/Unpark, then here is the place to call unpark(wnode.thread)\n        } else {\n            egress = ticket+1;\n        }\n\n    }",
      "line_number": 174,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNSpinsBothLock",
      "method_type": "method"
    },
    {
      "name": "lockInterruptibly",
      "signature": "public void lockInterruptibly() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNSpinsBothLock.java",
      "language": "java",
      "sync_primitives": [
        "lockInterruptibly",
        "Lock",
        "lock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }",
      "line_number": 191,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNSpinsBothLock",
      "method_type": "method"
    },
    {
      "name": "tryLock",
      "signature": "public boolean tryLock() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNSpinsBothLock.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "tryLock"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }",
      "line_number": 197,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNSpinsBothLock",
      "method_type": "method"
    },
    {
      "name": "newCondition",
      "signature": "public Condition newCondition() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/locks/experimental/TicketAWNSpinsBothLock.java",
      "language": "java",
      "sync_primitives": [
        "Condition",
        "newCondition"
      ],
      "dependencies": [
        "UnsupportedOperationException"
      ],
      "concurrency_patterns": [],
      "complexity_score": 8,
      "source_code": "        // Not supported\n        throw new UnsupportedOperationException();\n    }    ",
      "line_number": 210,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "TicketAWNSpinsBothLock",
      "method_type": "method"
    },
    {
      "name": "finalize",
      "signature": "protected void finalize() throws Throwable {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "super.finalize",
        "finalize"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            removeState(st);\n            super.finalize();\n        }",
      "line_number": 105,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "LRScalableTreeSet",
      "signature": "public LRScalableTreeSet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "AtomicLong",
        "AtomicReference",
        "AtomicInteger",
        "ConcurrentLinkedQueue",
        "Thread",
        "ThreadLocal"
      ],
      "dependencies": [
        "AtomicLong",
        "AtomicReference",
        "TreeSet",
        "AtomicInteger",
        "State",
        "ReadersEntry",
        "ConcurrentLinkedQueue",
        "ThreadLocal",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "        leftTree = new TreeSet<E>();\n        rightTree = new TreeSet<E>();\n\n        // Only \"Write\" operations can modify these\n        leftRight = new AtomicInteger(READS_ON_LEFT);\n        versionIndex = new AtomicLong(VERSION0);\n\n        // Stores the Reader's state for each thread\n        readersStateQ = new ConcurrentLinkedQueue<State>();\n\n        readersStateArrayRef = new AtomicReference<State[]>(null);\n\n        entry = new ThreadLocal<ReadersEntry>();\n    }",
      "line_number": 114,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "removeState",
      "signature": "protected void removeState(State state) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "readersStateQ.remove",
        "remove",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        // We don't need to lock in exclusive mode thanks to the GC\n        readersStateQ.remove(state);\n        readersStateArrayRef.set(null);\n    }",
      "line_number": 136,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "addState",
      "signature": "private ReadersEntry addState() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "add",
        "State",
        "ReadersEntry",
        "entry.set",
        "set",
        "readersStateQ.add"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 14,
      "source_code": "        final State state = new State(STATE_NOT_READING, STATE_NOT_READING);\n        final ReadersEntry newEntry = new ReadersEntry(state);\n        entry.set(newEntry);\n        readersStateQ.add(state);\n        readersStateArrayRef.set(null);\n        return newEntry;\n    }",
      "line_number": 146,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "rebuildArrayIfNeeded",
      "signature": "private State[] rebuildArrayIfNeeded() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "readersStateArrayRef.set",
        "size",
        "compareAndSet",
        "get",
        "set",
        "toArray",
        "readersStateQ.toArray",
        "readersStateArrayRef.get",
        "readersStateQ.size",
        "readersStateArrayRef.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        State[] localReadersStateArray = readersStateArrayRef.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before scanning the readersStateQ \n            readersStateArrayRef.set(dummyArray);\n            // Copy the elements in readersStateQ to an array\n            localReadersStateArray =\n                    readersStateQ.toArray(new State[readersStateQ.size()]);\n            readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);\n        }\n        return localReadersStateArray;\n    }",
      "line_number": 159,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "toggleVersionAndScan",
      "signature": "private void toggleVersionAndScan() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [
        "versionIndex.get",
        "get",
        "versionIndex.set",
        "set"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "        State[] localReadersStateArray = rebuildArrayIfNeeded();\n        final long localVersionIndex = versionIndex.get();\n        final int prevVersionIndex = (int)(localVersionIndex % 2);\n        final int nextVersionIndex = (int)((localVersionIndex+1) % 2);\n        \n        // Wait for Readers from next version\n        for (State readerState : localReadersStateArray) {\n            skipOrYield(readerState, nextVersionIndex);\n        }\n        \n        // Toggle versionIndex\n        versionIndex.set(localVersionIndex+1);\n\n        // Wait for Readers from previous version\n        for (State readerState : localReadersStateArray) {\n            skipOrYield(readerState, prevVersionIndex);\n        }\n    }",
      "line_number": 178,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "skipOrYield",
      "signature": "private final void skipOrYield(final State readerState, final int localVersionIndex) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "yield",
        "Thread.yield"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 13,
      "source_code": "        if (readerState == null) {\n            return;\n        }\n\n        if (localVersionIndex == VERSION0) {\n            while (readerState.v0State == STATE_READING) {\n                Thread.yield();\n            }\n        } else {\n            while (readerState.v1State == STATE_READING) {\n                Thread.yield();\n            }\n        }\n    }",
      "line_number": 203,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "TreeSet.contains",
        "contains",
        "entry.get",
        "versionIndex.get",
        "leftRight.get",
        "leftTree.contains",
        "get",
        "rightTree.contains"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 34,
      "source_code": "        ReadersEntry localReadersEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localReadersEntry == null) {\n            localReadersEntry = addState();\n        }\n        boolean retValue;\n        long localVersionIndex = versionIndex.get()%2;\n        try {\n            // Set the current Reader's state to READING\n            if (localVersionIndex == VERSION0) {\n                localReadersEntry.st.v0State = STATE_READING;\n            } else {\n                localReadersEntry.st.v1State = STATE_READING;\n            }\n\n            // Read the up-to-date value of leftRight.\n            // Order is important: The leftRight value can only be read _after_\n            // the Reader's state has been set.         \n            if (leftRight.get() == READS_ON_LEFT) {\n                retValue = leftTree.contains(elem);\n            } else {\n                retValue = rightTree.contains(elem);\n            }\n        } finally {\n            // In the extreme event that TreeSet.contains() throws an exception, \n            // we want to make sure that no Writer is left hanging.\n            if (localVersionIndex == VERSION0) {\n                localReadersEntry.st.v0State = STATE_NOT_READING;\n            } else {\n                localReadersEntry.st.v1State = STATE_NOT_READING;\n            }\n        }\n        return retValue;\n    }",
      "line_number": 227,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "optimisticContains",
      "signature": "public boolean optimisticContains(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "TreeSet.contains",
        "contains",
        "loadFence",
        "leftTree.contains",
        "versionIndex.get",
        "leftRight.get",
        "entry.get",
        "get",
        "UNSAFE.loadFence",
        "rightTree.contains"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 39,
      "source_code": "        boolean retValue;\n        long localVersionIndex = versionIndex.get();\n        int localLeftRight = leftRight.get();\n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = leftTree.contains(elem);\n        } else {\n            retValue = rightTree.contains(elem);\n        }\n        \n        if (retValue) {\n            return true;\n        }\n\n        // We add a fence here to prevent the contains() above from\n        // moving below the versionIndex.get()\n        UNSAFE.loadFence();\n        final long lVersionIndex = versionIndex.get();\n        if (lVersionIndex == localVersionIndex) {\n            return false;\n        }\n\n        ReadersEntry localReadersEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localReadersEntry == null) {\n            localReadersEntry = addState();\n        }\n        localVersionIndex = lVersionIndex % 2;\n        try {\n            // Set the current Reader's state to READING\n            if (localVersionIndex == VERSION0) {\n                localReadersEntry.st.v0State = STATE_READING;\n            } else {\n                localReadersEntry.st.v1State = STATE_READING;\n            }\n\n            // Read the up-to-date value of leftRight.\n            // Order is important: The leftRight value can only be read _after_\n            // the Reader's state has been set.         \n            if (leftRight.get() == READS_ON_LEFT) {\n                retValue = leftTree.contains(elem);\n            } else {\n                retValue = rightTree.contains(elem);\n            }\n        } finally {\n            // In the extreme event that TreeSet.contains() throws an exception, \n            // we want to make sure that no Writer is left hanging.\n            if (localVersionIndex == VERSION0) {\n                localReadersEntry.st.v0State = STATE_NOT_READING;\n            } else {\n                localReadersEntry.st.v1State = STATE_NOT_READING;\n            }\n        }\n        return ret",
      "line_number": 273,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public synchronized boolean add(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "add",
        "leftRight.set",
        "leftRight.get",
        "get",
        "set",
        "leftTree.add",
        "rightTree.add"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        final int localLeftRight = leftRight.get();\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.add(elem);\n        } else {\n            retValue = leftTree.add(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        toggleVersionAndScan();\n\n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.add(elem);\n        } else {\n            leftTree.add(elem);\n        }\n\n        return retValue;\n    }",
      "line_number": 337,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public synchronized boolean remove(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "leftRight.set",
        "leftRight.get",
        "get",
        "rightTree.remove",
        "set",
        "leftTree.remove",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        final boolean retValue;\n        int localLeftRight = leftRight.get();\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.                \n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.remove(elem);\n        } else {\n            retValue = leftTree.remove(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        toggleVersionAndScan();\n\n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.remove(elem);\n        } else {\n            leftTree.remove(elem);\n        }\n\n        return retValue;\n    }",
      "line_number": 376,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "is",
      "method_type": "method"
    },
    {
      "name": "BenchmarkTreeSetFullRebalance",
      "signature": "BenchmarkTreeSetFullRebalance(int numElements) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "globalIndex.set",
        "MAX_TEST_CASES.ordinal",
        "ordinal",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        this.numElements = numElements;\n        udarray = new UserData[numElements*4];\n        for (int i = 0; i < TestCase.MAX_TEST_CASES.ordinal(); i++) {\n            globalIndex.set(i, numElements);\n            for(int j = 0; j < MAX_NUM_THREADS; j++){\n                index[j][i] = numElements+j;\n            }\n        }\n    }",
      "line_number": 64,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "constructor"
    },
    {
      "name": "BenchmarkTreeSetFullRebalance",
      "signature": "BenchmarkTreeSetFullRebalance() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "globalIndex.set",
        "MAX_TEST_CASES.ordinal",
        "ordinal",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 5,
      "source_code": "        for (int i = 0; i < TestCase.MAX_TEST_CASES.ordinal(); i++) {\n            globalIndex.set(i, this.numElements);\n            for(int j = 0; j < MAX_NUM_THREADS; j++){\n                index[j][i] = numElements+j;\n            }\n        }\n    }",
      "line_number": 74,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "constructor"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread",
        "final"
      ],
      "dependencies": [
        "ordinal",
        "lrScalableTreeSetOptimistic.optimisticContains",
        "lrScalableTreeSetRV.contains",
        "containsKey",
        "rwLockTreeSet.add",
        "add",
        "snapTreeMap.remove",
        "lrScalableTreeSetOptimistic.add",
        "snapTreeMap.containsKey",
        "lrScalableTreeSetOptimistic.remove",
        "lrScalableTreeSetNV.add",
        "rwLockTreeSet.remove",
        "lrScalableTreeSetNV.contains",
        "stype.ordinal",
        "optimisticContains",
        "lrScalableTreeSetRV.remove",
        "out.println",
        "lrScalableTreeSet.add",
        "put",
        "lrScalableTreeSet.contains",
        "System.nanoTime",
        "nanoTime",
        "contains",
        "println",
        "lrScalableTreeSet.remove",
        "snapTreeMap.put",
        "rwLockTreeSet.containsKey",
        "lrScalableTreeSetRV.add",
        "remove",
        "lrScalableTreeSetNV.remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "            long xrand = System.nanoTime();\n            long x;\n\n            for (long i = 0; i < numIterations; i++) {\n                if (quit) return;\n\n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                \n                if (writePerMil != 1000 && (writePerMil == 0 || ((x%1000) >= writePerMil))) {\n                    int i0 = (int)(i % (numElements*4));\n                    int i1 = (int)((i+1) % (numElements*4));\n                    final UserData ud0 = udarray[i0];\n                    final UserData ud1 = udarray[i1];\n                    switch (stype) {\n                        case LRScalableTreeSetNV:\n                        \tlrScalableTreeSetNV.contains(ud0);\n                        \tlrScalableTreeSetNV.contains(ud1);\n                            break;\n                        case LRScalableTreeSet:\n                            lrScalableTreeSet.contains(ud0);\n                            lrScalableTreeSet.contains(ud1);\n                            break;\n                        case LRScalableTreeSetOptimistic:\n                            lrScalableTreeSetOptimistic.optimisticContains(ud0);\n                            lrScalableTreeSetOptimistic.optimisticContains(ud1);\n                            break;\n                        case LRScalableTreeSetRV:                            \t\n                            lrScalableTreeSetRV.contains(ud0);\n                            lrScalableTreeSetRV.contains(ud1);\n                            break;\n                        case SnapTreeMap:                            \t\n                            snapTreeMap.containsKey(ud0);\n                            snapTreeMap.containsKey(ud1);\n                            break;\n                        case ScalableRWLockTreeSet:\n                        \trwLockTreeSet.containsKey(ud0);\n                        \trwLockTreeSet.containsKey(ud1);\n                        \tbreak;\n                    }\n      ",
      "line_number": 114,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "myinit",
      "signature": "private void myinit() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "println",
        "put",
        "add",
        "lrScalableTreeSet.add",
        "UserData",
        "lrScalableTreeSetOptimistic.add",
        "snapTreeMap.put",
        "lrScalableTreeSetNV.add",
        "rwLockTreeSet.add",
        "lrScalableTreeSetRV.add"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "\n        // fill in the full array, each entry with a unique entry\n        for (int i = 0; i < numElements*4; i++) {\n            udarray[i] = new UserData();\n            udarray[i].a = i;\n            udarray[i].b = i % 7;\n        }\n\n        System.out.println(\"Filling up trees with \"+numElements+\" elements...\");\n        // Insert only the first block of elements\n        for (int i = 0; i < numElements; i++) lrScalableTreeSet.add(udarray[i]);\n        for (int i = 0; i < numElements; i++) lrScalableTreeSetNV.add(udarray[i]);\n        for (int i = 0; i < numElements; i++) lrScalableTreeSetRV.add(udarray[i]);\n        for (int i = 0; i < numElements; i++) lrScalableTreeSetOptimistic.add(udarray[i]);\n        for (int i = 0; i < numElements; i++) snapTreeMap.put(udarray[i], udarray[i]);\n        for (int i = 0; i < numElements; i++) rwLockTreeSet.add(udarray[i]);\n    }",
      "line_number": 204,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "allDedicatedWriterTests",
      "signature": "private void allDedicatedWriterTests(int numThreads) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 26,
      "source_code": "        workerThreads = new WorkerThread[numThreads];\n        \n        System.out.println(\"----- Dedicated Writer tests (2 Writers + \" + (numThreads - 2) + \" Readers) numElements=\"+numElements+\" -----\");\n        dedicatedWriterTest(numThreads, TestCase.LRScalableTreeSet);\n        dedicatedWriterTest(numThreads, TestCase.LRScalableTreeSetNV);\n        dedicatedWriterTest(numThreads, TestCase.LRScalableTreeSetRV);\n        dedicatedWriterTest(numThreads, TestCase.LRScalableTreeSetOptimistic);        \n        dedicatedWriterTest(numThreads, TestCase.SnapTreeMap);\n        dedicatedWriterTest(numThreads, TestCase.ScalableRWLockTreeSet);        \n        System.out.println(\"\");\n    }",
      "line_number": 227,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "allWritePerMilTests",
      "signature": "private void allWritePerMilTests(int numThreads, int writePerMil) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        workerThreads = new WorkerThread[numThreads];\n        double writePercentage = writePerMil == 0 ? 0 : writePerMil/10.;\n        System.out.println(\"----- writePerMil tests numThreads=\" +numThreads+\"  Writes=\"+writePercentage+\"%  numElements=\"+numElements+\" -----\");        \n        writePerMilTest(numThreads, writePerMil, TestCase.LRScalableTreeSet);\n        writePerMilTest(numThreads, writePerMil, TestCase.LRScalableTreeSetNV);\n        writePerMilTest(numThreads, writePerMil, TestCase.LRScalableTreeSetRV);\n        writePerMilTest(numThreads, writePerMil, TestCase.LRScalableTreeSetOptimistic);        \n        writePerMilTest(numThreads, writePerMil, TestCase.SnapTreeMap);        \n        writePerMilTest(numThreads, writePerMil, TestCase.ScalableRWLockTreeSet);\n        System.out.println(\"\");\n    }",
      "line_number": 244,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "powerPCWritePerMilTests",
      "signature": "private void powerPCWritePerMilTests(int numThreads, int writePerMil) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        workerThreads = new WorkerThread[numThreads];\n        double writePercentage = writePerMil == 0 ? 0 : writePerMil/10.;\n        System.out.println(\"----- writePerMil tests numThreads=\" +numThreads+\"  Writes=\"+writePercentage+\"%  numElements=\"+numElements+\" -----\");        \n        writePerMilTest(numThreads, writePerMil, TestCase.LRScalableTreeSet);       \n        writePerMilTest(numThreads, writePerMil, TestCase.SnapTreeMap);        \n        System.out.println(\"\");\n    }",
      "line_number": 258,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "sleepAndStopWorkerThreads",
      "signature": "private void sleepAndStopWorkerThreads(int numThreads) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "Thread.sleep",
        "out.println",
        "sleep",
        "println"
      ],
      "concurrency_patterns": [],
      "complexity_score": 16,
      "source_code": "        try {\n            Thread.sleep(numMilis);\n        } catch (InterruptedException e) {\n            System.out.println(\"InterruptedException\");\n        }\n        for (int i = 0; i < numThreads; i++) {\n            workerThreads[i].quit = true;\n        }    \t\n    }",
      "line_number": 268,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "dedicatedWriterTest",
      "signature": "private void dedicatedWriterTest(int numThreads, TestCase stype) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "join",
        "out.print",
        "out.println",
        "csv.addRunDedicated",
        "print",
        "println",
        "addRunDedicated",
        "name",
        "stype.name",
        "stype.toString",
        "length",
        "substring",
        "start",
        "WorkerThread",
        "toString"
      ],
      "concurrency_patterns": [],
      "complexity_score": 53,
      "source_code": "        // If we see an error here just increase the number of spaces\n        String indentedName = stype.toString() + \"                              \".substring(stype.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n        \n        // Create the threads and then start them all in one go\n        for (int i = 0; i < numThreads; i++) {\n            if (i == 0 || i == 1) {\n                // First and second threads are Writers\n                workerThreads[i] = new WorkerThread(1000, stype, i, 2);\n            } else {\n                // all other threads are Readers\n                workerThreads[i] = new WorkerThread(0, stype, i, 2);\n            }\n        }\n        for (int i = 0; i < numThreads; i++) {\n            workerThreads[i].start();\n        }\n\n        sleepAndStopWorkerThreads(numThreads);\n\n        long totalOps = 0;\n        long totalReadOps = 0;\n        long totalWriteOps = 0;\n        for (int i = 0; i < numThreads; i++) {\n            totalOps += workerThreads[i].numOps;\n            totalReadOps += workerThreads[i].numReadOps;\n            totalWriteOps += workerThreads[i].numWriteOps;\n        }\n\n        try {\n            for (int i = 0; i < numThreads; i++) {\n                workerThreads[i].join();\n            }\n        } catch (InterruptedException e) {\n            System.out.println(\"InterruptedException\");\n        }\n        System.out.println(\"Total Ops/ms = \" + (totalOps /numMilis) + \"   Reads/ms = \" + (totalReadOps/numMilis) + \"   Writes/ms = \" + (totalWriteOps/numMilis));\n        csv.addRunDedicated(stype.name(), numThreads-2, 2, totalReadOps/numMilis, totalWriteOps/numMilis);\n    }",
      "line_number": 280,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "writePerMilTest",
      "signature": "private void writePerMilTest(int numThreads, int writePerMil, TestCase stype) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [
        "join",
        "out.print",
        "out.println",
        "print",
        "println",
        "addRun",
        "name",
        "stype.name",
        "stype.toString",
        "length",
        "substring",
        "csv.addRun",
        "start",
        "WorkerThread",
        "toString"
      ],
      "concurrency_patterns": [],
      "complexity_score": 41,
      "source_code": "        // If we see an error here just increase the number of spaces\n        String indentedName = stype.toString() + \"                              \".substring(stype.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n        \n        // Create the threads and then start them all in one go\n        for (int i = 0; i < numThreads; i++) {\n            workerThreads[i] = new WorkerThread(writePerMil, stype, i, numThreads);\n        }\n        for (int i = 0; i < numThreads; i++) {\n            workerThreads[i].start();\n        }\n\n        sleepAndStopWorkerThreads(numThreads);\n\n        long totalOps = 0;\n        for (int i = 0; i < numThreads; i++) {\n            totalOps += workerThreads[i].numOps;\n        }\n\n        try {\n            for (int i = 0; i < numThreads; i++) {\n                workerThreads[i].join();\n            }\n        } catch (InterruptedException e) {\n            System.out.println(\"InterruptedException\");\n        }\n        System.out.println(\"Total Ops/ms = \" + (totalOps /numMilis));\n        csv.addRun(stype.name(), writePerMil, numThreads, totalOps/numMilis);\n    }",
      "line_number": 322,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "performanceTest32Cores",
      "signature": "static void performanceTest32Cores() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "static"
      ],
      "dependencies": [
        "saveDBDedicated",
        "asList",
        "out.println",
        "tests.myinit",
        "println",
        "Integer",
        "myinit",
        "availableProcessors",
        "Runtime.getRuntime",
        "Arrays.asList",
        "LinkedList",
        "allDedicatedWriterTests",
        "tests.allDedicatedWriterTests",
        "BenchmarkTreeSetFullRebalance",
        "csv.saveDBDedicated",
        "getRuntime"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        LinkedList<Integer> threadList = new LinkedList<Integer>(Arrays.asList(2, 3, 4, 6, 8, 12, 16, 20, 24, 28, 32));\n        \n        // Do a test run for 1K elements or 1M elements\n        BenchmarkTreeSetFullRebalance tests = new BenchmarkTreeSetFullRebalance(1000*1);\n        tests.myinit();\n          \n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n        for (Integer nThreads : threadList) {\n            tests.allDedicatedWriterTests(nThreads);\n        }\n        // Save the results of the test runs in .csv format to import in Excel\n        tests.csv.saveDBDedicated(NumOps.TotalOps, tests.numElements);\n        tests.csv.saveDBDedicated(NumOps.ReadOps,  tests.numElements);\n        tests.csv.saveDBDedicated(NumOps.WriteOps, tests.numElements);  \n    }",
      "line_number": 358,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "simpleDedicateTest",
      "signature": "static void simpleDedicateTest() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "static"
      ],
      "dependencies": [
        "asList",
        "out.println",
        "tests.myinit",
        "println",
        "Integer",
        "myinit",
        "availableProcessors",
        "Runtime.getRuntime",
        "Arrays.asList",
        "LinkedList",
        "allDedicatedWriterTests",
        "tests.allDedicatedWriterTests",
        "BenchmarkTreeSetFullRebalance",
        "getRuntime"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "        LinkedList<Integer> threadList = new LinkedList<Integer>(Arrays.asList(4));\n        \n        BenchmarkTreeSetFullRebalance tests = new BenchmarkTreeSetFullRebalance();\n        tests.myinit();\n          \n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n        for (Integer nThreads : threadList) {\n            tests.allDedicatedWriterTests(nThreads);\n        }\n    }",
      "line_number": 379,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "simpleWritePerMilTest",
      "signature": "static void simpleWritePerMilTest() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "static"
      ],
      "dependencies": [
        "asList",
        "out.println",
        "tests.myinit",
        "println",
        "Integer",
        "myinit",
        "availableProcessors",
        "Runtime.getRuntime",
        "allWritePerMilTests",
        "Arrays.asList",
        "tests.allWritePerMilTests",
        "saveDB",
        "csv.saveDB",
        "LinkedList",
        "BenchmarkTreeSetFullRebalance",
        "getRuntime"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 39,
      "source_code": "        LinkedList<Integer> threadList = new LinkedList<Integer>(Arrays.asList(1, 2, 3, 4, 6, 8, 12, 16, 20, 24, 28, 32));\n        //LinkedList<Integer> threadList = new LinkedList<Integer>(Arrays.asList(4));\n        \n        BenchmarkTreeSetFullRebalance tests = new BenchmarkTreeSetFullRebalance();\n        // 1K elements or 1M elements\n        int elems = 1000*1; \n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n        \n        for (Integer nThreads : threadList) {\n            int calc = elems/nThreads;\n            tests = new BenchmarkTreeSetFullRebalance(calc*nThreads);\n            tests.myinit();\n            tests.allWritePerMilTests(nThreads, 100);\n        }  // 10%\n        \n        for (Integer nThreads : threadList){\n            int calc = elems/nThreads;\n            tests = new BenchmarkTreeSetFullRebalance(calc*nThreads);\n            tests.myinit();\n            tests.allWritePerMilTests(nThreads, 10);\n        }   // 1%\n        \n        for (Integer nThreads : threadList){\n            int calc = elems/nThreads;\n            tests = new BenchmarkTreeSetFullRebalance(calc*nThreads);\n            tests.myinit();\n            tests.allWritePerMilTests(nThreads, 1);\n        }    // 0.1%\n        \n        tests.csv.saveDB(tests.numElements);\n    }",
      "line_number": 395,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "mixedTestPowerPCTest",
      "signature": "static void mixedTestPowerPCTest() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "static"
      ],
      "dependencies": [
        "asList",
        "out.println",
        "tests.myinit",
        "println",
        "Integer",
        "powerPCWritePerMilTests",
        "myinit",
        "availableProcessors",
        "Runtime.getRuntime",
        "Arrays.asList",
        "saveDB",
        "csv.saveDB",
        "LinkedList",
        "BenchmarkTreeSetFullRebalance",
        "getRuntime",
        "tests.powerPCWritePerMilTests"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 39,
      "source_code": "        LinkedList<Integer> threadList = new LinkedList<Integer>(Arrays.asList(1, 2, 3, 4, 8, 16, 32, 64, 128, 176));\n        //LinkedList<Integer> threadList = new LinkedList<Integer>(Arrays.asList(8));\n        \n        BenchmarkTreeSetFullRebalance tests = new BenchmarkTreeSetFullRebalance();\n        // 1K elements or 1M elements\n        int elems = 1000*1; \n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n        \n        for (Integer nThreads : threadList) {\n            int calc = elems/nThreads;\n            tests = new BenchmarkTreeSetFullRebalance(calc*nThreads);\n            tests.myinit();\n            tests.powerPCWritePerMilTests(nThreads, 100);\n        }  // 10%\n        \n        for (Integer nThreads : threadList){\n            int calc = elems/nThreads;\n            tests = new BenchmarkTreeSetFullRebalance(calc*nThreads);\n            tests.myinit();\n            tests.powerPCWritePerMilTests(nThreads, 10);\n        }   // 1%\n        \n        for (Integer nThreads : threadList){\n            int calc = elems/nThreads;\n            tests = new BenchmarkTreeSetFullRebalance(calc*nThreads);\n            tests.myinit();\n            tests.powerPCWritePerMilTests(nThreads, 1);\n        }    // 0.1%\n        \n        tests.csv.saveDB(tests.numElements);\n    }",
      "line_number": 434,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetFullRebalance.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 1,
      "source_code": "        //performanceTest32Cores(); \n        //simpleWritePerMilTest();\n        //simpleDedicateTest();       \n        mixedTestPowerPCTest();\n    }",
      "line_number": 468,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BenchmarkTreeSetFullRebalance",
      "method_type": "method"
    },
    {
      "name": "ScalableRWLockTreeSet",
      "signature": "public ScalableRWLockTreeSet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "TreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        treeSet = new TreeSet<E>();\n    }",
      "line_number": 58,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "constructor"
    },
    {
      "name": "ScalableRWLockTreeSet",
      "signature": "public ScalableRWLockTreeSet(Comparator<? super E> comparator) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "TreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        treeSet = new TreeSet<E>(comparator);\n    }",
      "line_number": 62,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "constructor"
    },
    {
      "name": "clear",
      "signature": "public void clear() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "exclusiveLock",
        "srwlock.exclusiveLock",
        "exclusiveUnlock",
        "clear",
        "srwlock.exclusiveUnlock",
        "treeSet.clear"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.exclusiveLock();\n        try {\n            treeSet.clear();\n        } finally {\n            srwlock.exclusiveUnlock();\n        }\n    }",
      "line_number": 67,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "clone",
      "signature": "public Object clone() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "sharedUnlock",
        "srwlock.sharedUnlock",
        "sharedLock",
        "srwlock.sharedLock",
        "clone",
        "treeSet.clone"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.clone();\n        } finally {\n            srwlock.sharedUnlock();\n        }\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "comparator",
      "signature": "public Comparator<? super E> comparator() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "treeSet.comparator",
        "comparator",
        "sharedUnlock",
        "srwlock.sharedUnlock",
        "sharedLock",
        "srwlock.sharedLock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.comparator();\n        } finally {\n            srwlock.sharedUnlock();\n        }        \n    }",
      "line_number": 85,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "containsKey",
      "signature": "public boolean containsKey(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "contains",
        "sharedUnlock",
        "treeSet.contains",
        "srwlock.sharedUnlock",
        "sharedLock",
        "srwlock.sharedLock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.contains(key);\n        } finally {\n            srwlock.sharedUnlock();\n        }        \n    }",
      "line_number": 94,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "first",
      "signature": "public E first() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "first",
        "sharedUnlock",
        "treeSet.first",
        "srwlock.sharedUnlock",
        "sharedLock",
        "srwlock.sharedLock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.first();\n        } finally {\n            srwlock.sharedUnlock();\n        }          \n    }",
      "line_number": 103,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "higher",
      "signature": "public E higher(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "treeSet.higher",
        "sharedUnlock",
        "srwlock.sharedUnlock",
        "sharedLock",
        "higher",
        "srwlock.sharedLock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.higher(key);\n        } finally {\n            srwlock.sharedUnlock();\n        }        \n    }",
      "line_number": 112,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "isEmpty",
      "signature": "public boolean isEmpty() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "sharedUnlock",
        "isEmpty",
        "srwlock.sharedUnlock",
        "sharedLock",
        "srwlock.sharedLock",
        "treeSet.isEmpty"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.isEmpty();\n        } finally {\n            srwlock.sharedUnlock();\n        }   \n    }",
      "line_number": 121,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "lowerKey",
      "signature": "public E lowerKey(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "sharedUnlock",
        "treeSet.lower",
        "srwlock.sharedUnlock",
        "sharedLock",
        "srwlock.sharedLock",
        "lower"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.lower(key);\n        } finally {\n            srwlock.sharedUnlock();\n        }\n    }   ",
      "line_number": 130,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "treeSet.add",
        "exclusiveLock",
        "add",
        "srwlock.exclusiveLock",
        "exclusiveUnlock",
        "srwlock.exclusiveUnlock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.exclusiveLock();\n        try {\n            return treeSet.add(elem);\n        } finally {\n           srwlock.exclusiveUnlock();\n        }\n    }",
      "line_number": 139,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "exclusiveLock",
        "treeSet.remove",
        "srwlock.exclusiveLock",
        "exclusiveUnlock",
        "srwlock.exclusiveUnlock",
        "remove"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.exclusiveLock();\n        try {\n            return treeSet.remove(elem);\n        } finally {\n            srwlock.exclusiveUnlock();\n        }        \n    }",
      "line_number": 148,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "size",
      "signature": "public int size() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "size",
        "treeSet.size",
        "sharedUnlock",
        "srwlock.sharedUnlock",
        "sharedLock",
        "srwlock.sharedLock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.size();\n        } finally {\n            srwlock.sharedUnlock();\n        }        \n    }    ",
      "line_number": 157,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/ScalableRWLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "sharedUnlock",
        "srwlock.sharedUnlock",
        "sharedLock",
        "treeSet.toString",
        "srwlock.sharedLock",
        "toString"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        srwlock.sharedLock();\n        try {\n            return treeSet.toString();\n        } finally {\n        srwlock.sharedUnlock();\n        }        \n    }   ",
      "line_number": 166,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ScalableRWLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "finalize",
      "signature": "protected void finalize() throws Throwable {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "super.finalize",
        "finalize"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            removeState(this.st);\n            super.finalize();\n        }",
      "line_number": 123,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "LRScalableTreeSetRV",
      "signature": "public LRScalableTreeSetRV() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "ConcurrentLinkedQueue",
        "Thread",
        "AtomicReference",
        "ThreadLocal"
      ],
      "dependencies": [
        "AtomicReference",
        "TreeSet",
        "State",
        "ReadersEntry",
        "ConcurrentLinkedQueue",
        "ThreadLocal",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        \n        leftTree  = new TreeSet<E>();\n        rightTree = new TreeSet<E>();\n        \n        // Only \"Write\" operations can modify leftRight\n        leftRight = READS_ON_LEFT;\n        writerLeftRight = READS_ON_LEFT;\n\n        // Stores the Reader's state for each thread\n        readersStateQ = new ConcurrentLinkedQueue<State>();\n\n        readersStateArray = new AtomicReference(null);\n        \n        entry = new ThreadLocal<ReadersEntry>();\n\n        writeState = new State[128];\n    }",
      "line_number": 133,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "constructor"
    },
    {
      "name": "removeState",
      "signature": "protected void removeState(State st) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "readersStateArray.set",
        "readersStateQ.remove",
        "remove",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        // We don't need to lock in exclusive mode thanks to the GC\n        st.readerState = STATE_NOT_READING;\n        readersStateQ.remove(st);\n        readersStateArray.set(null);\n    }",
      "line_number": 157,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "addState",
      "signature": "private ReadersEntry addState() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "add",
        "ReadersEntry",
        "entry.set",
        "set",
        "readersStateArray.set",
        "readersStateQ.add"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final ReadersEntry newEntry = new ReadersEntry(STATE_NOT_READING);        \n        entry.set(newEntry);        \n        readersStateQ.add(newEntry.st);\n        readersStateArray.set(null);\n        return newEntry;\n    }",
      "line_number": 169,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "rebuildArraysIfNeeded",
      "signature": "private State[] rebuildArraysIfNeeded() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "size",
        "compareAndSet",
        "get",
        "set",
        "toArray",
        "readersStateArray.set",
        "readersStateQ.toArray",
        "readersStateQ.size",
        "readersStateArray.get",
        "readersStateArray.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        State[] localReadersStateArray = readersStateArray.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before copying readersStateQ\n            readersStateArray.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStateQ.toArray(new State[readersStateQ.size()]);\n            readersStateArray.compareAndSet(dummyArray, localReadersStateArray);\n        }\n        \n        return localReadersStateArray;\n    }",
      "line_number": 181,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "scanInitialReaders",
      "signature": "private int scanInitialReaders() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        final State[] localReadersVersionArray = rebuildArraysIfNeeded();\n        \n        int i=0;\n        // Wait for Readers from next version\n        for (State readerState : localReadersVersionArray) {\n            \n            if (readerState!= null){\n                /*\n                * gets the initial version of the Reader\n                */\n                long initialstate = readerState.readerState;\n                if(initialstate > STATE_NOT_READING){\n                    writeState[i] = readerState;\n                    writeStateInitial[i] = initialstate;\n                    i++;\n                }\n            }\n        }\n        return i;\n    }    ",
      "line_number": 194,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "scanReaders",
      "signature": "private void scanReaders() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "yield",
        "Thread.yield"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        \n        final int length = scanInitialReaders();\n        \n        for(int j=0;j<length;j++){\n            \n            /*\n             * If the state is positive or the state didn't change since the \n             * arrival of the Writer then it means that the Reader is performing\n             * a read in one of the trees and it could be the tree were the Writer\n             * wants to enter. Once the version of the Reader changes it means that\n             * the read has to be performing on the tree opposite to where the Writer\n             * wants to enter. If the state is negative it means that there is\n             * no read associated with that thread at this moment.\n             */\n            State wstate = writeState[j];\n            long initialstate = writeStateInitial[j];\n            long state = wstate.readerState;\n            while (state > STATE_NOT_READING && state == initialstate){\n                Thread.yield();\n                state = wstate.readerState;\n            }\n        }\n    }   ",
      "line_number": 223,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "signal",
        "Thread",
        "final"
      ],
      "dependencies": [
        "contains",
        "leftTree.contains",
        "entry.get",
        "get",
        "rightTree.contains"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 26,
      "source_code": "        ReadersEntry localReadersEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localReadersEntry == null) {\n            localReadersEntry = addState();\n        }\n        \n        final long localReaderState = localReadersEntry.st.localreaderState;    \n        // \"Publish\" a positive readerState to signal to Writer that this \n        // Reader is in-progress\n        localReadersEntry.st.readerState = -localReaderState+1;\n        // Read the up-to-date value of leftRight.\n        final boolean retValue;\n        if (leftRight == READS_ON_LEFT) {\n            retValue = leftTree.contains(elem);\n        } else {\n            retValue = rightTree.contains(elem);\n        }\n        localReadersEntry.st.readerState = localReaderState-1;\n        localReadersEntry.st.localreaderState = localReaderState-1;\n        return retValue;\n    }",
      "line_number": 256,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public synchronized boolean add(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "leftTree.add",
        "rightTree.add",
        "add"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        final boolean retValue;\n        // Do the put() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.\n        if (writerLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.add(elem);\n        } else {\n            retValue = leftTree.add(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        writerLeftRight = -writerLeftRight;\n        leftRight = writerLeftRight;\n        scanReaders();\n\n        if (writerLeftRight == READS_ON_LEFT) {\n            rightTree.add(elem);\n        } else {\n            leftTree.add(elem);\n        }\n        return retValue;\n    }",
      "line_number": 287,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public synchronized boolean remove(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetRV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "leftTree.remove",
        "remove",
        "rightTree.remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        final boolean retValue;\n        // Do the remove() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.\n        if (writerLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.remove(elem);\n        } else {\n            retValue = leftTree.remove(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n      \n        writerLeftRight = -writerLeftRight;\n        // Does an atomic set()\n        leftRight = writerLeftRight;\n        scanReaders();\n\t\t\n        if (writerLeftRight == READS_ON_LEFT) {\n        \trightTree.remove(elem);\n        } else {\n        \tleftTree.remove(elem);\n        }\t\t\n        return retValue;\n    }",
      "line_number": 320,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetRV",
      "method_type": "method"
    },
    {
      "name": "BenchmarkTreeSetLatency",
      "signature": "public BenchmarkTreeSetLatency(int numElements) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetLatency.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        this.numElements = numElements;\n        this.udarray = new UserData[numElements*4];\n    }",
      "line_number": 58,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetLatency",
      "method_type": "constructor"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetLatency.java",
      "language": "java",
      "sync_primitives": [
        "getAndAdd"
      ],
      "dependencies": [
        "heartBeat.getAndAdd",
        "getAndAdd"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "            while (!quit) {\n                heartBeat.getAndAdd(1);\n            }\n        }",
      "line_number": 69,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BenchmarkTreeSetLatency",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetLatency.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "ordinal",
        "lrScalableTreeSetOptimistic.optimisticContains",
        "containsKey",
        "add",
        "snapTreeMap.remove",
        "lrScalableTreeSetOptimistic.add",
        "snapTreeMap.containsKey",
        "lrScalableTreeSetOptimistic.remove",
        "scalableRWLockTreeSet.add",
        "stype.ordinal",
        "scalableRWLockTreeSet.containsKey",
        "optimisticContains",
        "out.println",
        "lrScalableTreeSet.add",
        "put",
        "lrScalableTreeSet.contains",
        "get",
        "System.nanoTime",
        "nanoTime",
        "contains",
        "println",
        "scalableRWLockTreeSet.remove",
        "heartBeat.get",
        "lrScalableTreeSet.remove",
        "snapTreeMap.put",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 31,
      "source_code": "\n            for (long i = 0; i < numIterations; i++) {\n                if (quit) return; \n\n                if (writePerMil != 1000 && (writePerMil == 0 || (i % 1000 > writePerMil))) {\n                    final int i0 = (int)(i % (numElements*4));\n                    final UserData ud0 = udarray[i0];\n                    \n                    long startBeats = System.nanoTime();\n                    //long startBeats = heartBeat.get();\n                    switch (stype) {\n                        case LRScalableTreeSet:                             \n                            lrScalableTreeSet.contains(ud0);\n                            break;\n                        case LRScalableTreeSetOptimistic:                             \n                            lrScalableTreeSetOptimistic.optimisticContains(ud0);\n                            break;\n                        case SnapTreeMap:                    \n                            snapTreeMap.containsKey(ud0);\n                            break;\n                        case ScalableRWLockTreeSet:\n                            scalableRWLockTreeSet.containsKey(ud0);\n                            break;\n                    }\n                    long stopBeats = System.nanoTime();\n                    //long stopBeats = heartBeat.get();\n                    final long numbeats = stopBeats-startBeats;   \n                    if (doMeasures) {\n                        storeLinearLatency(numbeats);\n                        numHeartBeats += numbeats;                        \n                        numReadOps += 1;\n                        numOps += 1;\n                    }\n                } else {\n                    int iAdd, iRemove;\n                    if (tidx == 0) { // tidx 0 and 1 are always Writers\n                        iAdd = (int)((evenIndex[stype.ordinal()]) % (numElements*4));\n                        iRemove = (int)((evenIndex[stype.ordinal()] - numElements) % (numElements*4));\n                        evenIndex[stype.ordinal",
      "line_number": 99,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetLatency",
      "method_type": "method"
    },
    {
      "name": "computeVAR",
      "signature": "public double computeVAR(double percentage) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetLatency.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "            final long cutoff = (long)(numReadOps*percentage);\n            long sum = 0;\n            for (int ibox=0; ibox < readLatencyLinearHistogram.length; ibox++) {\n                sum += readLatencyLinearHistogram[ibox];\n                //System.out.println(\"sum = \"+sum+\"  cutoff = \"+cutoff);\n                if (sum >= cutoff) {\n                    System.out.println(\"Latency at \"+percentage*100+\"% = \"+ibox*1000./LINEAR_BIN_WIDTH+\" micro-seconds\");\n                    return 0;\n                }\n            }\n            System.out.println(\"Latency at \"+percentage*100+\"% = ???\");\n            return 0;\n        }",
      "line_number": 193,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BenchmarkTreeSetLatency",
      "method_type": "method"
    },
    {
      "name": "myinit",
      "signature": "private void myinit() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetLatency.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "println",
        "put",
        "add",
        "ordinal",
        "lrScalableTreeSet.add",
        "UserData",
        "lrScalableTreeSetOptimistic.add",
        "MAX_TEST_CASES.ordinal",
        "snapTreeMap.put",
        "scalableRWLockTreeSet.add"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        for (int i = 0; i < numElements*4; i++) {\n            udarray[i] = new UserData();\n            udarray[i].a = i;\n            udarray[i].b = i % 7;\n        }\n        for (int i = 0; i < TestCase.MAX_TEST_CASES.ordinal(); i++) {\n            oddIndex[i] = numElements+1;\n            evenIndex[i] = numElements;\n        }\n\n        System.out.println(\"Filling up trees with \"+numElements+\" elements...\");\n        for (int i = 0; i < numElements; i++) lrScalableTreeSet.add(udarray[i]);\n        for (int i = 0; i < numElements; i++) lrScalableTreeSetOptimistic.add(udarray[i]);\n        for (int i = 0; i < numElements; i++) snapTreeMap.put(udarray[i], udarray[i]);\n        for (int i = 0; i < numElements; i++) scalableRWLockTreeSet.add(udarray[i]);\n    }",
      "line_number": 210,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetLatency",
      "method_type": "method"
    },
    {
      "name": "dedicatedWriterTest",
      "signature": "public void dedicatedWriterTest(int numThreads, TestCase stype) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetLatency.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "Thread",
        "final"
      ],
      "dependencies": [
        "HeartBeatThread",
        "length",
        "Thread.sleep",
        "computeVAR",
        "join",
        "out.print",
        "e.printStackTrace",
        "hb.start",
        "start",
        "printStackTrace",
        "out.println",
        "print",
        "stype.toString",
        "hb.join",
        "substring",
        "toString",
        "sleep",
        "println",
        "WorkerThread"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 127,
      "source_code": "        // If we see an error here just increase the number of spaces\n        String indentedName = stype.toString() + \"                              \".substring(stype.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n        \n        // Create the Worker threads threads and the hearbeat thread\n        for (int i = 0; i < numThreads; i++) {\n            if (i == 0 || i == 1) {\n                // The first two threads are Writers\n                workerThreads[i] = new WorkerThread(1000, stype, i);\n            } else {\n                workerThreads[i] = new WorkerThread(0, stype, i);\n            }\n        }\n        HeartBeatThread hb = new HeartBeatThread();\n        hb.start();\n        \n        // Sleep for 0.1 seconds before starting the worker threads\n        try {\n            Thread.sleep(100);\n        } catch(InterruptedException e){\n            System.out.println(\"InterruptedException\");\n        }\n        // Start the worker threads\n        for (int i = 0; i < numThreads; i++) workerThreads[i].start();\n\n        // The first 20 seconds we don't measure anything\n        try {\n            Thread.sleep(20*1000);\n        } catch(InterruptedException e){\n            System.out.println(\"InterruptedException\");\n        }\n        // Start the measurements\n        for (int i = 0; i < numThreads; i++) workerThreads[i].doMeasures = true;\n\n        // Sleep for 10k seconds\n        try {\n            Thread.sleep(numMilis);\n        } catch(InterruptedException e){\n            System.out.println(\"InterruptedException\");\n        }\n        // Stop the worker threads\n        for (int i = 0; i < numThreads; i++) workerThreads[i].quit = true;\n        \n        long totalReadOps = 0;\n        for (int i = 0; i < numThreads; i++) {\n            totalReadOps += workerThreads[i].numReadOps;\n        }\n        \n        try {\n            for (int i = 0; i < numThreads; i++) workerThreads[i].join();\n        } catch (InterruptedException e) {\n            e.printStac",
      "line_number": 229,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSetLatency",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/BenchmarkTreeSetLatency.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "tests.myinit",
        "println",
        "myinit",
        "availableProcessors",
        "Runtime.getRuntime",
        "tests.dedicatedWriterTest",
        "getRuntime",
        "BenchmarkTreeSetLatency",
        "dedicatedWriterTest"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        final int numThreads = 4;\n        final int numElements = 1000*1000;\n                \n        BenchmarkTreeSetLatency tests = new BenchmarkTreeSetLatency(numElements);\n        tests.myinit();\n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n        System.out.println(\"Set the javaw.exe to high priority and run the JVM with -XX:+CMSIncrementalMode before running this test suite\");\n        \n        tests.dedicatedWriterTest(numThreads, TestCase.ScalableRWLockTreeSet);\n        tests.dedicatedWriterTest(numThreads, TestCase.LRScalableTreeSet);\n        tests.dedicatedWriterTest(numThreads, TestCase.LRScalableTreeSetOptimistic);\n        tests.dedicatedWriterTest(numThreads, TestCase.SnapTreeMap);\n    }",
      "line_number": 340,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSetLatency",
      "method_type": "method"
    },
    {
      "name": "finalize",
      "signature": "protected void finalize() throws Throwable {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "super.finalize",
        "finalize"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "            removeState(this.st);\n            super.finalize();\n        }",
      "line_number": 100,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "LRScalableTreeSetNV",
      "signature": "public LRScalableTreeSetNV() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReference",
        "AtomicInteger",
        "ConcurrentLinkedQueue",
        "Thread",
        "ThreadLocal"
      ],
      "dependencies": [
        "AtomicReference",
        "TreeSet",
        "AtomicInteger",
        "State",
        "ReadersEntry",
        "ConcurrentLinkedQueue",
        "ThreadLocal",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        \n        leftTree  = new TreeSet<E>();\n        rightTree = new TreeSet<E>();\n        \n        // Only \"Write\" operations can modify this\n        leftRight    = new AtomicInteger(READS_ON_LEFT);\n\n        // Stores the Reader's state for each thread\n        readersStatesQ = new ConcurrentLinkedQueue<State>();\n\n        readersStateArray = new AtomicReference(null);\n        \n        entry = new ThreadLocal<ReadersEntry>();\n    }",
      "line_number": 110,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "constructor"
    },
    {
      "name": "removeState",
      "signature": "protected void removeState(State st) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "readersStateArray.set",
        "readersStatesQ.remove",
        "remove",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        // We don't need to lock in exclusive mode Java thanks to the GC\n        st.readerState = STATE_NOT_READING;\n        readersStatesQ.remove(st);\n        readersStateArray.set(null);\n    }",
      "line_number": 131,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "addState",
      "signature": "private ReadersEntry addState() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "readersStatesQ.add",
        "add",
        "ReadersEntry",
        "entry.set",
        "set",
        "readersStateArray.set"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final ReadersEntry newEntry = new ReadersEntry(STATE_NOT_READING);         \n        entry.set(newEntry);        \n        readersStatesQ.add(newEntry.st);\n        readersStateArray.set(null);        \n        return newEntry;\n    }",
      "line_number": 143,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "rebuildArraysIfNeeded",
      "signature": "private State[] rebuildArraysIfNeeded() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "size",
        "compareAndSet",
        "readersStatesQ.toArray",
        "get",
        "set",
        "toArray",
        "readersStateArray.set",
        "readersStatesQ.size",
        "readersStateArray.get",
        "readersStateArray.compareAndSet"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "        State[] localReadersStateArray = readersStateArray.get();\n        if (localReadersStateArray == null) {\n            // Set to dummyArray before copying readersStateQ\n            readersStateArray.set(dummyArray);\n            // Copy readersStateList to an array\n            localReadersStateArray = readersStatesQ.toArray(new State[readersStatesQ.size()]);\n            readersStateArray.compareAndSet(dummyArray, localReadersStateArray);\n        }\n        \n        return localReadersStateArray;\n    }",
      "line_number": 155,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "scanReaders",
      "signature": "private void scanReaders(int localLeftRight) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Thread",
        "final"
      ],
      "dependencies": [
        "yield",
        "Thread.yield"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 10,
      "source_code": "        \n        final State[] localReadersVersionArray = rebuildArraysIfNeeded();\n        \n        // Wait for Readers from next version\n        for (State readerState : localReadersVersionArray) {\n            \n            if (readerState!= null){\n                while (readerState.readerState == STATE_READING || readerState.readerState == localLeftRight){\n                    Thread.yield();\n                }\n            }\n        }\n    } ",
      "line_number": 175,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "Thread",
        "ThreadLocal"
      ],
      "dependencies": [
        "contains",
        "leftTree.contains",
        "entry.get",
        "leftRight.get",
        "get",
        "rightTree.contains"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        ReadersEntry localReadersEntry = entry.get();\n        // Initialize a new Reader-state for this thread if needed         \n        if (localReadersEntry == null) {\n            localReadersEntry = addState();\n        }\n        \n        // Cache the pointers as optimization\n        final State localState = localReadersEntry.st;      \n        localState.readerState = STATE_READING;\n\n        // Read the up-to-date value of leftRight.\n        // Order is important: The {@code leftRight} value can only be \n        // read _after_ the counter has been incremented for the \n        // corresponding {@code versionIndex}.\n        final int threadLocalLeftRight = leftRight.get();\n        final boolean retValue;\n        localState.readerState = threadLocalLeftRight;\n        if (threadLocalLeftRight == READS_ON_LEFT) {\n            retValue = leftTree.contains(elem);\n        } else {\n            retValue = rightTree.contains(elem);\n        }\n        localState.readerState = STATE_NOT_READING;      \n        \n        return retValue;\n    }",
      "line_number": 204,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public synchronized boolean add(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "add",
        "leftRight.set",
        "leftRight.get",
        "get",
        "set",
        "leftTree.add",
        "rightTree.add"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final boolean retValue;\n        final int localLeftRight = leftRight.get();\n        // Do the add() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.\n        if (localLeftRight == READS_ON_LEFT) {\n            retValue = rightTree.add(elem);\n        } else {\n            retValue = leftTree.add(elem); \n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        // Notice that when doing a \"Read\", we first read the \n        // {@code versionIndex} and then the {@code leftRight}, while \n        // doing the \"Write\" the order is reversed: first we toggle the\n        // {@code leftRight} and then we toggle the {@code versionIndex}.\t\t\n        scanReaders(localLeftRight);\n\n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.add(elem);\n        } else {\n            leftTree.add(elem);\n        }\n        return retValue;\n    }",
      "line_number": 239,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public synchronized boolean remove(E elem) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/LeftRight/LRScalableTreeSetNV.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "final",
        "synchronized"
      ],
      "dependencies": [
        "leftRight.set",
        "leftRight.get",
        "get",
        "rightTree.remove",
        "set",
        "leftTree.remove",
        "remove"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "        final boolean retValue;\n        final int localLeftRight = leftRight.get();\n        // Do the remove() in the first Tree, opposite to the one currently \n        // being used by the Read operations. No need to wait.\n        if (leftRight.get() == READS_ON_LEFT) {\n            retValue = rightTree.remove(elem);\n        } else {\n            retValue = leftTree.remove(elem);\n        }\n        // Optimization that only works for Sets\n        if (!retValue) return false;\n\n        // Toggle leftRight and wait for currently running Readers\n        leftRight.set(-localLeftRight);\n        // Notice that when doing a \"Read\", we first read the \n        // {@code versionIndex} and then the {@code leftRight}, while \n        // doing the \"Write\" the order is reversed: first we toggle \n        // the {@code leftRight} and then we increment {@code versionIndex}.\t\t     \n        scanReaders(localLeftRight);\n\t\t        \n        if (-localLeftRight == READS_ON_LEFT) {\n            rightTree.remove(elem);\n        } else {\n        \tleftTree.remove(elem);\n        }\n        return retValue;\n    }       ",
      "line_number": 277,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LRScalableTreeSetNV",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet() { super(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 47,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet(CopyableTreeSet<E> tree) { super(tree); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 48,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "copyOf",
      "signature": "public Object copyOf() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return new CopyableTreeSet<E>(this);\n        }",
      "line_number": 50,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyOnWriteMQWFTreeSet",
      "signature": "public CopyOnWriteMQWFTreeSet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super(new CopyableTreeSet<E>());\n    }",
      "line_number": 55,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "constructor"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "instance.contains"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.contains(key);\n    }",
      "line_number": 62,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.add",
        "add",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.add(_key));\n    }",
      "line_number": 69,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.remove",
        "remove",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.remove(_key));\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQWFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "tree.addAll",
        "addAll"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(null, c, null, (E _nop1, Collection<? extends E> _c, E _nop3, TreeSet<E> tree) -> tree.addAll(_c));\n    }    ",
      "line_number": 83,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQWFTreeSet",
      "method_type": "method"
    },
    {
      "name": "LeftRightTreeSet",
      "signature": "public LeftRightTreeSet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/LeftRightTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "E",
        "TreeSet",
        "RIArrayCLQFinalizers"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super(new TreeSet<E>(), new TreeSet<E>(), new RIArrayCLQFinalizers(), new RIArrayCLQFinalizers());\n    }",
      "line_number": 49,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LeftRightTreeSet",
      "method_type": "constructor"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/LeftRightTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "tree.contains",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyReadOnly((E)key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.contains(_key));\n    }",
      "line_number": 56,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LeftRightTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/LeftRightTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.add",
        "add",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.add(_key));\n    }",
      "line_number": 63,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LeftRightTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/LeftRightTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.remove",
        "remove",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.remove(_key));\n    }",
      "line_number": 70,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LeftRightTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/LeftRightTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "tree.addAll",
        "addAll"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(null, c, null, (E _nop, Collection<? extends E> _c, E _nop2, TreeSet<E> tree) -> tree.addAll(_c) );\n    }",
      "line_number": 77,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LeftRightTreeSet",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(MutationNode<P1, P2, P3, C> cmp, MutationNode<P1, P2, P3, C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 227,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "Combined",
      "signature": "public Combined(MutationNode<P1,P2,P3,C> head, C instance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "            this.head = head;\n            this.instance = instance;\n        }",
      "line_number": 267,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "COWMutationQWF",
      "signature": "public COWMutationQWF(C cloneableInstance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [
        "AtomicReferenceArray",
        "Thread",
        "AtomicReference"
      ],
      "dependencies": [
        "state.set",
        "P1",
        "Combined",
        "length",
        "OpDesc",
        "set",
        "state.length"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "singleton_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        // The head starts by pointing at the same node as tail\n        combinedRef = new Combined(tail, cloneableInstance);\n        state = new AtomicReferenceArray<OpDesc<P1,P2,P3,C>>(NUM_THREADS);\n        for (int i = 0; i < state.length(); i++) {\n            state.set(i, new OpDesc<P1,P2,P3,C>(-1, false, null));\n        }\n\n    }",
      "line_number": 288,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "applyMutation",
      "signature": "public <R> R applyMutation(P1 param1, P2 param2, P3 param3, QuadFunction<P1, P2, P3, ? super C, R> mutativeFunc) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "currentThread",
        "getId",
        "Thread.currentThread",
        "P1",
        "Combined",
        "copyOf",
        "MutationNode",
        "apply",
        "R",
        "mutativeFunc.apply",
        "instance.copyOf",
        "mutation.apply"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        // We better have consecutive thread ids, otherwise this will blow up\n        // TODO: replace this mechanism with something more flexible, like the CLQ+Array+Finalizers\n        final int TID = (int)(Thread.currentThread().getId() % NUM_THREADS);\n\n        final MutationNode<P1,P2,P3,C> myNode = new MutationNode<P1,P2,P3,C>(mutativeFunc, param1, param2, param3, TID);\n        Combined<P1, P2, P3, C> curComb = combinedRef;\n        // Insert our node in the queue\n        enq(myNode, TID);\n        \n        // Clone the current instance and apply all mutations up until our node is reached\n        final C mutatedInstance = (C)curComb.instance.copyOf();\n        for (MutationNode<P1,P2,P3,C> mn = curComb.head.next; mn != myNode; mn = mn.next) {\n            mn.mutation.apply(mn.param1, mn.param2, mn.param3, mutatedInstance);\n        }\n        // Save the return value of the last mutation (ours). We don't care about the other return values.\n        final R retValue = mutativeFunc.apply(param1, param2, param3, mutatedInstance);\n               \n        // Create a new Combined with all the mutations up to ours (inclusive) \n        // and try to CAS the ref to it until it has our mutation.\n        final Combined<P1,P2,P3,C> newComb = new Combined<P1,P2,P3,C>(myNode, mutatedInstance);\n        do {\n            if (curComb != combinedRef) {\n                curComb = combinedRef;\n                MutationNode<P1,P2,P3,C> ltail = tail;\n                // Traverse the list until we reach the end, or our own node\n                for (MutationNode<P1,P2,P3,C> mn = curComb.head; mn != myNode; mn = mn.next)\n                    if (mn == ltail) return retValue; // Our mutation is visible\n            }\n        } while (!casRef(curComb, newComb));\n        // Our mutation is now visible to other threads (through combinedRef)\n        \n        return retValue;\n    }",
      "line_number": 312,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "maxPhase",
      "signature": "private long maxPhase() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "state.length",
        "get",
        "length"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        long maxPhase = -1;\n        for (int i = 0; i < state.length(); i++) {\n            long phase = state.get(i).phase;\n            if (phase > maxPhase) {\n                maxPhase = phase;\n            }\n        }\n        return maxPhase;\n    }",
      "line_number": 363,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "isStillPending",
      "signature": "private boolean isStillPending(int tid, long ph) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "state.get",
        "get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return state.get(tid).pending && state.get(tid).phase <= ph;\n    }",
      "line_number": 375,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "enq",
      "signature": "private void enq(MutationNode<P1,P2,P3,C> myNode, int TID) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1",
        "state.set",
        "OpDesc",
        "set"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        long phase = maxPhase() + 1;\n        state.set(TID, new OpDesc<P1,P2,P3,C>(phase, true, myNode));\n        help(phase);\n        help_finish_enq();\n    }",
      "line_number": 380,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "help_enq",
      "signature": "private void help_enq(int tid, long phase) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1",
        "last.casNext",
        "get",
        "casNext",
        "state.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "        while (isStillPending(tid, phase)) {\n            MutationNode<P1,P2,P3,C> last = tail;\n            MutationNode<P1,P2,P3,C> next = last.next;\n            if (last == tail) {\n                if (next == null) {\n                    if (isStillPending(tid, phase)) {\n                        if (last.casNext(next, state.get(tid).node)) {\n                            help_finish_enq();\n                            return;\n                        }\n                    }\n                } else {\n                    help_finish_enq();\n                }\n            }\n        }\n    }",
      "line_number": 388,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "help_finish_enq",
      "signature": "private void help_finish_enq() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "compareAndSet",
        "P1",
        "get",
        "state.compareAndSet",
        "OpDesc",
        "state.get"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        final MutationNode<P1,P2,P3,C> last = tail;\n        final MutationNode<P1,P2,P3,C> next = last.next;\n        if (next != null) {\n            int tid = next.enqTid;\n            final OpDesc<P1,P2,P3,C> curDesc = state.get(tid);\n            if (last == tail && state.get(tid).node == next) {\n                final OpDesc<P1,P2,P3,C> newDesc = new OpDesc<P1,P2,P3,C>(state.get(tid).phase, false, next);\n                state.compareAndSet(tid, curDesc, newDesc);\n                casTail(last, next);\n            }\n        }\n    }",
      "line_number": 408,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(MutationNode<P1,P2,P3,C> cmp, MutationNode<P1,P2,P3,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 443,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casRef",
      "signature": "private boolean casRef(Combined<P1,P2,P3,C> cmp, Combined<P1,P2,P3,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQWF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, refOffset, cmp, val);\n    }    ",
      "line_number": 447,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(MutationNode<P1, P2, P3, C> cmp, MutationNode<P1, P2, P3, C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 188,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "Combined",
      "signature": "public Combined(MutationNode<P1,P2,P3,C> head, C instance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "P1"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "            this.head = head;\n            this.instance = instance;\n        }",
      "line_number": 214,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "COWMutationQLF",
      "signature": "public COWMutationQLF(C cloneableInstance) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "Combined"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        // The head starts by pointing at the same node as tail\n        combinedRef = new Combined(tail, cloneableInstance);\n    }",
      "line_number": 230,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "applyMutation",
      "signature": "public <R> R applyMutation(P1 param1, P2 param2, P3 param3, QuadFunction<P1, P2, P3, ? super C, R> mutativeFunc) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "P1",
        "Combined",
        "copyOf",
        "MutationNode",
        "apply",
        "R",
        "mutativeFunc.apply",
        "instance.copyOf",
        "mutation.apply"
      ],
      "concurrency_patterns": [
        "singleton_pattern",
        "immutable_object"
      ],
      "complexity_score": 12,
      "source_code": "        final MutationNode<P1,P2,P3,C> myNode = new MutationNode<P1,P2,P3,C>(param1, param2, param3, mutativeFunc);\n        Combined<P1,P2,P3,C> curComb = combinedRef;\n        // Insert our node in the queue\n        addToTail(myNode);\n        \n        // Clone the current instance and apply all mutations up until our node is reached\n        final C mutatedInstance = (C)curComb.instance.copyOf();\n        for (MutationNode<P1,P2,P3,C> mn = curComb.head.next; mn != myNode; mn = mn.next) {\n            mn.mutation.apply(mn.param1, mn.param2, mn.param3, mutatedInstance);\n        }\n        // Save the return value of the last mutation (ours). We don't care about the other return values.\n        final R retValue = mutativeFunc.apply(param1, param2, param3, mutatedInstance);\n               \n        // Create a new Combined with all the mutations up to ours (inclusive) \n        // and try to CAS the ref to it until it has our mutation.\n        final Combined<P1,P2,P3,C> newComb = new Combined<P1,P2,P3,C>(myNode, mutatedInstance);\n        do {\n            if (curComb != combinedRef) {\n                curComb = combinedRef;\n                MutationNode<P1,P2,P3,C> ltail = tail;\n                // Traverse the list until we reach the end, or our own node\n                for (MutationNode<P1,P2,P3,C> mn = curComb.head; mn != myNode; mn = mn.next)\n                    if (mn == ltail) return retValue; // Our mutation is visible\n            }\n        } while (!casRef(curComb, newComb));\n        // Our mutation is now visible to other threads (through combinedRef)\n        \n        return retValue;\n    }",
      "line_number": 243,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "addToTail",
      "signature": "private void addToTail(final MutationNode<P1,P2,P3,C> myNode) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "casNext",
        "P1",
        "localTail.casNext"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "        while (true) {\n            final MutationNode<P1,P2,P3,C> localTail = tail;\n            final MutationNode<P1,P2,P3,C> node = localTail.next;\n            if (localTail == tail) {\n                if (node == null) {\n                    // localTail is last node\n                    if (localTail.casNext(null, myNode)) {\n                        casTail(localTail, myNode);\n                        return;\n                    }\n                } else {\n                    casTail(localTail, node);\n                }\n            }\n        }\n    }",
      "line_number": 283,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(MutationNode<P1,P2,P3,C> cmp, MutationNode<P1,P2,P3,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 301,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "casRef",
      "signature": "private boolean casRef(Combined<P1,P2,P3,C> cmp, Combined<P1,P2,P3,C> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/COWMutationQLF.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "P1",
        "UNSAFE.compareAndSwapObject"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, refOffset, cmp, val);\n    }",
      "line_number": 305,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "to",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "treeSet.contains",
        "contains"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return treeSet.contains(key);\n    }",
      "line_number": 58,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "TreeSet",
        "add",
        "E",
        "unlock",
        "lock.lock",
        "lock",
        "lock.unlock",
        "newTreeSet.add"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        lock.lock();\n        try {\n            final TreeSet<E> newTreeSet = new TreeSet<E>(treeSet);\n            final boolean retValue = newTreeSet.add(key);\n            treeSet = newTreeSet;\n            return retValue;\n        } finally {\n            lock.unlock();\n        }\n    }",
      "line_number": 63,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "TreeSet",
        "unlock",
        "newTreeSet.remove",
        "lock.lock",
        "lock",
        "remove",
        "lock.unlock",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        lock.lock();\n        try {\n            final TreeSet<E> newTreeSet = new TreeSet<E>(treeSet);\n            final boolean retValue = newTreeSet.remove(key);\n            treeSet = newTreeSet;\n            return retValue;\n        } finally {\n            lock.unlock();\n        }\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "TreeSet",
        "unlock",
        "newTreeSet.addAll",
        "addAll",
        "lock.lock",
        "lock",
        "lock.unlock",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 20,
      "source_code": "        lock.lock();\n        try {\n            final TreeSet<E> newTreeSet = new TreeSet<E>(treeSet);\n            final boolean retValue = newTreeSet.addAll(c);\n            treeSet = newTreeSet;\n            return retValue;\n        } finally {\n            lock.unlock();\n        }\n    }",
      "line_number": 89,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CRWWPLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "contains",
        "unlock",
        "treeSet.contains",
        "crwwpLock.readLock",
        "lock",
        "readLock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        crwwpLock.readLock().lock();\n        try {\n            return treeSet.contains(key);\n        } finally {\n            crwwpLock.readLock().unlock();\n        }\n    }",
      "line_number": 54,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRWWPLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CRWWPLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "treeSet.add",
        "add",
        "unlock",
        "writeLock",
        "crwwpLock.writeLock",
        "lock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        crwwpLock.writeLock().lock();\n        try {\n            return treeSet.add(key);\n        } finally {\n            crwwpLock.writeLock().unlock();\n        }\n    }",
      "line_number": 66,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRWWPLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CRWWPLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "unlock",
        "treeSet.remove",
        "writeLock",
        "crwwpLock.writeLock",
        "lock",
        "remove"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        crwwpLock.writeLock().lock();\n        try {\n            return treeSet.remove(key);\n        } finally {\n            crwwpLock.writeLock().unlock();\n        }\n    }",
      "line_number": 78,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRWWPLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CRWWPLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "unlock",
        "writeLock",
        "treeSet.addAll",
        "crwwpLock.writeLock",
        "addAll",
        "lock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        crwwpLock.writeLock().lock();\n        try {\n            return treeSet.addAll(c);\n        } finally {\n            crwwpLock.writeLock().unlock();\n        }\n    }    ",
      "line_number": 90,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CRWWPLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/ReentrantLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "contains",
        "mutex.lock",
        "mutex.unlock",
        "unlock",
        "treeSet.contains",
        "lock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        mutex.lock();\n        try {\n            return treeSet.contains(key);\n        } finally {\n            mutex.unlock();\n        }\n    }",
      "line_number": 52,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ReentrantLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/ReentrantLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "treeSet.add",
        "add",
        "mutex.lock",
        "mutex.unlock",
        "unlock",
        "lock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        mutex.lock();\n        try {\n            return treeSet.add(key);\n        } finally {\n            mutex.unlock();\n        }\n    }",
      "line_number": 64,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ReentrantLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/ReentrantLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "mutex.lock",
        "mutex.unlock",
        "unlock",
        "treeSet.remove",
        "lock",
        "remove"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        mutex.lock();\n        try {\n            return treeSet.remove(key);\n        } finally {\n            mutex.unlock();\n        }\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ReentrantLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/ReentrantLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "unlock",
        "lock",
        "final"
      ],
      "dependencies": [
        "mutex.lock",
        "mutex.unlock",
        "unlock",
        "treeSet.addAll",
        "addAll",
        "lock"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "        mutex.lock();\n        try {\n            return treeSet.addAll(c);\n        } finally {\n            mutex.unlock();\n        }\n    }    ",
      "line_number": 88,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "ReentrantLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/StampedLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock"
      ],
      "dependencies": [
        "contains",
        "unlock",
        "treeSet.contains",
        "stampedLock.asReadLock",
        "asReadLock",
        "lock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        stampedLock.asReadLock().lock();\n        try {\n            return treeSet.contains(key);\n        } finally {\n            stampedLock.asReadLock().unlock();\n        }\n    }",
      "line_number": 52,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "StampedLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/StampedLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock"
      ],
      "dependencies": [
        "treeSet.add",
        "add",
        "asWriteLock",
        "stampedLock.asWriteLock",
        "unlock",
        "lock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        stampedLock.asWriteLock().lock();\n        try {\n            return treeSet.add(key);\n        } finally {\n            stampedLock.asWriteLock().unlock();\n        }\n    }",
      "line_number": 64,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "StampedLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/StampedLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.asWriteLock",
        "unlock",
        "treeSet.remove",
        "lock",
        "remove"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        stampedLock.asWriteLock().lock();\n        try {\n            return treeSet.remove(key);\n        } finally {\n            stampedLock.asWriteLock().unlock();\n        }\n    }",
      "line_number": 76,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "StampedLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/StampedLockTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "unlock",
        "final",
        "lock"
      ],
      "dependencies": [
        "asWriteLock",
        "stampedLock.asWriteLock",
        "unlock",
        "treeSet.addAll",
        "addAll",
        "lock"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 28,
      "source_code": "        stampedLock.asWriteLock().lock();\n        try {\n            return treeSet.addAll(c);\n        } finally {\n            stampedLock.asWriteLock().unlock();\n        }\n    }    ",
      "line_number": 88,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "StampedLockTreeSet",
      "method_type": "method"
    },
    {
      "name": "BenchmarkTreeSets",
      "signature": "public BenchmarkTreeSets(int numThreads, int numMilis, CSVDatabase csvdb, int writePerMil) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "ConcurrentLinkedQueue",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [
        "ReentrantLockTreeSet",
        "CopyOnWriteLockTreeSet",
        "mqwfTreeSet.addAll",
        "StampedLockTreeSet",
        "add",
        "CRWWPLockTreeSet",
        "casTreeSet.addAll",
        "LeftRightTreeSet",
        "ConcurrentLinkedQueue",
        "addAll",
        "CopyOnWriteMQLFTreeSet",
        "mqlfTreeSet.addAll",
        "CopyOnWriteMQWFTreeSet",
        "clq.add",
        "out.println",
        "leftRightTreeSet.addAll",
        "UserData",
        "crwwpTreeSet.addAll",
        "cowlockTreeSet.addAll",
        "println",
        "CopyOnWriteCASTreeSet",
        "mutexTreeSet.addAll",
        "stampedTreeSet.addAll"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 43,
      "source_code": "        clq = new ConcurrentLinkedQueue<UserData>();\n        mutexTreeSet = new ReentrantLockTreeSet<UserData>();\n        stampedTreeSet = new StampedLockTreeSet<UserData>();\n        crwwpTreeSet = new CRWWPLockTreeSet<UserData>();\n        leftRightTreeSet = new LeftRightTreeSet<UserData>();\n        cowlockTreeSet = new CopyOnWriteLockTreeSet<UserData>();\n        casTreeSet = new CopyOnWriteCASTreeSet<UserData>();\n        mqlfTreeSet = new CopyOnWriteMQLFTreeSet<UserData>();\n        mqwfTreeSet = new CopyOnWriteMQWFTreeSet<UserData>();\n        \n        this.numMilis = numMilis;\n        this.csvdb = csvdb;\n        this.writePerMil = writePerMil;\n        udArray = new UserData[numElements];\n        for (int i = 0; i < numElements; i++) {\n            udArray[i] = new UserData();\n            udArray[i].a = i;\n            udArray[i].b = i % 7;\n        }\n                \n        System.out.println(\"Filling up data structures\");\n        for (int i = 0; i < numElements; i++) clq.add(udArray[i]);\n        mutexTreeSet.addAll(clq);\n        stampedTreeSet.addAll(clq);\n        crwwpTreeSet.addAll(clq);\n        leftRightTreeSet.addAll(clq);\n        cowlockTreeSet.addAll(clq);\n        casTreeSet.addAll(clq);\n        mqlfTreeSet.addAll(clq);\n        mqwfTreeSet.addAll(clq);\n\n        workerThreads = new WorkerThread[numThreads];\n        latencyThreads = new LatencyThread[numThreads];\n    }",
      "line_number": 81,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "constructor"
    },
    {
      "name": "performanceTests",
      "signature": "public void performanceTests(int numThreads, int numRuns) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "println"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 40,
      "source_code": "        /* Performance tests */\n        double writePercentage = writePerMil == 0 ? 0 : writePerMil/10.;\n        System.out.println(\"----- numThreads=\" +numThreads+\"  Writes=\"+writePercentage+\"%  numElements=\"+numElements+\"  numRuns=\"+numRuns+\" -----\");        \n        //singleThroughputTest(numThreads, TestCase.ReentrantLockTreeSet, numRuns);\n        //singleThroughputTest(numThreads, TestCase.StampedLockTreeSet, numRuns);\n        //singleThroughputTest(numThreads, TestCase.CRWWPLockTreeSet, numRuns);\n        //singleThroughputTest(numThreads, TestCase.LeftRightTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteLockTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteCASTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteMQLFTreeSet, numRuns);\n        singleThroughputTest(numThreads, TestCase.CopyOnWriteMQWFTreeSet, numRuns);\n        System.out.println(); \n    }",
      "line_number": 122,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "singleThroughputTest",
      "signature": "public void singleThroughputTest(int numThreads, TestCase type, int numRuns) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "addRunDedicated",
        "length",
        "Thread.sleep",
        "csvdb.addRun",
        "join",
        "out.print",
        "Arrays.sort",
        "type.toString",
        "e.printStackTrace",
        "sort",
        "start",
        "printStackTrace",
        "out.println",
        "print",
        "addRun",
        "csvdb.addRunDedicated",
        "copyOf",
        "substring",
        "toString",
        "sleep",
        "println",
        "WorkerThread",
        "Arrays.copyOf"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 62,
      "source_code": "        // If we see an error here just increase the number of spaces\n        String indentedName = type.toString() + \"                           \".substring(type.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n        long[] numAddRemoves = new long[numRuns];\n        long[] numContains = new long[numRuns];\n\n        for (int irun = 0; irun < numRuns; irun++) {\n            // Create the threads and then start them all in one go\n            for (int i = 0; i < numThreads; i++) {\n                workerThreads[i] = new WorkerThread(type, i);\n            }\n            for (int i = 0; i < numThreads; i++) workerThreads[i].start();\n    \n            // Sleep for 10 seconds\n            try {\n                Thread.sleep(numMilis);\n            } catch(InterruptedException e) {\n                System.out.println(\"InterruptedException\");\n            }\n            for (int i = 0; i < numThreads; i++) workerThreads[i].quit = true;\n                   \n            try {\n                for (int i = 0; i < numThreads; i++) workerThreads[i].join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            \n            numAddRemoves[irun] = 0;\n            numContains[irun] = 0;\n            for (int i = 0; i < numThreads; i++) {\n                numAddRemoves[irun] += workerThreads[i].numAddRemoves;\n                numContains[irun] += workerThreads[i].numContains;\n            }\n        }\n        \n        // Now compute the median\n        int medianRun = numRuns/2; // numRuns should be an odd number\n        long medianAddRemoves = 0;\n        long medianContains = 0;\n        if (numContains[0] != 0) {\n            long[] sortedCopy = Arrays.copyOf(numContains, numContains.length);\n            Arrays.sort(sortedCopy);\n            for (int irun = 0; irun < numRuns; irun++) {\n                if (sortedCopy[medianRun] == numContains[irun]) {\n                    medianAddRemoves = numAddRemoves[irun];\n       ",
      "line_number": 141,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "singleLatencyTest",
      "signature": "public void singleLatencyTest(TestCase type) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "Thread",
        "final"
      ],
      "dependencies": [
        "join",
        "out.print",
        "out.println",
        "sleep",
        "print",
        "println",
        "type.toString",
        "e.printStackTrace",
        "LatencyThread",
        "length",
        "Thread.sleep",
        "substring",
        "start",
        "printStackTrace",
        "toString"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 139,
      "source_code": "        \n        // If we see an error here just increase the number of spaces\n        String indentedName = type.toString() + \"                           \".substring(type.toString().length());\n        System.out.print(\"##### \"+indentedName+\" #####  \");\n\n        // Create 16 threads and then start them all in one go\n        int numThreads = 16;\n        latencyThreads[0] = new LatencyThread(type, 0, true);\n        latencyThreads[1] = new LatencyThread(type, 1, true);\n        latencyThreads[2] = new LatencyThread(type, 2, true);\n        latencyThreads[3] = new LatencyThread(type, 3, true);\n        latencyThreads[4] = new LatencyThread(type, 4, true);\n        latencyThreads[5] = new LatencyThread(type, 5, true);\n        latencyThreads[6] = new LatencyThread(type, 6, true);\n        latencyThreads[7] = new LatencyThread(type, 7, true);\n        latencyThreads[8] = new LatencyThread(type, 8, false);\n        latencyThreads[9] = new LatencyThread(type, 9, false);\n        latencyThreads[10] = new LatencyThread(type, 10, false);\n        latencyThreads[11] = new LatencyThread(type, 11, false);\n        latencyThreads[12] = new LatencyThread(type, 12, false);\n        latencyThreads[13] = new LatencyThread(type, 13, false);\n        latencyThreads[14] = new LatencyThread(type, 14, false);\n        latencyThreads[15] = new LatencyThread(type, 15, false);\n        for (int i = 0; i < numThreads; i++) latencyThreads[i].start();\n\n        // Sleep for 10 seconds\n        try {\n            Thread.sleep(numMilis);\n        } catch(InterruptedException e) {\n            System.out.println(\"InterruptedException\");\n        }\n        for (int i = 0; i < numThreads; i++) latencyThreads[i].quit = true;\n               \n        try {\n            for (int i = 0; i < numThreads; i++) latencyThreads[i].join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        // Aggregate the CONTAINS histograms from all the Reader threads\n        final double[] contai",
      "line_number": 216,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "randomLong",
      "signature": "public static long randomLong(long x) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        x ^= (x << 21);\n        x ^= (x >>> 35);\n        x ^= (x << 4);\n        return x;\n    }",
      "line_number": 338,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "WorkerThread",
      "signature": "public WorkerThread(TestCase type, int tid) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "Thread"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 2,
      "source_code": "            this.type = type;   \n            this.tid = tid;\n        }",
      "line_number": 356,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [
        "cowlockTreeSet.add",
        "mqwfTreeSet.contains",
        "casTreeSet.contains",
        "stampedTreeSet.add",
        "cowlockTreeSet.remove",
        "stampedTreeSet.contains",
        "casTreeSet.remove",
        "leftRightTreeSet.contains",
        "mqlfTreeSet.contains",
        "stampedTreeSet.remove",
        "mqwfTreeSet.add",
        "add",
        "mqwfTreeSet.remove",
        "crwwpTreeSet.remove",
        "cowlockTreeSet.contains",
        "System.nanoTime",
        "mqlfTreeSet.add",
        "mutexTreeSet.contains",
        "casTreeSet.add",
        "crwwpTreeSet.contains",
        "nanoTime",
        "contains",
        "crwwpTreeSet.add",
        "mutexTreeSet.add",
        "leftRightTreeSet.remove",
        "mqlfTreeSet.remove",
        "remove",
        "leftRightTreeSet.add",
        "mutexTreeSet.remove"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 58,
      "source_code": "            long xrand = System.nanoTime();\n            long x;\n            \n            while (!quit) {\n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                \n                UserData ud = udArray[(int)(x % numElements)];\n                \n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                \n                UserData ud1 = udArray[(int)(x % numElements)];\n                if ((writePerMil==-1 && (tid == 0 || tid == 1)) || \n                     (writePerMil != 0 && (x%1000) < writePerMil)) {\n                    // These two threads are doing remove/add\n                    switch (type) {\n                    case ReentrantLockTreeSet:\n                        mutexTreeSet.remove(ud);\n                        mutexTreeSet.add(ud);\n                        break;\n                    case StampedLockTreeSet:\n                        stampedTreeSet.remove(ud);\n                        stampedTreeSet.add(ud);\n                        break;\n                    case LeftRightTreeSet:\n                        leftRightTreeSet.remove(ud);\n                        leftRightTreeSet.add(ud);\n                        break;\n                    case CRWWPLockTreeSet:\n                        crwwpTreeSet.remove(ud);\n                        crwwpTreeSet.add(ud);\n                        break;\n                    case CopyOnWriteLockTreeSet:\n                        cowlockTreeSet.remove(ud);\n                        cowlockTreeSet.add(ud);\n                        break;\n                    case CopyOnWriteCASTreeSet:\n                        casTreeSet.remove(ud);\n                        casTreeSet.add(ud);\n                        break;\n                    case CopyOnWriteMQLFTreeSet:\n                        mqlfTreeSet.remove(ud);\n                        mqlfTreeSet.add(ud);\n                        break;\n                    case CopyO",
      "line_number": 362,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "LatencyThread",
      "signature": "public LatencyThread(TestCase type, int tid, boolean isReader) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "StampedLock",
        "Lock",
        "Thread",
        "ReentrantLock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "reader_writer_lock",
        "thread_local_storage"
      ],
      "complexity_score": 24,
      "source_code": "            this.type = type;   \n            this.tid = tid;\n            this.isReader = isReader;\n            switch (type) {\n            case ReentrantLockTreeSet:\n                this.treeSet = mutexTreeSet;\n                break;\n            case StampedLockTreeSet:\n                this.treeSet = stampedTreeSet;\n                break;\n            case CRWWPLockTreeSet:\n                this.treeSet = crwwpTreeSet;\n                break;\n            case LeftRightTreeSet:\n                this.treeSet = leftRightTreeSet;\n                break;\n            case CopyOnWriteLockTreeSet:\n                this.treeSet = cowlockTreeSet;\n                break;\n            case CopyOnWriteCASTreeSet:\n                this.treeSet = casTreeSet;\n                break;                \n            case CopyOnWriteMQLFTreeSet:\n                this.treeSet = mqlfTreeSet;\n                break;                \n            case CopyOnWriteMQWFTreeSet:\n                this.treeSet = mqwfTreeSet;\n                break;                \n            default:\n                this.treeSet = null;\n                break;\n            }            \n            for (int i = 0; i < MAX_LINEAR_HIST_BINS; i++) {\n                containsLatencyLinearHistogram[i] = 0;\n                addLatencyLinearHistogram[i] = 0;\n                removeLatencyLinearHistogram[i] = 0;\n            }\n        }",
      "line_number": 471,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "thread_management",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "public void run() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "treeSet.add",
        "nanoTime",
        "contains",
        "add",
        "treeSet.remove",
        "treeSet.contains",
        "System.nanoTime",
        "remove"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 6,
      "source_code": "            long xrand = System.nanoTime();\n            long x; \n            \n            while (!quit) {\n                xrand = randomLong(xrand);\n                if (xrand < 0) x = -xrand;\n                else x = xrand;\n                UserData ud = udArray[(int)(x % numElements)];\n                if (!isReader) {\n                    long startBeats = 0, stopBeats = 0, numBeats;\n                    startBeats = System.nanoTime();\n                    treeSet.remove(ud);\n                    stopBeats = System.nanoTime();\n                    numBeats = stopBeats-startBeats;\n                    storeRemoveLinearLatency(numBeats);\n\n                    startBeats = System.nanoTime();\n                    treeSet.add(ud);\n                    stopBeats = System.nanoTime();\n                    numBeats = stopBeats-startBeats;\n                    storeAddLinearLatency(numBeats);\n                } else {                   \n                    long startBeats = System.nanoTime();\n                    treeSet.contains(ud);\n                    long stopBeats = System.nanoTime();\n                    final long numbeats = stopBeats-startBeats;\n                    storeContainsLinearLatency(numbeats);\n                }\n            }\n        }",
      "line_number": 511,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "throughputBenchmark",
      "signature": "static void throughputBenchmark() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Thread",
        "final"
      ],
      "dependencies": [
        "System.gc",
        "Arrays.asList",
        "Thread.sleep",
        "saveDB",
        "gc",
        "getRuntime",
        "performanceTests",
        "Integer",
        "csvdb.saveDB",
        "Runtime.getRuntime",
        "BenchmarkTreeSets",
        "asList",
        "out.println",
        "LinkedList",
        "sleep",
        "println",
        "tests.performanceTests",
        "availableProcessors",
        "CSVDatabase"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 100,
      "source_code": "        //final LinkedList<Integer> threadList = new LinkedList(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 28, 32, 36, 40, 64));\n        //final int numRuns = 5;\n        //final int durationSeconds = 20;\n        final LinkedList<Integer> threadList = new LinkedList(Arrays.asList(4));\n        final int numRuns = 1;  // On the paper it should be 5 runs\n        final int durationSeconds = 10;      // 20 seconds is the default for the paper\n        \n        final CSVDatabase csvdb = new CSVDatabase();      \n        final int sleepGCMiliSeconds = 1000; // Number of miliseconds to sleep between tests for the GC to enter \n        BenchmarkTreeSets tests;\n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n\n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1000, csvdb, 1000);\n            System.gc();\n            Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit                \n            tests.performanceTests(nThreads, numRuns);\n        }  // 50-50-0:  50% add() - 50% remove() - 0% contains() \n\n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1000, csvdb, 500);\n            System.gc();\n            Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit                \n            tests.performanceTests(nThreads, numRuns);\n        }  // 50%\n        \n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1000, csvdb, 100);\n            System.gc();\n            Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit                \n            tests.performanceTests(nThreads, numRuns);\n        }  // 10%\n\n        for (Integer nThreads : threadList) {\n            tests = new BenchmarkTreeSets(nThreads, durationSeconds*1",
      "line_number": 568,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "latencyBenchmark",
      "signature": "static void latencyBenchmark() throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "out.println",
        "sleep",
        "println",
        "tests.singleLatencyTest",
        "System.gc",
        "availableProcessors",
        "CSVDatabase",
        "Runtime.getRuntime",
        "Thread.sleep",
        "gc",
        "singleLatencyTest",
        "BenchmarkTreeSets",
        "getRuntime"
      ],
      "concurrency_patterns": [
        "reader_writer_lock",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        final int durationSeconds = 1000;      // 1000  seconds (16 minutes) is the default for the paper\n        final CSVDatabase csvdb = new CSVDatabase();      \n        final int sleepGCMiliSeconds = 5000; // Number of miliseconds to sleep between tests for the GC to enter \n        System.out.println(\"This system has \" + Runtime.getRuntime().availableProcessors() + \" cores\");\n\n        BenchmarkTreeSets tests = new BenchmarkTreeSets(16, durationSeconds*1000, csvdb, 1000);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds); // sleep for a while second to allow the GC to work a bit\n        tests.singleLatencyTest(TestCase.CopyOnWriteCASTreeSet);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds);\n        tests.singleLatencyTest(TestCase.CopyOnWriteLockTreeSet);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds);\n        tests.singleLatencyTest(TestCase.CopyOnWriteMQLFTreeSet);\n        System.gc();\n        Thread.sleep(sleepGCMiliSeconds);\n        tests.singleLatencyTest(TestCase.CopyOnWriteMQWFTreeSet);\n    }",
      "line_number": 635,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "main",
      "signature": "public static void main(String[] args)  throws InterruptedException {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/BenchmarkTreeSets.java",
      "language": "java",
      "sync_primitives": [
        "static"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        throughputBenchmark();\n        //latencyBenchmark();\n    }",
      "line_number": 660,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "BenchmarkTreeSets",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "get",
        "ref.get"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return ref.get().contains(key);\n    }",
      "line_number": 56,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "add",
        "TreeSet",
        "E",
        "get",
        "ref.compareAndSet",
        "ref.get",
        "newTreeSet.add"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        TreeSet<E> oldTreeSet, newTreeSet;\n        boolean retValue;\n        do {\n            oldTreeSet = ref.get();\n            newTreeSet = new TreeSet<E>(oldTreeSet);\n            retValue = newTreeSet.add(key);\n        } while (!ref.compareAndSet(oldTreeSet, newTreeSet));\n        return retValue;\n    }",
      "line_number": 61,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "TreeSet",
        "get",
        "ref.compareAndSet",
        "newTreeSet.remove",
        "ref.get",
        "remove",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        TreeSet<E> oldTreeSet, newTreeSet;\n        boolean retValue;\n        do {\n            oldTreeSet = ref.get();\n            newTreeSet = new TreeSet<E>(oldTreeSet);\n            retValue = newTreeSet.remove(key);\n        } while (!ref.compareAndSet(oldTreeSet, newTreeSet));\n        return retValue;\n    }",
      "line_number": 73,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteCASTreeSet.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet"
      ],
      "dependencies": [
        "compareAndSet",
        "TreeSet",
        "get",
        "newTreeSet.addAll",
        "ref.compareAndSet",
        "addAll",
        "ref.get",
        "E"
      ],
      "concurrency_patterns": [
        "compare_and_swap",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 3,
      "source_code": "        TreeSet<E> oldTreeSet, newTreeSet;\n        boolean retValue;\n        do {\n            oldTreeSet = ref.get();\n            newTreeSet = new TreeSet<E>(oldTreeSet);\n            retValue = newTreeSet.addAll(c);\n        } while (!ref.compareAndSet(oldTreeSet, newTreeSet));\n        return retValue;\n    }",
      "line_number": 85,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteCASTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet() { super(); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 46,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyableTreeSet",
      "signature": "public CopyableTreeSet(CopyableTreeSet<E> tree) { super(tree); }",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "",
      "line_number": 47,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "copyOf",
      "signature": "public Object copyOf() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return new CopyableTreeSet<E>(this);\n        }",
      "line_number": 49,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "CopyOnWriteMQLFTreeSet",
      "signature": "public CopyOnWriteMQLFTreeSet() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "CopyableTreeSet",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        super(new CopyableTreeSet<E>());\n    }",
      "line_number": 54,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "constructor"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "contains",
        "instance.contains"
      ],
      "concurrency_patterns": [
        "singleton_pattern"
      ],
      "complexity_score": 0,
      "source_code": "        return combinedRef.instance.contains(key);\n    }",
      "line_number": 61,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.add",
        "add",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.add(_key));\n    }",
      "line_number": 68,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(E key) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "tree.remove",
        "remove",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(key, null, null, (E _key, Collection<? extends E> _nop1, E _nop2, TreeSet<E> tree) -> tree.remove(_key));\n    }",
      "line_number": 75,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/papers/COWMutationQ/CopyOnWriteMQLFTreeSet.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "E",
        "tree.addAll",
        "addAll"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return applyMutation(null, c, null, (E _nop, Collection<? extends E> _c, E _nop2, TreeSet<E> tree) -> tree.addAll(_c));\n    }",
      "line_number": 82,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "CopyOnWriteMQLFTreeSet",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LazyIndexArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 89,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LazyIndexArrayQueue",
      "method_type": "method"
    },
    {
      "name": "LazyIndexArrayQueue",
      "signature": "public LazyIndexArrayQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LazyIndexArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Node",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final Node<E> startSentinel = new Node<E>(null);\n        head = startSentinel;\n        tail = startSentinel;\n    }",
      "line_number": 117,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LazyIndexArrayQueue",
      "method_type": "constructor"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LazyIndexArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "items.compareAndSet",
        "lazySet",
        "compareAndSet",
        "Node",
        "get",
        "items.get",
        "NullPointerException",
        "casNext",
        "ltail.casNext",
        "enqidx.get",
        "enqidx.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 15,
      "source_code": "        if (item == null) throw new NullPointerException();\n        while (true) {\n            final Node<E> ltail = tail;\n            if (ltail.items.get(BUFFER_SIZE-1) != null) { // This node is full\n                if (ltail != tail) continue;\n                final Node<E> lnext = ltail.next;\n                if (lnext == null) {\n                    final Node<E> newNode = new Node<E>(item);\n                    if (ltail.casNext(null, newNode)) {\n                        casTail(ltail, newNode);\n                        return;\n                    }\n                } else {\n                    casTail(ltail, lnext);\n                }\n                continue;\n            }\n            for (int i=ltail.enqidx.get(); i < BUFFER_SIZE; i++) {\n                if (ltail.items.get(i) != null) continue;\n                if (ltail.items.compareAndSet(i, null, item)) {\n                    ltail.enqidx.lazySet(i+1);\n                    return;\n                }\n                if (ltail != tail) break;\n            }\n        }\n    }",
      "line_number": 130,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LazyIndexArrayQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LazyIndexArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "items.compareAndSet",
        "lazySet",
        "compareAndSet",
        "deqidx.get",
        "get",
        "items.get",
        "deqidx.lazySet",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "        Node<E> lhead = head;\n        Node<E> node = lhead;\n        while (node != null) {\n            if (node.items.get(0) == null) return null;   // This node is empty\n            if (node.items.get(BUFFER_SIZE-1) == taken) { // This node has been drained, check if there is another one\n                node = node.next;\n                continue;\n            }            \n            for (int i=node.deqidx.get(); i < BUFFER_SIZE; i++) {\n                final E item = node.items.get(i);\n                if (item == null) return null;            // This node is empty\n                if (item == taken) continue;\n                if (node.items.compareAndSet(i, item, taken)) {\n                    node.deqidx.lazySet(i+1);\n                    if (node != lhead && head == lhead) casHead(lhead, node);\n                    //lhead.next = lhead;                   // Do self-linking to help the GC\n                    return item;\n                }\n                if (lhead != head) break;\n            }            \n        }\n        return null;                                      // Queue is empty\n    }",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LazyIndexArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LazyIndexArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 187,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LazyIndexArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LazyIndexArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 191,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LazyIndexArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 99,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "Log2ArrayQueue",
      "method_type": "method"
    },
    {
      "name": "Log2ArrayQueue",
      "signature": "public Log2ArrayQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Node",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final Node<E> startSentinel = new Node<E>(null);\n        head = startSentinel;\n        tail = startSentinel;\n    }",
      "line_number": 128,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "Log2ArrayQueue",
      "method_type": "constructor"
    },
    {
      "name": "findFirstNull",
      "signature": "private int findFirstNull(Node<E> node) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "items.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if (node.items.get(0) == null) return 0;\n        int minPos = 0;\n        int maxPos = BUFFER_SIZE-1;\n        while (true) {\n            int pos = (maxPos-minPos)/2 + minPos;\n            if (node.items.get(pos) == null) {\n                maxPos = pos;\n            } else {\n                minPos = pos;\n            }\n            if (maxPos-minPos <= 3) return minPos;\n        }\n    }",
      "line_number": 134,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "Log2ArrayQueue",
      "method_type": "method"
    },
    {
      "name": "findLastTaken",
      "signature": "private int findLastTaken(Node<E> node) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "get",
        "items.get",
        "E"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "        if (node.items.get(BUFFER_SIZE-1) == taken) return BUFFER_SIZE-1;\n        int minPos = 0;\n        int maxPos = BUFFER_SIZE-1;\n        while (true) {\n            int pos = (maxPos-minPos)/2 + minPos;\n            if (node.items.get(pos) == taken) {\n                minPos = pos;\n            } else {\n                maxPos = pos;\n            }\n            if (maxPos-minPos <= 3) return minPos;\n        }\n    }",
      "line_number": 149,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "Log2ArrayQueue",
      "method_type": "method"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "items.compareAndSet",
        "compareAndSet",
        "Node",
        "get",
        "items.get",
        "NullPointerException",
        "casNext",
        "ltail.casNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        if (item == null) throw new NullPointerException();\n        while (true) {\n            final Node<E> ltail = tail;\n            if (ltail.items.get(BUFFER_SIZE-1) != null) { // This node is full\n                if (ltail != tail) continue;\n                final Node<E> lnext = ltail.next;\n                if (lnext == null) {\n                    final Node<E> newNode = new Node<E>(item);\n                    if (ltail.casNext(null, newNode)) {\n                        casTail(ltail, newNode);\n                        return;\n                    }\n                } else {\n                    casTail(ltail, lnext);\n                }\n                continue;\n            }\n            // Find the first null entry in items[] and try to CAS from null to item\n            for (int i = findFirstNull(ltail); i < BUFFER_SIZE; i++) {\n                if (ltail.items.get(i) != null) continue;\n                if (ltail.items.compareAndSet(i, null, item)) return;\n                if (ltail != tail) break;\n            }\n        }\n    }",
      "line_number": 171,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "Log2ArrayQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "items.compareAndSet",
        "compareAndSet",
        "get",
        "items.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        Node<E> lhead = head;\n        Node<E> node = lhead;\n        while (node != null) {\n            if (node.items.get(0) == null) return null;   // This node is empty\n            if (node.items.get(BUFFER_SIZE-1) == taken) { // This node has been drained, check if there is another one\n                node = node.next;\n                continue;\n            }            \n            // Find the first non taken entry in items[] and try to CAS from item to taken\n            for (int i = findLastTaken(node); i < BUFFER_SIZE; i++) {\n                final E item = node.items.get(i);\n                if (item == null) return null;            // This node is empty\n                if (item == taken) continue;\n                if (node.items.compareAndSet(i, item, taken)) {\n                    if (node != lhead && head == lhead) casHead(lhead, node);\n                    //lhead.next = lhead;                   // Do self-linking to help the GC\n                    return item;\n                }\n                if (lhead != head) break;\n            }            \n        }\n        return null;                                      // Queue is empty\n    }",
      "line_number": 201,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "Log2ArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 226,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "Log2ArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/Log2ArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 230,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "Log2ArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/FAAArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 99,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "FAAArrayQueue",
      "method_type": "method"
    },
    {
      "name": "FAAArrayQueue",
      "signature": "public FAAArrayQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/FAAArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "enqidx.set",
        "Node",
        "E",
        "set"
      ],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        final Node<E> sentinelNode = new Node<E>(null);\n        sentinelNode.enqidx.set(0);\n        head = sentinelNode;\n        tail = sentinelNode;\n    }",
      "line_number": 127,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FAAArrayQueue",
      "method_type": "constructor"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/FAAArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "getAndIncrement",
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "enqidx.getAndIncrement",
        "items.compareAndSet",
        "compareAndSet",
        "Node",
        "NullPointerException",
        "casNext",
        "ltail.casNext",
        "getAndIncrement",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 11,
      "source_code": "        if (item == null) throw new NullPointerException();\n        while (true) {\n            final Node<E> ltail = tail;\n            final int idx = ltail.enqidx.getAndIncrement();\n            if (idx > BUFFER_SIZE-1) { // This node is full\n                if (ltail != tail) continue;\n                final Node<E> lnext = ltail.next;\n                if (lnext == null) {\n                    final Node<E> newNode = new Node<E>(item);\n                    if (ltail.casNext(null, newNode)) {\n                        casTail(ltail, newNode);\n                        return;\n                    }\n                } else {\n                    casTail(ltail, lnext);\n                }\n                continue;\n            }\n            if (ltail.items.compareAndSet(idx, null, item)) return;\n        }\n    }",
      "line_number": 140,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FAAArrayQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/FAAArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final",
        "getAndIncrement",
        "getAndSet"
      ],
      "dependencies": [
        "items.getAndSet",
        "deqidx.getAndIncrement",
        "deqidx.get",
        "get",
        "getAndSet",
        "enqidx.get",
        "getAndIncrement",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "        while (true) {\n            Node<E> lhead = head;\n            if (lhead.deqidx.get() >= lhead.enqidx.get() && lhead.next == null) return null;\n            final int idx = lhead.deqidx.getAndIncrement();\n            if (idx > BUFFER_SIZE-1) { // This node has been drained, check if there is another one\n                if (lhead.next == null) return null;  // No more nodes in the queue\n                casHead(lhead, lhead.next);\n                continue;\n            }\n            final E item = lhead.items.getAndSet(idx, taken); // We can use a CAS instead\n            if (item != null) return item; \n        }\n    }",
      "line_number": 167,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "FAAArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/FAAArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 183,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "FAAArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/FAAArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 187,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "FAAArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casNext",
      "signature": "boolean casNext(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LinearArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }",
      "line_number": 86,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LinearArrayQueue",
      "method_type": "method"
    },
    {
      "name": "LinearArrayQueue",
      "signature": "public LinearArrayQueue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LinearArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "Node",
        "E"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": "        final Node<E> startSentinel = new Node<E>(null);\n        head = startSentinel;\n        tail = startSentinel;\n    }",
      "line_number": 115,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LinearArrayQueue",
      "method_type": "constructor"
    },
    {
      "name": "enqueue",
      "signature": "public void enqueue(E item) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LinearArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "items.compareAndSet",
        "compareAndSet",
        "Node",
        "get",
        "items.get",
        "NullPointerException",
        "casNext",
        "ltail.casNext",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "        if (item == null) throw new NullPointerException();\n        while (true) {\n            final Node<E> ltail = tail;\n            if (ltail.items.get(BUFFER_SIZE-1) != null) { // This node is full\n                if (ltail != tail) continue;\n                final Node<E> lnext = ltail.next;\n                if (lnext == null) {\n                    final Node<E> newNode = new Node<E>(item);\n                    if (ltail.casNext(null, newNode)) {\n                        casTail(ltail, newNode);\n                        return;\n                    }\n                } else {\n                    casTail(ltail, lnext);\n                }\n                continue;\n            }\n            // Find the first null entry in items[] and try to CAS from null to item\n            for (int i=0; i < BUFFER_SIZE; i++) {\n                if (ltail.items.get(i) != null) continue;\n                if (ltail.items.compareAndSet(i, null, item)) return;\n                if (ltail != tail) break;\n            }\n        }\n    }",
      "line_number": 130,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LinearArrayQueue",
      "method_type": "method"
    },
    {
      "name": "dequeue",
      "signature": "public E dequeue() {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LinearArrayQueue.java",
      "language": "java",
      "sync_primitives": [
        "compareAndSet",
        "final"
      ],
      "dependencies": [
        "items.compareAndSet",
        "compareAndSet",
        "get",
        "items.get",
        "E"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "compare_and_swap",
        "producer_consumer",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "        Node<E> lhead = head;\n        Node<E> node = lhead;\n        while (node != null) {\n            if (node.items.get(0) == null) return null;   // This node is empty\n            if (node.items.get(BUFFER_SIZE-1) == taken) { // This node has been drained, check if there is another one\n                node = node.next;\n                continue;\n            }            \n            // Find the first non taken entry in items[] and try to CAS from item to taken\n            for (int i=0; i < BUFFER_SIZE; i++) {\n                final E item = node.items.get(i);\n                if (item == null) return null;            // This node is empty\n                if (item == taken) continue;\n                if (node.items.compareAndSet(i, item, taken)) {\n                    if (node != lhead && head == lhead) casHead(lhead, node);\n                    //lhead.next = lhead;                   // Do self-linking to help the GC\n                    return item;\n                }\n                if (lhead != head) break;\n            }            \n        }\n        return null;                                      // Queue is empty\n    }",
      "line_number": 162,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "LinearArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casTail",
      "signature": "private boolean casTail(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LinearArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);\n    }",
      "line_number": 187,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LinearArrayQueue",
      "method_type": "method"
    },
    {
      "name": "casHead",
      "signature": "private boolean casHead(Node<E> cmp, Node<E> val) {",
      "file_path": "cloned_repositories/pramalhe_ConcurrencyFreaks/Java/com/concurrencyfreaks/queues/array/LinearArrayQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "compareAndSwapObject",
        "UNSAFE.compareAndSwapObject",
        "E"
      ],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);\n    }",
      "line_number": 191,
      "repository": "pramalhe/ConcurrencyFreaks",
      "test_files": [],
      "test_functions": [],
      "domain": "atomic_operations",
      "class_name": "LinearArrayQueue",
      "method_type": "method"
    }
  ]
}