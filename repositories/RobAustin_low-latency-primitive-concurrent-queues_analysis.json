{
  "repository": "RobAustin/low-latency-primitive-concurrent-queues",
  "analysis_date": "2025-06-09",
  "total_functions": 105,
  "functions_with_tests": 0,
  "test_coverage_percentage": 0.0,
  "total_test_functions": 0,
  "functions_by_domain": {
    "producer_consumer": 54,
    "data_structures": 26,
    "synchronization": 17,
    "general": 8
  },
  "functions_by_complexity": {
    "low": 69,
    "medium": 27,
    "high": 9,
    "very_high": 0
  },
  "functions_by_type": {
    "method": 103,
    "constructor": 2
  },
  "test_type_distribution": {},
  "top_sync_primitives": {
    "final": 53,
    "Lock": 52,
    "lock": 52,
    "volatile": 44,
    "BlockingQueue": 4,
    "Thread": 3,
    "wait": 3,
    "Condition": 3,
    "ArrayBlockingQueue": 2
  },
  "concurrency_patterns": {
    "thread_local_storage": 61,
    "immutable_object": 53,
    "producer_consumer": 37,
    "double_checked_locking": 30,
    "future_pattern": 27,
    "lock_free_algorithm": 3,
    "singleton_pattern": 1
  },
  "functions": [
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "put",
        "queue.put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": " *       queue.put(1);\n *       }",
      "line_number": 53,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "queue.take",
        "take"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": " *           final int value = queue.take();\n *       }",
      "line_number": 61,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingIntQueue",
      "signature": "public ConcurrentBlockingIntQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "\n    }",
      "line_number": 88,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingIntQueue",
      "signature": "public ConcurrentBlockingIntQueue(int size) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(size);\n    }",
      "line_number": 95,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(int value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\n        // volatile read\n        final int writeLocation = this.producerWriteLocation;\n\n        final int nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation);\n\n        // purposely not volatile\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 115,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "take",
      "signature": "public int take() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpace(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final int value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 135,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(int value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int writeLocation = this.producerWriteLocation;\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity - 1) {\n\n            if (readLocation == 0)\n                return false;\n\n        } else if (nextWriteLocation + 1 == readLocation)\n            return false;\n\n        // purposely not volatile see the comment below\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 186,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public void put(int value) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int writeLocation1 = this.producerWriteLocation;\n        final int nextWriteLocation = blockForWriteSpace(writeLocation1);\n\n        // purposely not volatile see the comment below\n        data[writeLocation1] = value;\n\n        setWriteLocation(nextWriteLocation);\n    }",
      "line_number": 217,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(int o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "\n        int readLocation = this.readLocation;\n        int writeLocation = this.writeLocation;\n\n        for (; ; ) {\n\n            if (readLocation == writeLocation)\n                return false;\n\n            if (o == data[readLocation])\n                return true;\n\n            // sets the readLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        }\n\n\n    }",
      "line_number": 321,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(int[] target) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return drainTo(target, target.length);\n    }",
      "line_number": 362,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(int[] target, int maxElements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingIntQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        int readLocation = this.consumerReadLocation;\n\n        int i = 0;\n\n        // to reduce the number of volatile reads we are going to perform a kind of double check reading on the volatile write location\n        int writeLocation = this.writeLocation;\n\n        do {\n\n            // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka size()=0)\n            // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n            if (writeLocation == readLocation) {\n\n                writeLocation = this.writeLocation;\n\n\n                if (writeLocation == readLocation) {\n\n                    setReadLocation(readLocation);\n                    return i;\n                }\n            }\n\n\n            // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n            // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n            target[i] = data[readLocation];\n\n\n        } while (i <= maxElements);\n\n        setReadLocation(readLocation);\n\n        return maxElements;\n    }",
      "line_number": 386,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "put",
        "queue.put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": " *       queue.put(1);\n *       }",
      "line_number": 54,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "queue.take",
        "take"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": " *           final int value = queue.take();\n *       }",
      "line_number": 62,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingShortQueue",
      "signature": "public ConcurrentBlockingShortQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "\n    }",
      "line_number": 89,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingShortQueue",
      "signature": "public ConcurrentBlockingShortQueue(int capacity) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(capacity);\n    }",
      "line_number": 96,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(short value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\n        // volatile read\n        final int writeLocation = this.producerWriteLocation;\n\n        final int nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation);\n\n        // purposely not volatile\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 116,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "take",
      "signature": "public short take() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpace(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final short value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 137,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(short value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int writeLocation = this.producerWriteLocation;\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity - 1) {\n\n            if (readLocation == 0)\n                return false;\n\n        } else if (nextWriteLocation + 1 == readLocation)\n            return false;\n\n        // purposely not volatile see the comment below\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 188,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public void put(short value) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int writeLocation1 = this.producerWriteLocation;\n        final int nextWriteLocation = blockForWriteSpace(writeLocation1);\n\n        // purposely not volatile see the comment below\n        data[writeLocation1] = value;\n\n        setWriteLocation(nextWriteLocation);\n    }",
      "line_number": 219,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(int o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "\n        int readLocation = this.readLocation;\n        int writeLocation = this.writeLocation;\n\n        for (; ; ) {\n\n            if (readLocation == writeLocation)\n                return false;\n\n            if (o == data[readLocation])\n                return true;\n\n            // sets the readLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        }\n\n\n    }",
      "line_number": 323,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(short[] target) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return drainTo(target, target.length);\n    }",
      "line_number": 364,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(short[] target, int maxElements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingShortQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        int readLocation = this.consumerReadLocation;\n\n        int i = 0;\n\n        // to reduce the number of volatile reads we are going to perform a kind of double check reading on the volatile write location\n        int writeLocation = this.writeLocation;\n\n        do {\n\n            // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka capacity()=0)\n            // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n            if (writeLocation == readLocation) {\n\n                writeLocation = this.writeLocation;\n\n\n                if (writeLocation == readLocation) {\n\n                    setReadLocation(readLocation);\n                    return i;\n                }\n            }\n\n\n            // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n            // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n            target[i] = data[readLocation];\n\n\n        } while (i <= maxElements);\n\n        setReadLocation(readLocation);\n\n        return maxElements;\n    }",
      "line_number": 388,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "put",
        "queue.put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": " *       queue.put(1);\n *       }",
      "line_number": 54,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "queue.take",
        "take"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": " *           final int value = queue.take();\n *       }",
      "line_number": 62,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingLongQueue",
      "signature": "public ConcurrentBlockingLongQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "\n    }",
      "line_number": 88,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingLongQueue",
      "signature": "public ConcurrentBlockingLongQueue(int capacity) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(capacity);\n    }",
      "line_number": 95,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(long value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\n        // volatile read\n        final int writeLocation = this.producerWriteLocation;\n\n        final int nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation);\n\n        // purposely not volatile\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 115,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "take",
      "signature": "public long take() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpace(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final long value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 136,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(long value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int writeLocation = this.producerWriteLocation;\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity - 1) {\n\n            if (readLocation == 0)\n                return false;\n\n        } else if (nextWriteLocation + 1 == readLocation)\n            return false;\n\n        // purposely not volatile see the comment below\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 184,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public void put(long value) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int writeLocation1 = this.producerWriteLocation;\n        final int nextWriteLocation = blockForWriteSpace(writeLocation1);\n\n        // purposely not volatile see the comment below\n        data[writeLocation1] = value;\n\n        setWriteLocation(nextWriteLocation);\n    }",
      "line_number": 215,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(int o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "\n        int readLocation = this.readLocation;\n        int writeLocation = this.writeLocation;\n\n        for (; ; ) {\n\n            if (readLocation == writeLocation)\n                return false;\n\n            if (o == data[readLocation])\n                return true;\n\n            // sets the readLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        }\n\n\n    }",
      "line_number": 324,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(long[] target) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return drainTo(target, target.length);\n    }",
      "line_number": 365,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(long[] target, int maxElements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingLongQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        int readLocation = this.consumerReadLocation;\n\n        int i = 0;\n\n        // to reduce the number of volatile reads we are going to perform a kind of double check reading on the volatile write location\n        int writeLocation = this.writeLocation;\n\n        do {\n\n            // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka capacity()=0)\n            // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n            if (writeLocation == readLocation) {\n\n                writeLocation = this.writeLocation;\n\n\n                if (writeLocation == readLocation) {\n\n                    setReadLocation(readLocation);\n                    return i;\n                }\n            }\n\n\n            // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n            // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n            target[i] = data[readLocation];\n\n\n        } while (i <= maxElements);\n\n        setReadLocation(readLocation);\n\n        return maxElements;\n    }",
      "line_number": 389,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "AbstractBlockingQueue",
      "signature": "public AbstractBlockingQueue(int capacity) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "BlockingQueue"
      ],
      "dependencies": [
        "IllegalArgumentException"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 5,
      "source_code": "        if (capacity == 0)\n            throw new IllegalArgumentException();\n        this.capacity = capacity + 1;\n    }",
      "line_number": 64,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "AbstractBlockingQueue",
      "method_type": "constructor"
    },
    {
      "name": "AbstractBlockingQueue",
      "signature": "public AbstractBlockingQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "BlockingQueue"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 4,
      "source_code": "        this.capacity = 1024;\n    }",
      "line_number": 74,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "AbstractBlockingQueue",
      "method_type": "constructor"
    },
    {
      "name": "setWriteLocation",
      "signature": "void setWriteLocation(int nextWriteLocation) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Thread"
      ],
      "dependencies": [
        "unsafe.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "\n\n        // putOrderedInt wont immediately make the updates available, even on this thread, so will update the field so the change is immediately visible to, at least this thread. ( note the field is non volatile )\n        this.producerWriteLocation = nextWriteLocation;\n\n        // the line below, is where the write memory barrier occurs,\n        // we have just written back the data in the line above ( which is not require to have a memory barrier as we will be doing that in the line below\n\n        // write back the next write location\n        unsafe.putOrderedInt(this, WRITE_LOCATION_OFFSET, nextWriteLocation);\n    }",
      "line_number": 79,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "setReadLocation",
      "signature": "void setReadLocation(int nextReadLocation) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Thread"
      ],
      "dependencies": [
        "unsafe.putOrderedInt",
        "putOrderedInt"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "thread_local_storage"
      ],
      "complexity_score": 12,
      "source_code": "\n        // putOrderedInt wont immediately make the updates available, even on this thread, so will update the field so the change is immediately visible to, at least this thread. ( note the field is non volatile )\n        this.consumerReadLocation = nextReadLocation;\n\n        // the write memory barrier will occur here, as we are storing the nextReadLocation\n        unsafe.putOrderedInt(this, READ_LOCATION_OFFSET, nextReadLocation);\n    }",
      "line_number": 92,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockAtTake",
      "signature": "private void blockAtTake() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 4,
      "source_code": "    }",
      "line_number": 104,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockAtTake",
      "signature": "private boolean blockAtTake(long timeoutAt) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "System.nanoTime",
        "nanoTime"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 4,
      "source_code": "        return timeoutAt > System.nanoTime();\n    }",
      "line_number": 112,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockAtAdd",
      "signature": "private void blockAtAdd() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "    }",
      "line_number": 119,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockAtAdd",
      "signature": "boolean blockAtAdd(long timeoutAt) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "System.nanoTime",
        "nanoTime"
      ],
      "concurrency_patterns": [],
      "complexity_score": 4,
      "source_code": "        return timeoutAt > System.nanoTime();\n    }",
      "line_number": 127,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "getNextWriteLocationThrowIfFull",
      "signature": "int getNextWriteLocationThrowIfFull(int writeLocation) throws IllegalStateException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "volatile",
        "Lock",
        "final",
        "lock"
      ],
      "dependencies": [
        "IllegalStateException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 17,
      "source_code": "\n        // we want to minimize the number of volatile reads, so we read the writeLocation just once.\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity) {\n\n            if (readLocation == 0)\n                throw new IllegalStateException(\"queue is full\");\n\n        } else if (nextWriteLocation == readLocation)\n            // this condition handles the case general case where the read is at the start of the backing array and we are at the end,\n            // blocks as our backing array is full, we will wait for a read, ( which will cause a change on the read location )\n            throw new IllegalStateException(\"queue is full\");\n\n        return nextWriteLocation;\n    }",
      "line_number": 174,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockForWriteSpaceInterruptibly",
      "signature": "int blockForWriteSpaceInterruptibly(int writeLocation) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "volatile",
        "Lock",
        "final",
        "Thread",
        "lock"
      ],
      "dependencies": [
        "Thread.interrupted",
        "InterruptedException",
        "interrupted"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 42,
      "source_code": "\n        // we want to minimize the number of volatile reads, so we read the writeLocation just once.\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity)\n\n            while (readLocation == 0) {\n\n                if (Thread.interrupted())\n                    throw new InterruptedException();\n\n\n                // // this condition handles the case where writer has caught up with the read,\n                // we will wait for a read, ( which will cause a change on the read location )\n                blockAtAdd();\n\n            }\n        else\n\n\n            while (nextWriteLocation == readLocation) {\n\n                if (Thread.interrupted())\n                    throw new InterruptedException();\n\n                // this condition handles the case general case where the read is at the start of the backing array and we are at the end,\n                // blocks as our backing array is full, we will wait for a read, ( which will cause a change on the read location )\n                blockAtAdd();\n\n            }\n        return nextWriteLocation;\n    }",
      "line_number": 199,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockForWriteSpace",
      "signature": "int blockForWriteSpace(int writeLocation) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "wait",
        "Condition",
        "volatile",
        "Lock",
        "final",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "lock_free_algorithm",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // we want to minimize the number of volatile reads, so we read the writeLocation just once.\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity)\n\n            while (readLocation == 0)\n                // // this condition handles the case where writer has caught up with the read,\n                // we will wait for a read, ( which will cause a change on the read location )\n                blockAtAdd();\n\n        else\n\n\n            while (nextWriteLocation == readLocation)\n                // this condition handles the case general case where the read is at the start of the backing array and we are at the end,\n                // blocks as our backing array is full, we will wait for a read, ( which will cause a change on the read location )\n                blockAtAdd();\n\n        return nextWriteLocation;\n    }",
      "line_number": 239,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockForReadSpace",
      "signature": "int blockForReadSpace(long timeout, TimeUnit unit, int readLocation) throws TimeoutException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "nanoTime",
        "toNanos",
        "unit.toNanos",
        "TimeoutException",
        "System.nanoTime"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 23,
      "source_code": "\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        final long timeoutAt = System.nanoTime() + unit.toNanos(timeout);\n\n        // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka size()=0)\n        // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n\n        while (writeLocation == readLocation)\n            if (!blockAtTake(timeoutAt))\n                throw new TimeoutException();\n\n        return nextReadLocation;\n    }",
      "line_number": 273,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockForReadSpace",
      "signature": "int blockForReadSpace(int readLocation) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 22,
      "source_code": "\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka size()=0)\n        // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n        while (writeLocation == readLocation)\n            blockAtTake();\n\n        return nextReadLocation;\n    }",
      "line_number": 297,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "blockForReadSpaceThrowNoSuchElementException",
      "signature": "int blockForReadSpaceThrowNoSuchElementException(int readLocation) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/AbstractBlockingQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 18,
      "source_code": "\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka size()=0)\n        // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n        while (writeLocation == readLocation)\n            throw new NoSuchElementException();\n\n        return nextReadLocation;\n    }",
      "line_number": 317,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "AbstractBlockingQueue",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "queue.take",
        "take"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": " *           final int value = queue.take();\n *       }",
      "line_number": 107,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingByteQueue",
      "signature": "public ConcurrentBlockingByteQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "\n    }",
      "line_number": 148,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingByteQueue",
      "signature": "public ConcurrentBlockingByteQueue(int size) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(size);\n    }",
      "line_number": 155,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(byte value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\n        // volatile read\n        final int writeLocation = this.writeLocation;\n\n        final int nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation);\n\n        // purposely not volatile\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 178,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "take",
      "signature": "public byte take() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // volatile read\n        final int readLocation = this.readLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpace(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final byte value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 201,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(byte value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        // we want to minimize the number of volatile reads, so we read the writeLocation just once.\n        final int writeLocation = this.writeLocation;\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity - 1) {\n\n            if (readLocation == 0)\n                return false;\n\n        } else if (nextWriteLocation + 1 == readLocation)\n            return false;\n\n        // purposely not volatile see the comment below\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 256,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public void put(byte value) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int writeLocation1 = this.writeLocation;\n        final int nextWriteLocation = blockForWriteSpace(writeLocation1);\n\n        // purposely not volatile see the comment below\n        data[writeLocation1] = value;\n\n        setWriteLocation(nextWriteLocation);\n    }",
      "line_number": 288,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(int o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "\n        int readLocation = this.readLocation;\n        int writeLocation = this.writeLocation;\n\n        for (; ; ) {\n\n            if (readLocation == writeLocation)\n                return false;\n\n            if (o == data[readLocation])\n                return true;\n\n            // sets the readLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        }\n\n\n    }",
      "line_number": 403,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(byte[] target) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return drainTo(target, target.length);\n    }",
      "line_number": 447,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(byte[] target, int maxElements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingByteQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // we want to minimize the number of volatile reads, so we read the readLocation just once.\n        int readLocation = this.readLocation;\n\n        int i = 0;\n\n        // to reduce the number of volatile reads we are going to perform a kind of double check reading on the volatile write location\n        int writeLocation = this.writeLocation;\n\n        do {\n\n            // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka size()=0)\n            // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n            if (writeLocation == readLocation) {\n\n                writeLocation = this.writeLocation;\n\n\n                if (writeLocation == readLocation) {\n\n                    setReadLocation(readLocation);\n                    return i;\n                }\n            }\n\n\n            // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n            // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n            target[i] = data[readLocation];\n\n\n        } while (i <= maxElements);\n\n        setReadLocation(readLocation);\n\n        return maxElements;\n    }",
      "line_number": 474,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "put",
        "queue.put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": " *       queue.put(1);\n *       }",
      "line_number": 103,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "queue.take",
        "take"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": " *           final int value = queue.take();\n *       }",
      "line_number": 111,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingObjectQueue",
      "signature": "public ConcurrentBlockingObjectQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "\n    }",
      "line_number": 152,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingObjectQueue",
      "signature": "public ConcurrentBlockingObjectQueue(int capacity) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(capacity);\n    }",
      "line_number": 159,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingObjectQueue",
      "signature": "public ConcurrentBlockingObjectQueue(int capacity, boolean b) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(capacity);\n    }",
      "line_number": 163,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingObjectQueue",
      "signature": "public ConcurrentBlockingObjectQueue(int capacity, boolean b, Collection<Integer> elements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [
        "Integer"
      ],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(capacity);\n    }",
      "line_number": 168,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(E value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\n        // volatile read\n        final int writeLocation = this.producerWriteLocation;\n\n        final int nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation);\n\n        // purposely not volatile\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 175,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "take",
      "signature": "public E take() throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpace(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final E value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 198,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(E value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int writeLocation = this.producerWriteLocation;\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity) {\n\n            if (readLocation == 0)\n                return false;\n\n        } else if (nextWriteLocation == readLocation)\n            return false;\n\n        // purposely not volatile see the comment below\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 242,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public void put(E value) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int writeLocation1 = this.producerWriteLocation;\n        final int nextWriteLocation = blockForWriteSpaceInterruptibly(writeLocation1);\n\n        // purposely not volatile see the comment below\n        data[writeLocation1] = value;\n\n        setWriteLocation(nextWriteLocation);\n    }",
      "line_number": 275,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "poll",
      "signature": "public E poll() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        if (writeLocation == readLocation)\n            return null;\n\n        // purposely not volatile as the read memory barrier occurred when we read 'writeLocation'\n        final E value = data[readLocation];\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 388,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public boolean remove(Object o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "o.equals",
        "System.arraycopy",
        "arraycopy",
        "equals"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 15,
      "source_code": "\n        final E[] newData = (E[]) new Object[capacity];\n\n        boolean hasRemovedItem = false;\n        int read = this.readLocation;\n        int write = this.writeLocation;\n\n        if (read == write)\n            return false;\n\n        int i = 0;\n        if (read < write) {\n\n            for (int location = read; location <= write; location++) {\n                if (o.equals(data[location])) {\n                    hasRemovedItem = true;\n                } else {\n                    newData[i++] = data[location];\n                }\n            }\n\n\n        } else {\n\n            for (int location = read; location < capacity; location++) {\n\n                if (!o.equals(data[location])) {\n                    hasRemovedItem = true;\n                } else {\n                    newData[i++] = data[location];\n                }\n\n            }\n\n            for (int location = 0; location <= write; location++) {\n\n                if (!o.equals(data[location])) {\n                    hasRemovedItem = true;\n                } else {\n                    newData[i++] = data[location];\n                }\n            }\n        }\n\n        if (!hasRemovedItem)\n            return false;\n\n        this.readLocation = 0;\n        this.writeLocation = i;\n        System.arraycopy(newData, 0, data, 0, i);\n\n        return true;\n\n    }",
      "line_number": 407,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "containsAll",
      "signature": "public boolean containsAll(Collection<?> items) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "items.size",
        "size"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 5,
      "source_code": "\n        final int read = readLocation;\n        final int write = writeLocation;\n\n        if (items.size() == 0)\n            return true;\n\n        if (read == write)\n            return false;\n\n        for (Object o : items) {\n            if (!contains(o))\n                return false;\n        }\n\n\n        return true;\n\n    }",
      "line_number": 465,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "addAll",
      "signature": "public boolean addAll(Collection<? extends E> c) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "NullPointerException",
        "this.equals",
        "IllegalArgumentException",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 13,
      "source_code": "\n        if (this.capacity <= 1)\n            throw new NullPointerException(\"You can not add to a queue of Zero Size.\");\n\n        if (this.equals(c))\n            throw new IllegalArgumentException();\n\n        // volatile read\n        final int writeLocation = this.producerWriteLocation;\n        int writeLocation0 = writeLocation;\n        int nextWriteLocation = -1;\n\n        for (E e : c) {\n\n            if (e == null)\n                throw new NullPointerException(\"Element to be added, can not be null.\");\n\n            nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation0);\n\n            // purposely not volatile\n            data[writeLocation0] = e;\n            writeLocation0 = nextWriteLocation;\n        }\n\n        if (nextWriteLocation != -1)\n            setWriteLocation(nextWriteLocation);\n        else\n            return false;\n\n\n        return true;\n\n    }",
      "line_number": 487,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "removeAll",
      "signature": "public boolean removeAll(Collection<?> c) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "contains",
        "c.contains",
        "arraycopy",
        "System.arraycopy"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 15,
      "source_code": "        final E[] newData = (E[]) new Object[capacity];\n\n        boolean hasRemovedItem = false;\n        int read = this.readLocation;\n        int write = this.writeLocation;\n\n        if (read == write)\n            return false;\n\n        int i = 0;\n        if (read < write) {\n\n            for (int location = read; location < write; location++) {\n                if (c.contains(data[location])) {\n                    hasRemovedItem = true;\n                } else {\n                    newData[i++] = data[location];\n                }\n            }\n\n        } else {\n\n            for (int location = read; location < capacity; location++) {\n\n                if (!c.contains(data[location])) {\n                    hasRemovedItem = true;\n                } else {\n                    newData[i++] = data[location];\n                }\n\n            }\n\n            for (int location = 0; location <= write; location++) {\n\n                if (!c.contains(data[location])) {\n                    hasRemovedItem = true;\n                } else {\n                    newData[i++] = data[location];\n                }\n            }\n        }\n\n        if (!hasRemovedItem)\n            return false;\n\n        this.readLocation = 0;\n        this.writeLocation = i;\n        System.arraycopy(newData, 0, data, 0, i);\n\n        return true;\n\n    }",
      "line_number": 523,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "retainAll",
      "signature": "public boolean retainAll(Collection<?> c) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "contains",
        "c.contains",
        "arraycopy",
        "System.arraycopy"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 15,
      "source_code": "\n        final E[] newData = (E[]) new Object[capacity];\n\n        boolean changed = false;\n        int read = this.readLocation;\n        int write = this.writeLocation;\n\n        if (read == write)\n            return false;\n\n        int i = 0;\n        if (read < write) {\n\n            for (int location = read; location < write; location++) {\n                if (c.contains(data[location])) {\n                    newData[i++] = data[location];\n                } else {\n                    changed = true;\n                }\n            }\n\n        } else {\n\n            for (int location = read; location < capacity; location++) {\n\n                if (c.contains(data[location])) {\n                    newData[i++] = data[location];\n                } else {\n                    changed = true;\n                }\n\n\n            }\n\n            for (int location = 0; location <= write; location++) {\n\n                if (c.contains(data[location])) {\n                    newData[i++] = data[location];\n                } else {\n                    changed = true;\n                }\n            }\n        }\n\n        if (changed) {\n\n            this.readLocation = 0;\n            this.writeLocation = i;\n            System.arraycopy(newData, 0, data, 0, i);\n\n            return true;\n        }\n\n        return false;\n\n    }",
      "line_number": 578,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "iterator",
      "signature": "public Iterator<E> iterator() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "NoSuchElementException",
        "E",
        "Iterator"
      ],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 3,
      "source_code": "\n        final E[] objects = (E[]) toArray();\n\n        return new Iterator<E>() {\n\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < objects.length;\n            }\n\n            @Override\n            public E next() {\n                if (!hasNext())\n                    throw new NoSuchElementException();\n                return objects[i++];\n            }\n\n            @Override\n            public void remove() {\n                i++;\n            }\n        };\n\n    }",
      "line_number": 638,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public Object[] toArray() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int read = readLocation;\n        final int write = writeLocation;\n\n        if (read == write)\n            return new Object[]{};\n\n        int i = 0;\n\n        if (read < write) {\n            final Object[] objects = new Object[write - read];\n            for (int location = read; location < write; location++) {\n                objects[i++] = data[location];\n            }\n\n            return objects;\n        }\n\n\n        final Object[] objects = new Object[(capacity - read) + write];\n\n        for (int location = read; location < capacity; location++) {\n            objects[i++] = data[location];\n        }\n\n        for (int location = 0; location < write; location++) {\n            objects[i++] = data[location];\n        }\n\n        return objects;\n    }",
      "line_number": 667,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "toArray",
      "signature": "public <T> T[] toArray(T[] result) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "BlockingQueue",
        "final",
        "ArrayBlockingQueue",
        "lock"
      ],
      "dependencies": [
        "Integer",
        "getClass",
        "getComponentType",
        "newInstance",
        "result.getClass",
        "Arrays.fill",
        "Array.newInstance",
        "T",
        "ArrayBlockingQueue",
        "fill"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "producer_consumer",
        "future_pattern",
        "singleton_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        //  new ArrayBlockingQueue<Integer>(data)\n        final int read = readLocation;\n        int write = writeLocation;\n\n        if (result.length == 0)\n            return result;\n\n        if (read > write)\n            write += capacity;\n\n        int size = write - read;\n\n        if (size > result.length)\n            result = (T[]) java.lang.reflect.Array.newInstance(\n                    result.getClass().getComponentType(), size + 1);\n\n        int i = 0;\n\n        for (int location = read; location < write; location++) {\n            result[i++] = (T) data[location];\n        }\n\n        if (i < result.length - 1) {\n            Arrays.fill((Object[]) result, i, result.length, null);\n        }\n\n        // fill with null\n        return result;\n\n\n    }",
      "line_number": 701,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "remove",
      "signature": "public E remove() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpaceThrowNoSuchElementException(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final E value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n    }",
      "line_number": 747,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "element",
      "signature": "public E element() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [
        "NoSuchElementException"
      ],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 9,
      "source_code": "\n\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        if (writeLocation == readLocation)\n            throw new NoSuchElementException();\n\n        // purposely not volatile as the read memory barrier occurred when we read 'writeLocation'\n        final E value = data[readLocation];\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 765,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "peek",
      "signature": "public E peek() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 1,
      "source_code": "        if (size() == 0)\n            return null;\n        return data[this.consumerReadLocation];\n    }",
      "line_number": 785,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(Object o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "o.equals",
        "NullPointerException",
        "equals"
      ],
      "concurrency_patterns": [
        "double_checked_locking"
      ],
      "complexity_score": 11,
      "source_code": "\n        if (o == null)\n            throw new NullPointerException(\"object can not be null\");\n\n        int read = this.readLocation;\n        int write = this.writeLocation;\n\n\n        if (read == write)\n            return false;\n\n        if (read < write) {\n\n            for (int location = read; location < write; location++) {\n                if (o.equals(data[location]))\n                    return true;\n            }\n\n            return false;\n        }\n\n        for (int location = read; location < capacity; location++) {\n\n            if (o.equals(data[location]))\n                return true;\n        }\n\n        for (int location = 0; location < write; location++) {\n\n            if (o.equals(data[location]))\n                return true;\n        }\n\n\n        return false;\n    }",
      "line_number": 805,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(E[] target) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return drainTo(target, target.length);\n    }",
      "line_number": 866,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(E[] target, int maxElements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        int readLocation = this.consumerReadLocation;\n\n        int i = 0;\n\n        // to reduce the number of volatile reads we are going to perform a kind of double check reading on the volatile write location\n        int writeLocation = this.writeLocation;\n\n        do {\n\n            // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka capacity()=0)\n            // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n            if (writeLocation == readLocation) {\n\n                writeLocation = this.writeLocation;\n\n\n                if (writeLocation == readLocation) {\n\n                    setReadLocation(readLocation);\n                    return i;\n                }\n            }\n\n\n            // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n            // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n            target[i] = data[readLocation];\n\n\n        } while (i <= maxElements);\n\n        setReadLocation(readLocation);\n\n        return maxElements;\n    }",
      "line_number": 893,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "toString",
      "signature": "public String toString() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingObjectQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "BlockingQueue",
        "final",
        "ArrayBlockingQueue",
        "lock"
      ],
      "dependencies": [
        "builder.toString",
        "Integer",
        "builder.length",
        "StringBuilder",
        "builder.append",
        "length",
        "deleteCharAt",
        "builder.deleteCharAt",
        "append",
        "ArrayBlockingQueue",
        "toString"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 8,
      "source_code": "\n\n        //  new ArrayBlockingQueue<Integer>(data)\n        final int read = readLocation;\n        int write = writeLocation;\n\n        if (read == write) {\n            return \"[]\";\n        }\n\n        if (read > write)\n            write += capacity;\n\n        int size = write - read;\n\n        StringBuilder builder = new StringBuilder(\"[\");\n\n        int i = 0;\n\n        for (int location = read; location < write; location++) {\n            builder.append(data[location]).append(',');\n        }\n\n\n        builder.deleteCharAt(builder.length() - 1);\n        builder.append(\"]\");\n\n        return builder.toString();\n\n\n    }",
      "line_number": 935,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "implements",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "put",
        "queue.put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": " *       queue.put(1);\n *       }",
      "line_number": 54,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "queue.take",
        "take"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": " *           final int value = queue.take();\n *       }",
      "line_number": 62,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingDoubleQueue",
      "signature": "public ConcurrentBlockingDoubleQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "\n    }",
      "line_number": 89,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingDoubleQueue",
      "signature": "public ConcurrentBlockingDoubleQueue(int capacity) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(capacity);\n    }",
      "line_number": 96,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(double value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\n        // volatile read\n        final int writeLocation = this.producerWriteLocation;\n\n        final int nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation);\n\n        // purposely not volatile\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 117,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "take",
      "signature": "public double take() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpace(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final double value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 138,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(double value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int writeLocation = this.producerWriteLocation;\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity - 1) {\n\n            if (readLocation == 0)\n                return false;\n\n        } else if (nextWriteLocation + 1 == readLocation)\n            return false;\n\n        // purposely not volatile see the comment below\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 189,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public void put(double value) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int writeLocation1 = this.producerWriteLocation;\n        final int nextWriteLocation = blockForWriteSpace(writeLocation1);\n\n        // purposely not volatile see the comment below\n        data[writeLocation1] = value;\n\n        setWriteLocation(nextWriteLocation);\n    }",
      "line_number": 220,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(int o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "\n        int readLocation = this.readLocation;\n        int writeLocation = this.writeLocation;\n\n        for (; ; ) {\n\n            if (readLocation == writeLocation)\n                return false;\n\n            if (o == data[readLocation])\n                return true;\n\n            // sets the readLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        }\n\n\n    }",
      "line_number": 324,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(double[] target) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return drainTo(target, target.length);\n    }",
      "line_number": 365,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(double[] target, int maxElements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingDoubleQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        int readLocation = this.consumerReadLocation;\n\n        int i = 0;\n\n        // to reduce the number of volatile reads we are going to perform a kind of double check reading on the volatile write location\n        int writeLocation = this.writeLocation;\n\n        do {\n\n            // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka capacity()=0)\n            // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n            if (writeLocation == readLocation) {\n\n                writeLocation = this.writeLocation;\n\n\n                if (writeLocation == readLocation) {\n\n                    setReadLocation(readLocation);\n                    return i;\n                }\n            }\n\n\n            // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n            // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n            target[i] = data[readLocation];\n\n\n        } while (i <= maxElements);\n\n        setReadLocation(readLocation);\n\n        return maxElements;\n    }",
      "line_number": 389,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [
        "put",
        "queue.put"
      ],
      "concurrency_patterns": [
        "producer_consumer"
      ],
      "complexity_score": 0,
      "source_code": " *       queue.put(1);\n *       }",
      "line_number": 54,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "run",
      "signature": "*  public void run() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "final"
      ],
      "dependencies": [
        "queue.take",
        "take"
      ],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object"
      ],
      "complexity_score": 0,
      "source_code": " *           final int value = queue.take();\n *       }",
      "line_number": 62,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingFloatQueue",
      "signature": "public ConcurrentBlockingFloatQueue() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "\n    }",
      "line_number": 89,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "ConcurrentBlockingFloatQueue",
      "signature": "public ConcurrentBlockingFloatQueue(int size) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [],
      "complexity_score": 6,
      "source_code": "        super(size);\n    }",
      "line_number": 96,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "add",
      "signature": "public boolean add(float value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 7,
      "source_code": "\n        // volatile read\n        final int writeLocation = this.producerWriteLocation;\n\n        final int nextWriteLocation = getNextWriteLocationThrowIfFull(writeLocation);\n\n        // purposely not volatile\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 116,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "take",
      "signature": "public float take() {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 16,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int readLocation = this.consumerReadLocation;\n\n        // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextReadLocation = blockForReadSpace(readLocation);\n\n        // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n        final float value = data[readLocation];\n\n        setReadLocation(nextReadLocation);\n\n        return value;\n\n    }",
      "line_number": 136,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "offer",
      "signature": "public boolean offer(float value) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 10,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        final int writeLocation = this.producerWriteLocation;\n\n        // sets the nextWriteLocation my moving it on by 1, this may cause it it wrap back to the start.\n        final int nextWriteLocation = (writeLocation + 1 == capacity) ? 0 : writeLocation + 1;\n\n        if (nextWriteLocation == capacity - 1) {\n\n            if (readLocation == 0)\n                return false;\n\n        } else if (nextWriteLocation + 1 == readLocation)\n            return false;\n\n        // purposely not volatile see the comment below\n        data[writeLocation] = value;\n\n        setWriteLocation(nextWriteLocation);\n        return true;\n    }",
      "line_number": 187,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "put",
      "signature": "public void put(float value) throws InterruptedException {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock",
        "final"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "producer_consumer",
        "immutable_object",
        "thread_local_storage"
      ],
      "complexity_score": 8,
      "source_code": "\n        final int writeLocation1 = this.producerWriteLocation;\n        final int nextWriteLocation = blockForWriteSpace(writeLocation1);\n\n        // purposely not volatile see the comment below\n        data[writeLocation1] = value;\n\n        setWriteLocation(nextWriteLocation);\n    }",
      "line_number": 218,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "producer_consumer",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "contains",
      "signature": "public boolean contains(int o) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "thread_local_storage"
      ],
      "complexity_score": 4,
      "source_code": "\n        int readLocation = this.readLocation;\n        int writeLocation = this.writeLocation;\n\n        for (; ; ) {\n\n            if (readLocation == writeLocation)\n                return false;\n\n            if (o == data[readLocation])\n                return true;\n\n            // sets the readLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n        }\n\n\n    }",
      "line_number": 322,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "data_structures",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(float[] target) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [],
      "dependencies": [],
      "concurrency_patterns": [
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 0,
      "source_code": "        return drainTo(target, target.length);\n    }",
      "line_number": 363,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "general",
      "class_name": "mimics",
      "method_type": "method"
    },
    {
      "name": "drainTo",
      "signature": "int drainTo(float[] target, int maxElements) {",
      "file_path": "cloned_repositories/RobAustin_low-latency-primitive-concurrent-queues/src/main/java/uk/co/boundedbuffer/ConcurrentBlockingFloatQueue.java",
      "language": "java",
      "sync_primitives": [
        "volatile",
        "Lock",
        "lock"
      ],
      "dependencies": [],
      "concurrency_patterns": [
        "double_checked_locking",
        "future_pattern",
        "thread_local_storage"
      ],
      "complexity_score": 35,
      "source_code": "\n        // non volatile read  ( which is quicker )\n        int readLocation = this.consumerReadLocation;\n\n        int i = 0;\n\n        // to reduce the number of volatile reads we are going to perform a kind of double check reading on the volatile write location\n        int writeLocation = this.writeLocation;\n\n        do {\n\n            // in the for loop below, we are blocked reading unit another item is written, this is because we are empty ( aka size()=0)\n            // inside the for loop, getting the 'writeLocation', this will serve as our read memory barrier.\n            if (writeLocation == readLocation) {\n\n                writeLocation = this.writeLocation;\n\n\n                if (writeLocation == readLocation) {\n\n                    setReadLocation(readLocation);\n                    return i;\n                }\n            }\n\n\n            // sets the nextReadLocation my moving it on by 1, this may cause it it wrap back to the start.\n            readLocation = (readLocation + 1 == capacity) ? 0 : readLocation + 1;\n\n            // purposely not volatile as the read memory barrier occurred above when we read 'writeLocation'\n            target[i] = data[readLocation];\n\n\n        } while (i <= maxElements);\n\n        setReadLocation(readLocation);\n\n        return maxElements;\n    }",
      "line_number": 387,
      "repository": "RobAustin/low-latency-primitive-concurrent-queues",
      "test_files": [],
      "test_functions": [],
      "domain": "synchronization",
      "class_name": "mimics",
      "method_type": "method"
    }
  ]
}